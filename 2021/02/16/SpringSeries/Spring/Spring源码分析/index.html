<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>Spring源码分析 - SOBXiong的博客</title>
  
    <meta name="keywords" content="Spring">
  
  
    <meta name="description" content="内容
总体流程
资源加载
解析XML
解析Bean
加载Bean
">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png'></i>
          
          
            SOBXiong
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
      Spring源码分析
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="http://xiongjc.top" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/hdImg_f757fa7e0fd65077ce52d251fc7a01d815860762755.jpg">
    <p>SOBXiong</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2021年2月16日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><a href="#总体流程">总体流程</a></li>
<li><a href="#资源加载">资源加载</a></li>
<li><a href="#解析XML">解析XML</a></li>
<li><a href="#解析Bean">解析Bean</a></li>
<li><a href="#加载Bean">加载Bean</a></li>
</ul>
<a id="more"></a>

<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><ul>
<li><p>说明：本文环境Spring版本5.3.1</p>
</li>
<li><p>分析入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test1.xml"</span>);</span><br><span class="line">  TestBean testBean = context.getBean(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(<span class="string">"testBean = "</span> + testBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassPathXmlApplicationContext构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassPathXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parent);</span><br><span class="line">  setConfigLocations(configLocations);</span><br><span class="line">  <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先调用<code>setConfigLocations(String[])</code>方法设置配置路径<br>接着调用<code>refresh()</code>方法实现扩展功能，其中包括最重要的加载bean容器过程</p>
</blockquote>
</li>
<li><p>setConfigLocations()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableConfigApplicationContext.java</span></span><br><span class="line"><span class="comment">// 设置应用程序上下文的配置路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableConfigApplicationContext.java</span></span><br><span class="line"><span class="comment">// 解析给定的路径,用相应的环境属性值替换占位符($&#123;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 创建应用环境信息,包括SystemProperties以及SystemEnvironment信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>setConfigLocations(String[])</code>方法用于解析给定的路径数组，如果路径中包含占位符(${})，那么会尝试利用系统配置信息和系统环境信息进行解析<br>可能的系统配置信息和系统环境信息如下：<br><img src="placeholderResolver%E5%86%85%E5%AE%B91.png" alt="placeholderResolver内容(1)"><br><img src="placeholderResolver%E5%86%85%E5%AE%B92.png" alt="placeholderResolver内容(2)"></p>
</blockquote>
</li>
<li><p>refresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载或刷新配置的持久表示(可来自基于Java配置、XML文件、属性文件、关系数据库模式或其他格式)</span></span><br><span class="line"><span class="comment"> * 由于这是一个启动方法,如果失败它应该销毁已经创建的单例以避免挂起资源</span></span><br><span class="line"><span class="comment"> * 换句话说,在调用这个方法之后,要么全部实例化,要么根本不实例化</span></span><br><span class="line"><span class="comment"> * 如果无法初始化BeanFactory,抛出BeansException</span></span><br><span class="line"><span class="comment"> * 如果已初始化且不支持多次刷新,抛出IllegalStateException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line">    <span class="comment">// 准备刷新的上下文环境</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// 初始化BeanFactory,进行XML文件读取</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">    <span class="comment">// 对BeanFactory进行各种功能填充</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 子类覆盖方法</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line">      StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">      <span class="comment">// 激活各种BeanFactory处理器</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册拦截Bean创建的处理器(BeanPostProcessor)</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      beanPostProcess.end();</span><br><span class="line">      <span class="comment">// 为上下文初始化Message源,用于国际化处理</span></span><br><span class="line">      initMessageSource();</span><br><span class="line">      <span class="comment">// 初始化应用消息广播器</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line">      <span class="comment">// 刷新结束的回调函数,交由子类实现</span></span><br><span class="line">      onRefresh();</span><br><span class="line">      <span class="comment">// 在注册的Bean中查找Listener类型的bean实例并注册到消息广播器中</span></span><br><span class="line">      registerListeners();</span><br><span class="line">      <span class="comment">// 初始化剩下所有的非惰性单例Bean</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">      <span class="comment">// 完成刷新过程,通知生命周期处理器lifecycleProcessor刷新过程,发出ContextRefreshEvent通知</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> + <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁bean实例</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// 取消刷新</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">      contextRefresh.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>refresh()</code>方法包含了几乎ApplicationContext中提供的全部功能</p>
</blockquote>
</li>
<li><p>prepareRefresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 准备刷新的上下文环境</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录启动时间</span></span><br><span class="line">  <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 设置context状态</span></span><br><span class="line">  <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化上下文环境中任何占位符属性来源</span></span><br><span class="line">  <span class="comment">// 留给子类覆盖</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">  <span class="comment">// 校验需要的配置属性是否已存在于Enviroment中</span></span><br><span class="line">  getEnvironment().validateRequiredProperties();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>prepareRefresh()</code>方法主要有两个较大作用的方法：</p>
<ol>
<li><code>initPropertySources()</code>方法：用户可根据需要重写该方法进行个性化属性处理(如环境变量中必须设置某个值才能运行)，这给予用户了最大扩展Spring能力</li>
<li><code>validateRequiredProperties()</code>方法：对属性进行验证</li>
</ol>
</blockquote>
</li>
<li><p><strong><em>obtainFreshBeanFactory()方法</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 通知子类刷新内部BeanFactory并返回</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化BeanFactory,进行XML文件读取,将BeanFactory赋值给属性</span></span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">// 执行上下文底层BeanFactory的实际刷新：关闭以前可能有的BeanFactory,初始化新的BeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在以前的BeanFactory</span></span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    <span class="comment">// 销毁Bean实例</span></span><br><span class="line">    destroyBeans();</span><br><span class="line">    <span class="comment">// 关闭以前的BeanFactory</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建DefaultListableBeanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    <span class="comment">// 设置序列化id(反序列化用)</span></span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    <span class="comment">// 定制化BeanFactory,设置相关属性(是否允许覆盖名称、是否允许循环依赖)</span></span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 初始化DocumentReader,进行XML文件读取并解析</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ApplicationContext是对BeanFactory功能上的扩展，不但包含BeanFactory的全部功能更在其基础上添加了大量扩展。ApplicationContext通过组合BeanFactory的方式进行复用<br><code>obtainFreshBeanFactory()</code>方法将核心实现委托给<code>refreshBeanFactory()</code>方法</p>
</blockquote>
<ul>
<li><p>createBeanFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">// 为上下文创建内部BeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  setParentBeanFactory(parentBeanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  ignoreDependencyInterface(BeanNameAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ignoreDependencyInterface(BeanFactoryAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ignoreDependencyInterface(BeanClassLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (IN_NATIVE_IMAGE) &#123;</span><br><span class="line">    <span class="keyword">this</span>.instantiationStrategy = <span class="keyword">new</span> SimpleInstantiationStrategy();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>createBeanFactory()</code>方法最终构造了DefaultListableBeanFactory并传入可能有的父容器。在构造器链中，AbstractAutowireCapableBeanFactory的无参构造器中做了一些设置：忽略给定接口的自动装配功能(BeanNameAware.class、BeanFactoryAware.class以及BeanClassLoaderAware.class)、设置Bean实例化策略(instantiationStrategy)</p>
</blockquote>
</li>
<li><p>customizeBeanFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否允许覆盖同名称的不同定义的对象,默认null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否允许bean之间存在循环依赖,默认null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loadBeanDefinitions()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="comment">// 通过XmlBeanDefinitionReader加载BeanDefinition</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为给定的BeanFactory创建XmlBeanDefinitionReader</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的环境变量</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的资源加载器</span></span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的实体解析器</span></span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 初始化BeanDefinitionReader,允许子类覆盖</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  <span class="comment">// 真正执行加载BeanDefinition</span></span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.registry = registry;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = ((EnvironmentCapable) <span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置XML解析的验证方式,默认为true</span></span><br><span class="line">  reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  Resource[] configResources = getConfigResources();</span><br><span class="line">  <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过资源加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configResources);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] configLocations = getConfigLocations();</span><br><span class="line">  <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过配置文件路径加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configLocations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>loadBeanDefinitions()</code>方法创建了XmlBeanDefinitionReader，并对其进行了一系列的设置，接下来将委托该对象进行XML的解析与BeanDefinition的加载工作，这是IOC的核心</p>
</blockquote>
</li>
</ul>
</li>
<li><p>prepareBeanFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 配置BeanFactory的上下文特性,如类加载器和后处理器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置类加载器classLoader</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">    <span class="comment">// 设置BeanFactory的表达式语言处理器(SpEL)</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为BeanFactory设置默认属性编辑器(对bean属性等设置管理的工具)</span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line">  <span class="comment">// 添加ApplicationContextAwareProcessor</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 设置几个忽略自动装配的接口</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationStartup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">// 设置几个自动装配的特殊规则(可自动装配但在BeanFactory中没有定义为Bean)</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  <span class="comment">// 注册早期后处理器ApplicationListenerDetector检查ApplicationListener类型的内部Bean</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 增加对AspectJ的支持</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// 为类型匹配设置临时类加载器</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册默认的系统环境Bean</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>prepareBeanFactory()</code>方法主要填充了BeanFactory的功能(具体参见注释)<br>其中Spring表达式语言全称为Spring Expression Language(SpEL)，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等。SpEL使用#{}作为定界符，大括号中的字符都将被认为是SpEL<br>PropertyEditor属性编辑器用于将XML中的String转为特定类的对象，可以通过继承PropertyEditorSupport类并注册实现该功能<br>xxxAwareProcessor后置处理器用于将实现xxxAware的bean初始化时设置相应的资源<br>xxxAwareProcessor注册后，间接调用的xxxAware类已经不是普通的bean了，因此无需在依赖注入时考虑</p>
</blockquote>
</li>
<li><p>postProcessBeanFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在标准初始化后修改ApplicationContext内部的BeanFactory</span></span><br><span class="line"><span class="comment"> * 将加载所有BeanDefinition,但尚未实例化任何Bean</span></span><br><span class="line"><span class="comment"> * 这允许在特定ApplicationContext实现中注册特定的BeanPostProcessor等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目前空实现,交由子类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>invokeBeanFactoryPostProcessors()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并调用所有已注册的BeanFactoryPostProcessor的Bean实例,按照给定的显式顺序(如果给定)</span></span><br><span class="line"><span class="comment"> * 必须在单例Bean实例化之前调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 委托PostProcessorRegistrationDelegate调用BeanFactoryPostProcessor</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">  <span class="comment">// 检测LoadTimeWeaver并准备将来的方法织入</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有,先调用BeanDefinitionRegistry</span></span><br><span class="line">  Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="comment">// 如果beanFactory是BeanDefinitionRegistry类型</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历硬编码注册的后处理器</span></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        <span class="comment">// 对于BeanDefinitionRegistryPostProcessor类型,在BeanFactoryPostProcessor基础上还有自定义的方法,需要先调用</span></span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        <span class="comment">// 记录BeanDefinitionRegistry</span></span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 记录常规BeanFactoryPostProcessor</span></span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不要在这里初始化Factory Bean：需要将所有常规Bean保持为初始化状态,以便BeanFactoryPostProcessor应用于它们</span></span><br><span class="line"><span class="comment">     * 分离实现PriorityOrdered、Ordered接口和其他的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 首先调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">    <span class="comment">// 接着调用实现了Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">    <span class="comment">// 最终调用所有其他BeanDefinitionRegistryPostProcessor,直到不再出现其他BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">      reiterate = <span class="keyword">false</span>;</span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">          processedBeans.add(ppName);</span><br><span class="line">          reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在调用到目前为止处理的所有处理器的postProcessBeanFactory回调</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用在context实例中注册的工厂处理器</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// 跳过,已在上面第一阶段处理过</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">  <span class="comment">// 清除缓存的MergedBeanDefinition,因为后处理器可能已修改了原始的元数据,例如替换值中的占位符...</span></span><br><span class="line">  beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用给定的BeanDefinitionRegistryPostProcessor类型的Bean实例</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    StartupStep postProcessBeanDefRegistry = applicationStartup.start(<span class="string">"spring.context.beandef-registry.post-process"</span>).tag(<span class="string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">    postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    postProcessBeanDefRegistry.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用给定的BeanFactoryPostProcessor类型的Bean实例</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start(<span class="string">"spring.context.bean-factory.post-process"</span>).tag(<span class="string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">    postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">    postProcessBeanFactory.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于BeanFactoryPostProcessor的处理分两种情况处理，一种是对BeanDefinitionRegistryPostProcessor类的特殊处理，另一种是普通的BeanFactoryPostProcessor的处理。对于每种情况都需要考虑硬编码以及配置注入的后处理器：<br>硬编码注入一般通过AbstractApplicationContext的<code>addBeanFactoryPostProcessor()</code>方法添加<br>接着每种情况都进行排序(除了没实现PriorityOrdered以及Ordered接口)，接着统一调用<code>postProcessBeanDefinitionRegistry()</code>或<code>postProcessBeanFactory()</code>方法</p>
</blockquote>
</li>
<li><p>registerBeanPostProcessors()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并注册所有BeanPostProcessor的Bean实例,按照给定的显式顺序(如果给定)</span></span><br><span class="line"><span class="comment"> * 必须在任何应用程序Bean实例化之前调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取通过配置文件注入的BeanPostProcessor名称</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="comment">// 统计BeanPostProcessor数目：硬编码 + BeanPostProcessorChecker + 配置文件</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  <span class="comment">// 注册BeanPostProcessorChecker,当BeanPostProcessor实例化期间创建bean时(即当一个bean没有资格被所有BeanPostProcessor处理时),它会记录一条信息</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">  <span class="comment">// 分离实现PriorityOrdered、Ordered接口和其他的BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首先注册实现了PriorityOrdered接口的BeanPostProcessor</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">  <span class="comment">// 接着注册实现了Ordered接口的BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">  <span class="comment">// 接着注册所有其他BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line">  <span class="comment">// 最后再注册所有的内部BeanPostProcessor(MergedBeanDefinitionPostProcessor类型)</span></span><br><span class="line">  <span class="comment">// 并非重复注册,addBeanPostProcesor中会先移除已存在的BeanPostProcessor</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">  <span class="comment">// 添加用于检测内部Bean实例为ApplicationListener的后处理器ApplicationListenerDetector,将其移动到处理器链的末端(用于获取代理等)</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="comment">// 批量添加比CopyOnWriteArrayList更有效率</span></span><br><span class="line">    ((AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanPostProcessor, <span class="string">"BeanPostProcessor must not be null"</span>);</span><br><span class="line">  <span class="comment">// 移除旧的BeanPostProcessor</span></span><br><span class="line">  <span class="keyword">this</span>.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">  <span class="comment">// 添加新的BeanPostProcessor到list尾部</span></span><br><span class="line">  <span class="keyword">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对BeanPostProcessor和BeanFactoryPostProcessor处理极为相似，相同的是都根据PriorityOrdered、Ordered接口和其他BeanPostProcessor进行分别注册<br>不同的是BeanPostProcessor不是立刻使用而是注册，因此只需将所有配置注入的BeanPostProcessor加入到BeanFactory的属性中<br>在注册Bean时通过先<code>remove()</code>再<code>add()</code>确保了BeanPostProcessor的唯一性</p>
</blockquote>
</li>
<li><p>initMessageSource()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SOURCE_BEAN_NAME = <span class="string">"messageSource"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化MessageSource</span></span><br><span class="line"><span class="comment"> * 如果当前context没有定义,使用父容器定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 设置父MessageSource</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用空MessageSource以接收getMessage()调用</span></span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No '"</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">"' bean, using ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MessageSource主要用于国际化(i18n)，Spring通过封装JDK的java.util包中几个支持本地化的格式操作工具类NumberFormat、DateFormat、MessageFormat来支持国际化资源操作</p>
</blockquote>
</li>
<li><p>initApplicationEventMulticaster()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> * 如果context未定义,则使用SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    simpleApplicationEventMulticaster.setApplicationStartup(getApplicationStartup());</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = simpleApplicationEventMulticaster;</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> + <span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ApplicationEventMulticaster使用观察者模式，存放监听器并在合适的时候调用监听器(回调)</p>
</blockquote>
</li>
<li><p>onRefresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板方法,可重写该方法(交由子类)以添加特定context的刷新工作</span></span><br><span class="line"><span class="comment"> * 在初始化特殊Bean时调用,在单例Bean实例化之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>registerListeners()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将实现ApplicationListener接口的Bean添加为监听器</span></span><br><span class="line"><span class="comment"> * 不会影响那些被添加但无需成为Bean的其他监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先注册硬编码方法注册的监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不要在这里初始化Factory Bean：需要将所有常规bean保持为未初始化状态以便让后处理器应用于它们</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布早期applicationEvent</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>finishBeanFactoryInitialization()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成此context的BeanFactory的初始化,初始化剩余所有的单例Bean</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为此context初始化转换服务</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    beanFactory.setConversionService(beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前没有注册Bean后处理器(比如PropertyPlaceholderConfigurer)</span></span><br><span class="line">  <span class="comment">// 那么注册一个默认的EmbeddedValueResolver(嵌入值解析器)：此时主要用于annotation(注解)属性值的解析</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尽早初始化LoadTimeWeaverAware以便尽早注册它们的转换器</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 停止使用临时类加载器进行类型匹配</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 运行缓存所有BeanDefinition元数据,预期没有进一步的修改</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line">  <span class="comment">// 实例化所有剩余的单例Bean(不是lazy init(惰性加载))</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保实例化所有非惰性单例Bean,同时考虑到FactoryBeans</span></span><br><span class="line"><span class="comment"> * 如果需要,通过在工厂设置结束时调用</span></span><br><span class="line"><span class="comment"> * 如果无法创建一个单例Bean,则抛出BeansException</span></span><br><span class="line"><span class="comment"> * 注意：这可能使工厂中的一些Bean实例已经初始化</span></span><br><span class="line"><span class="comment"> * 在这种情况下,调用destorySingletons()进行完全清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代副本以允许init方法注册新的BeanDefinition</span></span><br><span class="line">  <span class="comment">// 尽管这不是常规Factory引导的一部分,但它在其他方面工作正常</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">  <span class="comment">// 触发所有非单例Bean的初始化</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发所有适用Bean的初始化后的回调函数</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">"spring.beans.smart-initialize"</span>).tag(<span class="string">"beanName"</span>, beanName);</span><br><span class="line">      SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">      smartInitialize.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>finishBeanFactoryInitialization()</code>方法主要完成BeanFactory的初始化工作，包括ConversionService的设置、配置冻结以及非延迟单例Bean的初始化工作<br>ConversionService为自定义类型的转换器，大部分是将String转换为指定类型的对象<br><code>freezeConfiguration()</code>方法用于配置冻结，说明注册的BeanDefinition将不被修改或进一步的处理<br><code>preInstantiateSingletons()</code>方法用于实例化所有单例Bean，这也是ApplicationContext实现的默认行为</p>
</blockquote>
</li>
<li><p>finishRefresh()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新context的刷新工作,调用LifecycleProcessor的onRefresh()方法并发布ContextRefreshedEvent</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清除上下文级别的资源缓存(例如源于扫描的ASM元数据)</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line">  <span class="comment">// 为context初始化LifecycleProcessor</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line">  <span class="comment">// 首先调用LifecycleProcessor的onRefresh()方法</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line">  <span class="comment">// 发布ContextRefreshedEvent事件</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 如果处于活动状态,参与LiveBeansView MBean(用于监控,SpringBoot的actuator模块用到)</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE) &#123;</span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring提供了Lifecycle接口，其中包含<code>start()</code>和<code>stop()</code>方法，实现此接口保证在Spring生命周期开始和结束时分别调用这两个方法，通常用于配置后台程序(如对MQ进行轮训)</p>
</blockquote>
</li>
<li><p>ApplicationContext介绍：<br><img src="ApplicationContext%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ApplicationContext继承情况"></p>
<blockquote>
<p><strong><em>BeanFactory</em></strong>：Spring管理Bean的顶层接口，ApplicationContext的IOC容器功能通过复用BeanFactory<br><strong><em>ResourceLoader</em></strong>：Spring加载资源的顶层接口，同样通过复用<br>ApplicationEventPublisher：封装事件发布功能<br>MessageSource：解析Message的策略接口，用于国际化<br>EnvironmentCapable：用于获取Environment</p>
</blockquote>
<p>常用的ClassPathXmlApplicationContext：<br><img src="ClassPathXmlApplicationContext%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ClassPathXmlApplicationContext继承情况"></p>
</li>
</ul>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><ul>
<li><p>背景：JavaSE中有一个标准类<code>java.net.URL</code>，表示统一资源定位器(Uniform Resource Locator)，但其实现存在局限性，没有定义相对于Classpath或ServletContext等资源的解析方式。因此Spring抽象了Resource用于统一资源，抽象了ResourceLoader用于统一资源加载</p>
</li>
<li><p>Resource接口(统一资源抽象)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resource.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exists();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStreamSource.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line">  <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>InputStreamSource接口封装任何能返回InputStream的类(如File、Classpath下的资源和Byte Array等)，它只定义了一个方法————<code>getInputStream()</code><br>Resource接口抽象了所有Spring内部使用到的底层资源：File、URL、Classpath等，针对不同来源的资源文件，存在多种Resource实现：</p>
<ol>
<li>FileSystemResource：对java.io.File类型资源的封装，支持文件和URL的形式，实现WritableResource接口；从Spring5开始，FileSystemResource使用NIO2的API进行读/写交互</li>
<li>ByteArrayResource：对字节数组类型资源的封装。如果通过InputStream形式访问该类型的资源，该实现会根据字节数组的数据构造一个对应的ByteArrayInputStream</li>
<li>UrlResource：对java.net.URL类型资源的封装。内部委派URL进行具体操作</li>
<li>ClassPathResource：获取Classpath类型资源的实现。使用给定的ClassLoader或者给定的Class来加载资源</li>
<li>InputStreamResource：获取InputStream类型资源的实现</li>
</ol>
<p><img src="Resource%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="Resource继承情况"></p>
</blockquote>
</li>
<li><p>ResourceLoader接口(统一资源加载器抽象)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceLoader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">  <span class="comment">// "classpath:"</span></span><br><span class="line">  String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line">  <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring将资源的定义和加载区分开，ResourceLoader资源加载器用于根据给定的资源文件地址返回对应的Resource<br><img src="ResourceLoader%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ResourceLoader继承图"></p>
</blockquote>
</li>
<li><p>loadBeanDefinitions()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的XmlBeanDefinitionReader加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * BeanFactory的生命周期是由refreshBeanFactory()方法处理的；因此该方法只应该是加载和/或注册BeanDefinition</span></span><br><span class="line"><span class="comment"> * 在Bean注册错误的情况下抛出BeansException</span></span><br><span class="line"><span class="comment"> * 在找不到所需的XML文档的情况下抛出IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  Resource[] configResources = getConfigResources();</span><br><span class="line">  <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过资源加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configResources);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] configLocations = getConfigLocations();</span><br><span class="line">  <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过配置文件路径加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configLocations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">    count += loadBeanDefinitions(location);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的资源位置加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 如果该BeanDefinitionReader的ResourceLoader是ResourcePatternResolver,那么路径可以是一个路径模式</span></span><br><span class="line"><span class="comment"> * actualResources是一个集合,用于填充加载过程中解析的实际资源对象;可以为null,表示调用者对这些资源对象不感兴趣</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">  <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot load bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">    <span class="comment">// 资源模式匹配可用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">      <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Collections.addAll(actualResources, resources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只能按绝对URL加载单个资源</span></span><br><span class="line">    Resource resource = resourceLoader.getResource(location);</span><br><span class="line">    <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">    <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      actualResources.add(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    count += loadBeanDefinitions(resource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =</span><br><span class="line">  <span class="keyword">new</span> NamedThreadLocal&lt;Set&lt;EncodedResource&gt;&gt;(<span class="string">"XML bean definition resources currently being loaded"</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;EncodedResource&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的XML文件加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 参数encodedResource是XML文件的资源描述符,允许指定用于解析文件的编码</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取当前线程保存的正在加载的资源</span></span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="comment">// 如果有重复,就说明存在循环加载问题,抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取输入流</span></span><br><span class="line">  <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">    <span class="comment">// 封装成SAX的标准输入流</span></span><br><span class="line">    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">    <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正执行加载BeanDefinition</span></span><br><span class="line">    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清理当前线程保存的正在加载的资源</span></span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在总体流程中分析到<code>loadBeanDefinitions()</code>方法，顺着该方法，方法内部调用了一系列的重载方法<br>比较重要的有两个地方：<br>一个是类AbstractBeanDefinitionReader内<code>loadBeanDefinitions(String, Set&lt;Resource&gt;)</code>方法，该方法首先获取了ResourceLoader，接着用该对象的<code>getResource()</code>方法加载资源，最后通过调用重载的<code>loadBeanDefinitions(Resource[])</code>方法；首先来看看获取的ResourceLoader对象以及<code>getResource()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于将路径模式解析为资源实例的ResourcePatternResolver</span></span><br><span class="line"><span class="comment"> * 默认是支持Ant风格路径模式的PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"><span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定的路径默认解析为资源对象</span></span><br><span class="line"><span class="comment"> * 应尽可能避免重叠资源条目指向统一物理资源。结果应该具有set语义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">  <span class="comment">// String CLASSPATH_ALL_URL_PREFIX = "classpath*:";</span></span><br><span class="line">  <span class="comment">// 如果以"classpath*:"开头</span></span><br><span class="line">  <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// 类路径资源(可能有同名的多个资源)</span></span><br><span class="line">    <span class="comment">// 如果路径是表示一种模式(含有'*'、'?'、"&#123;&#125;"等通配符)</span></span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">      <span class="comment">// 单个类路径资源路径模式</span></span><br><span class="line">      <span class="comment">// 解析通配符的路径获取资源</span></span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 具有给定名称的所有类路径资源</span></span><br><span class="line">      <span class="comment">// 返回classpath路径下和所有jar包中的所有相匹配资源</span></span><br><span class="line">      <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不以"classpath*:"开头</span></span><br><span class="line">    <span class="comment">// 通常在这里只查找前缀后面的模式</span></span><br><span class="line">    <span class="keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="string">"war:"</span>) ? locationPattern.indexOf(<span class="string">"*/"</span>) + <span class="number">1</span> : locationPattern.indexOf(<span class="string">':'</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">      <span class="comment">// 单个文件模式</span></span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 具有给定名称的单个资源</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用的ResourceLoader资源加载器其实是传入的applicationContext，它在<code>loadBeanDefinitions()</code>方法中被设置<br>其次ApplicationContext接口继承了ResourceLoader，因此可以被当成是ResourceLoader。而且AbstractApplicationContext继承自DefaultResourceLoader。在AbstractApplicationContext类构造器中，显式地初始化了PathMatchingResourcePatternResolver类的对象作为其委托的ResourceLoader实例并传入了自身。PathMatchingResourcePatternResolver相当于持有了DefaultResourceLoader(ApplicationContext)以及AntPatchMatcher，并将加载资源和路径模式匹配的工作委托给这两个属性<br>接着看获取资源<code>getResources()</code>方法，根据是否以”classpath*:”和是否是路径模式共给出三种获取资源的方式，具体不再展开</p>
<p>另一处<code>doLoadBeanDefinitions()</code>方法是最重要的，这是核心逻辑部分，用于执行加载BeanDefinition的操作，在后面的XML解析部分说明</p>
</blockquote>
</li>
<li><p>ResourceLoader解析Resource过程简单介绍：</p>
<ol>
<li><p>findAllClassPathResources()方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// location：类路径中的绝对路径</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  String path = location;</span><br><span class="line">  <span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    path = path.substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 委托给doFindAllClassPathResources()方法执行</span></span><br><span class="line">  Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Resolved classpath location ["</span> + location + <span class="string">"] to resources "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过类加载器找到具有给定路径的所有类路径资源</span></span><br><span class="line"><span class="comment"> * path：不带前导'/'的类路径中的绝对路径</span></span><br><span class="line"><span class="comment"> * 返回一组匹配的资源实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  ClassLoader cl = getClassLoader();</span><br><span class="line">  <span class="comment">// 根据ClassLoader加载路径下的所有资源</span></span><br><span class="line">  Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));</span><br><span class="line">  <span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = resourceUrls.nextElement();</span><br><span class="line">    <span class="comment">// 将URL转为URLResource</span></span><br><span class="line">    result.add(convertClassLoaderURL(url));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是""(空路径)</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasLength(path)) &#123;</span><br><span class="line">    <span class="comment">// 上述结果可能不完整,即仅包含文件系统引用</span></span><br><span class="line">    <span class="comment">// 同时需要加载类路径下的每个jar文件</span></span><br><span class="line">    addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>findPathMatchingResources()方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过Ant风格的PathMatcher查找与给定路径模式匹配的所有资源</span></span><br><span class="line"><span class="comment"> * 支持jar、zip和文件系统中的资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 确定根路径</span></span><br><span class="line">  String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">  <span class="comment">// 确定子路径</span></span><br><span class="line">  String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">  <span class="comment">// 获取根路径下的资源</span></span><br><span class="line">  Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  <span class="comment">// 遍历根路径下的资源</span></span><br><span class="line">  <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">    URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">    <span class="comment">// bundle资源类型</span></span><br><span class="line">    <span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="string">"bundle"</span>)) &#123;</span><br><span class="line">      URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirUrl);</span><br><span class="line">      <span class="keyword">if</span> (resolvedUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rootDirUrl = resolvedUrl;</span><br><span class="line">      &#125;</span><br><span class="line">      rootDirResource = <span class="keyword">new</span> UrlResource(rootDirUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vfs资源类型</span></span><br><span class="line">    <span class="keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">      result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">      <span class="comment">// jar资源类型</span></span><br><span class="line">      result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他资源类型</span></span><br><span class="line">      result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getResource()方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultResourceLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">  <span class="comment">// 通过ProtocolResolver加载资源</span></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * ProtocolResolver是用户自定义协议资源解决策略,作为DefaultResourceLoader的SPI(Service Provider Interface)</span></span><br><span class="line"><span class="comment">   * 它允许用户自定义资源加载协议,而不需要继承ResourceLoader的子类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">    Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果以'/'开头,返回ClassPathContextResource类型的资源</span></span><br><span class="line">  <span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// 再者,如果以"classpath:"开头,返回ClassPathResource类型的资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试将路径解析为URL</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">      <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">      <span class="comment">// 不是URL,当作资源路径解析</span></span><br><span class="line">      <span class="comment">// 返回ClassPathContextResource类型的资源</span></span><br><span class="line">      <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2><ul>
<li><p>背景：传统Spring程序均通过XML定义bean实例；因此Spring使用SAX(Simple API for XML)方式解析XML。该方式是sun公司内置于Java的，比传统的DOM解析方式快</p>
</li>
<li><p>doLoadBeanDefinitions()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的XML文件实际加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析XML文档获取XML Document实例</span></span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="comment">// 根据Document实例注册BeanDefinition</span></span><br><span class="line">    <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</span><br><span class="line"><span class="keyword">private</span> ErrorHandler errorHandler = <span class="keyword">new</span> SimpleSaxErrorHandler(logger);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> namespaceAware = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>doLoadBeanDefinitions()</code>方法中主要做了两件事<br>其一是解析XML获取Document实例，另一是注册BeanDefinition<br>在这部分中先说明解析步骤：<br>获取Document实例过程又将解析任务委托给DocumentLoader对象处理，在解析XML中传入了许多参数：</p>
<ol>
<li><p>inputSource：加载XML的Document的资源，封装InputStream而来</p>
</li>
<li><p>entityResolver：用于解析任何实体的解析器，默认是ResourceEntityResolver，在初始化XmlBeanDefinitionReader时设置</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>errorHandler：用于报告Document加载期间错误的错误处理器</p>
</li>
<li><p>validationMode：XML的验证模式</p>
</li>
<li><p>namespaceAware：是否要提供对XML名称空间的支持</p>
</li>
</ol>
<p>接着顺序分析<code>getValidationModeForResource()</code>方法以及<code>loadDocument()</code>方法，其中前者用于获取XML的验证模式，后者用于加载Document</p>
</blockquote>
</li>
<li><p>getValidationModeForResource()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确定指定资源的验证模式</span></span><br><span class="line"><span class="comment"> * 如果未显式设置验证模式,则验证模式将通过detectValidationMode()方法检测</span></span><br><span class="line"><span class="comment"> * 如果想完全控制验证模式,则重写此方法(即使设置了VALIDATION_AUTO)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// 禁用验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line"><span class="comment">// 自动获取验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line"><span class="comment">// DTD验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line"><span class="comment">// XSD验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line"><span class="comment">// 默认为自动模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> validationMode = VALIDATION_AUTO;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取指定的验证模式</span></span><br><span class="line">  <span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line">  <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测XML的验证模式</span></span><br><span class="line">  <span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line">  <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> detectedMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以XSD验证模式兜底</span></span><br><span class="line">  <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测所提供资源标识的XML的验证模式</span></span><br><span class="line"><span class="comment"> * 如果文件具有DOCTYPE定义则使用DTD验证,否则假定使用XSD验证</span></span><br><span class="line"><span class="comment"> * 如果要自定义自动验证模式的处理策略,重写此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// XML验证检测器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlValidationModeDetector validationModeDetector = <span class="keyword">new</span> XmlValidationModeDetector();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果资源不可读</span></span><br><span class="line">  <span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Passed-in Resource ["</span> + resource + <span class="string">"] contains an open stream: "</span> + <span class="string">"cannot determine validation mode automatically. Either pass in a Resource "</span> + <span class="string">"that is able to create fresh streams, or explicitly specify the validationMode "</span> + <span class="string">"on your XmlBeanDefinitionReader instance."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  InputStream inputStream;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = resource.getInputStream();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: cannot open InputStream. "</span> + <span class="string">"Did you attempt to load directly from a SAX InputSource without specifying the "</span> + <span class="string">"validationMode on your XmlBeanDefinitionReader instance?"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取相应验证模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: an error occurred whilst reading from the InputStream."</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlValidationModeDetector.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DOCTYPE = <span class="string">"DOCTYPE"</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasDoctype</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> content.contains(DOCTYPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为了寻找DOCTYPE而快速查看文件</span></span><br><span class="line">  <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream))) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</span><br><span class="line">    String content;</span><br><span class="line">    <span class="comment">// 逐行读取XML文件内容</span></span><br><span class="line">    <span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      content = consumeCommentTokens(content);</span><br><span class="line">      <span class="comment">// 跳过注释和空行</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否包含"DOCTYPE",如包含则是DTD模式</span></span><br><span class="line">      <span class="keyword">if</span> (hasDoctype(content)) &#123;</span><br><span class="line">        isDtdValidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 走到正文,跳出</span></span><br><span class="line">      <span class="keyword">if</span> (hasOpeningTag(content)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (CharConversionException ex) &#123;</span><br><span class="line">    <span class="comment">// 被一些字符编码阻塞</span></span><br><span class="line">    <span class="comment">// 把决定权交给调用者</span></span><br><span class="line">    <span class="keyword">return</span> VALIDATION_AUTO;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加载Document首先要获取XML文件的验证模式(验证模式保证了XML文件的正确性)，DTD(Document Type Definition————文档类型定义)和XSD(XML Schemas Definition)是两个用于XML文件的验证机制<br>XSD是为了替代DTD而出现的，基于XML，没有专门的语法(DTD不基于XML)，比DTD更优秀<br><code>getValidationModeForResource()</code>函数首先获取指定的验证模式，默认为自动模式。然后将检测验证模式的职责交由XmlValidationModeDetector类处理————逐行读取XML中的文本，根据是包含”DOCTYPE”判断是否为DTD模式</p>
</blockquote>
</li>
<li><p>loadDocument()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准的JAXP(Java API for XML Processing)配置的XML解析器根据提供的InputStream加载Document</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">  <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DocumentBuilderFactory实例</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">  factory.setNamespaceAware(namespaceAware);</span><br><span class="line">  <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">    factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">      <span class="comment">// 如果为XSD验证模式,强制使用命名空间支持</span></span><br><span class="line">      factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(<span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory + <span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> + <span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);</span><br><span class="line">        pcex.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> pcex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成DocumentBuilder用于解析XML文档</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilder <span class="title">createDocumentBuilder</span><span class="params">(DocumentBuilderFactory factory, @Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span> <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">  DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">  <span class="keyword">if</span> (entityResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">    docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DocumentLoader是Spring用于包装SAX解析XML的类<br><code>loadDocument()</code>方法内部主要通过填充参数的方式创建了DocumentBuilderFactory和DocumentBuilder对象，而后者真正用于解析XML文档。这两个类都是JDK底层SAX部分代码，与Spring无关，Spring委托SAX处理XML解析工作，具体不再展开<br>最后介绍一下EntityResolver，该类也是SAX规定的类，定义寻找解析文件的逻辑</p>
</blockquote>
</li>
<li><p>ResourceEntityResolver介绍(EntityResolver实现)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EntityResolver.java</span></span><br><span class="line"><span class="comment">// 用于定义寻找解析文件的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityResolver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputSource <span class="title">resolveEntity</span> <span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException, IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceEntityResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResourceEntityResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(resourceLoader.getClassLoader());</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(@Nullable String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类DelegatingEntityResolver进行解析</span></span><br><span class="line">  InputSource source = <span class="keyword">super</span>.resolveEntity(publicId, systemId);</span><br><span class="line">  <span class="comment">// 解析失败,使用ResourceLoader解析</span></span><br><span class="line">  <span class="keyword">if</span> (source == <span class="keyword">null</span> &amp;&amp; systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取Resource资源地址</span></span><br><span class="line">    String resourcePath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String decodedSystemId = URLDecoder.decode(systemId, <span class="string">"UTF-8"</span>);</span><br><span class="line">      String givenUrl = <span class="keyword">new</span> URL(decodedSystemId).toString();</span><br><span class="line">      <span class="comment">// 获取解析文件资源的相对路径(相对于系统根路径)</span></span><br><span class="line">      String systemRootUrl = <span class="keyword">new</span> File(<span class="string">""</span>).toURI().toURL().toString();</span><br><span class="line">      <span class="comment">// 如果在系统根目录,尝试相对于资源库</span></span><br><span class="line">      <span class="keyword">if</span> (givenUrl.startsWith(systemRootUrl)) &#123;</span><br><span class="line">        resourcePath = givenUrl.substring(systemRootUrl.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Could not resolve XML entity ["</span> + systemId + <span class="string">"] against system root URL"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是URL(或不是可处理的URL),尝试相对于资源库</span></span><br><span class="line">      resourcePath = systemId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resourcePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Trying to locate XML entity ["</span> + systemId + <span class="string">"] as resource ["</span> + resourcePath + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取Resource资源</span></span><br><span class="line">      Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resourcePath);</span><br><span class="line">      source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">      <span class="comment">// 设置publicId和systemId</span></span><br><span class="line">      source.setPublicId(publicId);</span><br><span class="line">      source.setSystemId(systemId);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found XML entity ["</span> + systemId + <span class="string">"]: "</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 网络请求验证文件</span></span><br><span class="line">      String url = systemId;</span><br><span class="line">      <span class="keyword">if</span> (url.startsWith(<span class="string">"http:"</span>)) &#123;</span><br><span class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        source = <span class="keyword">new</span> InputSource(<span class="keyword">new</span> URL(url).openStream());</span><br><span class="line">        source.setPublicId(publicId);</span><br><span class="line">        source.setSystemId(systemId);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Could not resolve XML entity ["</span> + systemId + <span class="string">"] through URL ["</span> + url + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回到解析器的默认行为</span></span><br><span class="line">        source = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DelegatingEntityResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelegatingEntityResolver</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dtdResolver = <span class="keyword">new</span> BeansDtdResolver();</span><br><span class="line">  <span class="keyword">this</span>.schemaResolver = <span class="keyword">new</span> PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(@Nullable String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 调用BeansDtdResolver解析</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.dtdResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 调用PluggableSchemaResolver解析</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.schemaResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回到解析器的默认行为</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EntityResolver主要用于获取解析文件，有了解析文件就可以验证XML编写是否符合规则<br>当前默认采用ResourceEntityResolver获取解析文件(由于构造时传入context————ResourceLoader的子接口)，首先调用父类的<code>resolveEntity()</code>方法进行解析<br>父类DelegatingEntityResolver则分别根据验证文件类型分别交由BeansDtdResolver(DTD)和PluggableSchemaResolver(XSD)类来获取解析文件<br>如果是XSD类型，PluggableSchemaResolver会先获取一个映射表，映射表是通过META-INF/spring.schemas从Spring依赖包(spring-beans)获取的，该配置文件中写明了映射表内容；BeansDtdResolver也先通过文件查找<br>如果以上都解析不出，则通过网络访问</p>
</blockquote>
</li>
</ul>
<h2 id="解析Bean"><a href="#解析Bean" class="headerlink" title="解析Bean"></a>解析Bean</h2><ul>
<li><p>背景：目前为止，XML已经被SAX解析为Document文档了，接下来可以进行真正的Bean解析注册过程了</p>
</li>
<li><p>registerBeanDefinitions()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册给定DOM文档中包含的BeanDefinition</span></span><br><span class="line"><span class="comment"> * 创建parser的新实例并调用它的registerBeanDefinitions()方法</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在解析错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建BeanDefinitionDocumentReader对象</span></span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="comment">// 获取已注册的BeanDefinition数量</span></span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  <span class="comment">// 创建XmlReaderContext对象以及注册BeanDefinition</span></span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="comment">// 计算新注册的BeanDefinition数目</span></span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建BeanDefinitionDocumentReader用于实例从XML文档中读取BeanDefinition</span></span><br><span class="line"><span class="comment"> * 默认实现采用指定的documentReaderClass进行实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"><span class="comment">// 创建XmlReaderContext引用传递给DocumentReader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果之前未设置则延迟创建默认的NamespaceHandlerResolver</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandlerResolver <span class="title">getNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.namespaceHandlerResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.namespaceHandlerResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建NamespaceHandlerResolver的默认实现,如果没指定的话</span></span><br><span class="line"><span class="comment"> * 默认实现返回DefaultNamespaceHandlerResolver实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> NamespaceHandlerResolver <span class="title">createDefaultNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = (getResourceLoader() != <span class="keyword">null</span> ? getResourceLoader().getClassLoader() : getBeanClassLoader());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultNamespaceHandlerResolver(cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>registerBeanDefinitions()</code>方法首先创建了BeanDefinitionDocumentReader对象，实例是DefaultBeanDefinitionDocumentReader类型；该对象用于将Document解析为BeanDefinition<br>接着将注册BeanDefinition的任务委托给了BeanDefinitionDocumentReader，在当中创建了XmlReaderContext对象，该对象是在BeanDefinition读取过程中传递的上下文，封装了所有相关的配置和状态，它包括几个重要的属性：</p>
<ol>
<li>source：原始资源描述符</li>
<li>problemReporter：问题报告器————允许工具和其他外部进程处理BeanDefinition解析期间报告的错误和警告</li>
<li>eventListener：事件回调接口————用于接收在BeanDefinition读取过程中component(组件)、alias(别名)和import(倒入)注册的回调</li>
<li>sourceExtractor：源数据抽取器————允许工具控制源数据的metadata(元数据)如何附加到BeanDefinition metadata(元数据)的简单策略</li>
<li>namespaceHandlerResolver：命名空间处理器解析器————由DefaultBeanDefinitionDocumentReader设置，用于定位处理特定命名空间URI的namespaceHandler实现(命名空间处理器实现)</li>
</ol>
</blockquote>
</li>
<li><p>委托的registerBeanDefinitions()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该实现根据spring-beans的XSD(或者历史上的DTD)解析BeanDefinition</span></span><br><span class="line"><span class="comment"> * 打开一个DOM文档；接着初始化&lt;beans/&gt;标签级别指定的默认设置；然后解析包含的BeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">  <span class="comment">// 获取XML的Document的Root元素,执行注册BeanDefinition</span></span><br><span class="line">  doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROFILE_ATTRIBUTE = <span class="string">"profile"</span>;</span><br><span class="line"><span class="comment">// 在给定的根&lt;beans/&gt;标签中注册每个BeanDefinition</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 任何嵌套的&lt;beans&gt;标签都会导致此方法的递归调用</span></span><br><span class="line"><span class="comment">   * 为了正确地传播和保留&lt;beans&gt;标签的"default-*"属性,请跟踪当前(parent,父)delegate(委托),该委托可能为null</span></span><br><span class="line"><span class="comment">   * 创建新的(子)委托,并引用父代理以进行回退(fallback),然后最终重置此委托为其原始(父)引用</span></span><br><span class="line"><span class="comment">   * 此行为模拟一个委托栈而不用实现一个委托栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 记录老的BeanDefinitionParserDelegate对象</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="comment">// 创建新的BeanDefinitionParserDelegate对象,并设置给delegate属性</span></span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="comment">// 检查是否是默认命名空间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 获取profile属性并处理</span></span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      <span class="comment">// 使用分隔符切分得到可能的多个profile</span></span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// 不能使用Profiles.of(...)方法,因为XML配置中不支持配置表达式。详见SPR-12458</span></span><br><span class="line">      <span class="comment">// 如果profile都无效,则不进行注册</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec + <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析前处理,模板设计模式,当前空实现</span></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  <span class="comment">// 解析XML成BeanDefinition</span></span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  <span class="comment">// 解析后处理,模板设计模式,当前空实现</span></span><br><span class="line">  postProcessXml(root);</span><br><span class="line">  <span class="comment">// 设置回老的BeanDefinitionParserDelegate对象</span></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>registerBeanDefinitions()</code>方法将具体执行注册BeanDefinition的逻辑委托给<code>doRegisterBeanDefinitions()</code>方法<br>该方法进行进行了许多操作：</p>
<ol>
<li><p>记录老(父)BeanDefinitionParserDelegate引用</p>
</li>
<li><p>创建新(子)BeanDefinitionParserDelegate引用并赋值给当前delegate属性；在创建新BeanDefinitionParserDelegate时设置了许多default-*属性，其中一些可以从父&lt;bean/&gt;标签(父BeanDefinitionParserDelegate)中部分继承，或为默认值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 用于解析XML的BeanDefinition的有状态的委托类,供主解析器和任何扩展使用</span></span><br><span class="line">  BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">  delegate.initDefaults(root, parentDelegate);</span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDefaults</span><span class="params">(Element root, @Nullable BeanDefinitionParserDelegate parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 填充默认值</span></span><br><span class="line">  populateDefaults(<span class="keyword">this</span>.defaults, (parent != <span class="keyword">null</span> ? parent.defaults : <span class="keyword">null</span>), root);</span><br><span class="line">  <span class="comment">// 触发默认注册事件</span></span><br><span class="line">  <span class="keyword">this</span>.readerContext.fireDefaultsRegistered(<span class="keyword">this</span>.defaults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALSE_VALUE = <span class="string">"false"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LAZY_INIT_ATTRIBUTE = <span class="string">"default-lazy-init"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_MERGE_ATTRIBUTE = <span class="string">"default-merge"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTOWIRE_ATTRIBUTE = <span class="string">"default-autowire"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_NO_VALUE = <span class="string">"no"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = <span class="string">"default-autowire-candidates"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_INIT_METHOD_ATTRIBUTE = <span class="string">"default-init-method"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DESTROY_METHOD_ATTRIBUTE = <span class="string">"default-destroy-method"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用默认的lazy-init、autowire、依赖项检查设置、init-method、destro-method和合并设置填充给定的DocumentDefaultsDefinition实例</span></span><br><span class="line"><span class="comment"> * 如果没有在本地显式地设置默认值,则通过返回parentDefaults来支持嵌套的&lt;beans&gt;标签实例</span></span><br><span class="line"><span class="comment"> * DocumentDefaultsDefinition：是保存默认值的简单JavaBean，这些默认值指定在标准Spring XML BeanDefinition文档中&lt;beans&gt;标签级别————default-lazy-init、default-autowire等</span></span><br><span class="line"><span class="comment"> * defaults：要填充的默认值</span></span><br><span class="line"><span class="comment"> * parentDefaults：父BeanDefinitionParserDelegate(如果有)的默认值</span></span><br><span class="line"><span class="comment"> * root：当前BeanDefinition文档的根标签(或嵌套的&lt;beans&gt;标签)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateDefaults</span><span class="params">(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root)</span> </span>&#123;</span><br><span class="line">  String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    lazyInit = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getLazyInit() : FALSE_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setLazyInit(lazyInit);</span><br><span class="line">  String merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(merge)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    merge = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getMerge() : FALSE_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setMerge(merge);</span><br><span class="line">  String autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(autowire)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    autowire = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setAutowire(autowire);</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setInitMethod(parentDefaults.getInitMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setSource(<span class="keyword">this</span>.readerContext.extractSource(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查是否是默认空间；如果是则获取并分割profile属性，并校验当前profile是否有效(无效退出)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">"http://www.springframework.org/schema/beans"</span>;</span><br><span class="line"><span class="comment">// 确定给定的URI是否指示默认命名空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isDefaultNamespace(getNamespaceURI(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(@Nullable String namespaceUri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;beans/&gt;根标签的命名空间为空</span></span><br><span class="line">  <span class="comment">// 或namespaceUri为http://www.springframework.org/schema/beans</span></span><br><span class="line">  <span class="keyword">return</span> !StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最重要的就是执行真正的解析BeanDefinition的<code>parseBeanDefinitions()</code>方法，在该方法前后提供了两个空实现的模板方法<code>preProcessXml()</code>和<code>postProcessXml()</code>用于扩展(子类继承覆写)</p>
</li>
<li><p>设置当前delegate属性为老的BeanDefinitionParserDelegate引用</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong><em>parseBeanDefinitions()方法</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析文档中根级别的标签：&lt;import&gt;、&lt;alias&gt;、&lt;bean&gt;</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点使用默认命名空间</span></span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 遍历子节点</span></span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="comment">// 如果该节点使用默认命名空间,执行默认解析</span></span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果该节点不使用默认命名空间,执行自定义解析</span></span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果根节点不使用默认命名空间,执行自定义解析</span></span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT; <span class="comment">// "bean"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NESTED_BEANS_ELEMENT = <span class="string">"beans"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALIAS_ELEMENT = <span class="string">"alias"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALIAS_ATTRIBUTE = <span class="string">"alias"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMPORT_ELEMENT = <span class="string">"import"</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">    processBeanDefinition(ele, delegate);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line">    <span class="comment">// 递归解析</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>parseBeanDefinitions()</code>方法一目了然，首先判断是否标签是否使用默认命名空间，如果否则是自定义标签————调用<code>parseCustomElement()</code>解析；否则是默认标签————根据标签的不同分别进行处理<br>接着依次分析不同标签的解析流程</p>
</blockquote>
</li>
<li><p><strong><em>importBeanDefinitionResource()方法(解析import标签)</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析&lt;import&gt;标签,并将BeanDefinition从给定的资源加载到BeanFactory</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取resource的属性值</span></span><br><span class="line">  String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 为空值,直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析系统配置(占位符)</span></span><br><span class="line">  location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line">  <span class="comment">// 实际Resource集合————从import的地址解析而来</span></span><br><span class="line">  Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 判断location是相对路径还是绝对路径</span></span><br><span class="line">  <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">    <span class="comment">// 无法转换为URI,考虑位置是相对的,除非是Spring前缀"classpath*:"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是绝对路径</span></span><br><span class="line">  <span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将添加的配置文件的Resource通过location解析,并把结果放入actualResources集合中</span></span><br><span class="line">      <span class="comment">// 并递归加载其中的BeanDefinitions</span></span><br><span class="line">      <span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不是URL -&gt; 考虑相对于当前文件的资源位置</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> importCount;</span><br><span class="line">      <span class="comment">// 创建相对路径的Resource</span></span><br><span class="line">      Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">      <span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">        <span class="comment">// 加载relativeResource中的BeanDefinition</span></span><br><span class="line">        importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">        <span class="comment">// 将relativeResource加入actualResources集合</span></span><br><span class="line">        actualResources.add(relativeResource);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取根路径</span></span><br><span class="line">        String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">        <span class="comment">// 根据根路径和location构造相对路径并加载BeanDefinition</span></span><br><span class="line">        importCount = getReaderContext().getReader().loadBeanDefinitions(StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 触发当前&lt;import&gt;标签处理完的事件回调</span></span><br><span class="line">  getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>importBeanDefinitionResource()</code>方法一目了然，可为以下几个步骤：</p>
<ol>
<li><p>获取source属性的值————表示资源的路径</p>
</li>
<li><p>解析资源路径的系统属性(占位符)</p>
</li>
<li><p>判断资源路径是绝对路径还是相对路径</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定的资源位置是否为URL：</span></span><br><span class="line"><span class="comment"> * 特殊的以"classpath:"或"classpath*:"开头的伪URL或标准URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// ResourcePatternUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUrl</span><span class="params">(@Nullable String resourceLocation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (resourceLocation != <span class="keyword">null</span> &amp;&amp; (resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) || ResourceUtils.isUrl(resourceLocation)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 1.以”classpath*:”或者”classpath:”开头为绝对路径<br> 2.能够通过location构建出URL类对象为绝对路径<br> 3.根据location构造URI类对象并调用<code>isAbsolute()</code>函数返回true为绝对路径</p>
</li>
<li><p>创建相对/绝对路径对应的Resource资源，递归调用Bean解析过程进行另一次解析</p>
</li>
<li><p>通知监听器完成&lt;import&gt;标签解析</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong><em>processAliasRegistration()方法(解析alias标签)</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的&lt;alias&gt;标签,在注册表中注册别名。</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取name和alias属性</span></span><br><span class="line">  String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">  String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 真正注册别名</span></span><br><span class="line">      getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias + <span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发当前&lt;alias&gt;标签注册完的事件回调</span></span><br><span class="line">    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从别名到规范名的映射</span></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">  Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">  <span class="comment">// #TODO</span></span><br><span class="line">  <span class="comment">// 锁对象,用于控制并发(既然用了ConcurrentHashMap,为什么还要锁?)</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="comment">// 如果alias与name相同,那么不归alias管,相当于没有alias</span></span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' ignored since it points to same name"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取alias已注册的beanName</span></span><br><span class="line">      String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">      <span class="comment">// 已存在</span></span><br><span class="line">      <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 相同,无需重复注册</span></span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否允许覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot define alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Overriding alias '"</span> + alias + <span class="string">"' definition for registered name '"</span> + registeredName + <span class="string">"' with new target name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检验是否存在循环指向</span></span><br><span class="line">      checkForAliasCircle(name, alias);</span><br><span class="line">      <span class="comment">// 注册alias,实际就是放入hash表</span></span><br><span class="line">      <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' registered for name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否出现alias循环：A -&gt; B , B -&gt; A</span></span><br><span class="line"><span class="comment"> * 捕获一个循环引用并抛出IllegalStateExceptio异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkForAliasCircle</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasAlias(alias, name)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': Circular reference - '"</span> + name + <span class="string">"' is a direct or indirect alias for '"</span> + alias + <span class="string">"' already"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定给定name是否已注册给定alias</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">  <span class="keyword">return</span> ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != <span class="keyword">null</span> &amp;&amp; hasAlias(name, registeredName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>processAliasRegistration()</code>方法一目了然，可为以下几个步骤：</p>
<ol>
<li><p>获取name和alias属性并校验非空</p>
</li>
<li><p>委托给SimpleAliasRegistry类真正执行注册别名逻辑，构造ReaderContext时传入了XmlBeanDefinitionReader的引用，而构造XmlBeanDefinitionReader时传入了DefaultListableBeanFactory的引用；DefaultListableBeanFactory隔代继承了SimpleAliasRegistry，因此最终交由SimpleAliasRegistry真正注册别名</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// 创建XmlReaderContext引用传递给DocumentReader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为给定的BeanFactory创建XmlBeanDefinitionReader</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册别名主要执行逻辑参见注释</p>
</li>
<li><p>通知监听器完成当前&lt;alias&gt;标签解析</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong><em>processBeanDefinition()方法(解析bean标签)</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的Bean标签,解析成BeanDefinition并将其注册到注册表</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析bean元素,如果成功返回BeanDefinitionHolder;否则返回null</span></span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 进行自定义标签解析</span></span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册最终的包装实例</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> + bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发当前&lt;bean&gt;标签处理完(注册完当前BeanDefinition)的事件回调</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>processBeanDefinition()</code>方法一目了然，可为以下几个步骤：</p>
<ol>
<li><p>将解析&lt;bean/&gt;标签成BeanDefinitionHolder的任务委托给BeanDefinitionParserDelegate(该类囊括了许多解析功能)；BeanDefinitionHolder类是封装了name和alias的BeanDefinition</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有name和alias的BeanDefinition的持有者。可注册为内部Bean的占位符</span></span><br><span class="line"><span class="comment">// BeanDefinitionHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析提供的&lt;bean&gt;标签。如果解析过程出现错误则可能返回null,并向ProblemReporter报告错误</span></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析id和name属性</span></span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 别名集合</span></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">// 切分name属性</span></span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// beanName优先使用id</span></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="comment">// 其次使用alias别名的第一个</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No XML 'id' specified - using '"</span> + beanName + <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查beanName的唯一性</span></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析其他属性,封装成AbstractBeanDefinition对象</span></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有beanName,使用beanName生成规则生成唯一的beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// 如果生成器返回加上后缀的类名,则为Plain Bean类名注册一个别名(如果仍然可能)</span></span><br><span class="line">          <span class="comment">// 这是Spring 1.2/2.0向后兼容的预期结果</span></span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> + <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="comment">// 创建BeanDefinitionHolder对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储所有使用过的beanName,以便可以在每个&lt;beans&gt;标签基础上强制唯一性</span></span><br><span class="line"><span class="comment"> * 重复的bean id/name可能不存在于同一级别的&lt;beans&gt;嵌套标签中,但可以跨级别存在同名bean id/name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; usedNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 验证指定的beanName和alias是否尚未在当前级别的&lt;beans&gt;嵌套标签中使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查看beanName或alias是否已被使用</span></span><br><span class="line">  String foundName = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">    foundName = beanName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    error(<span class="string">"Bean name '"</span> + foundName + <span class="string">"' is already used in this &lt;beans&gt; element"</span>, beanElement);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">  <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>parseBeanDefinitionElement()</code>方法流程也较为清晰，分为以下几个部分：<br>  1.首先解析id和name属性，并设置beanName(首先考虑beanId,其次是首个alias)<br>  2.检查name的唯一性(alias也会参与验证)<br>  3.解析其他属性，封装成AbstractBeanDefinition对象；这部分后续介绍<br>  4.如果没有beanName，使用beanName生成规则生成唯一的beanName<br>  5.返回封装beanName和alias的BeanDefinitionHolder对象</p>
</li>
<li><p>传入将生成的BeanDefinitionHolder对象调用BeanDefinitionParserDelegate类的<code>decorateBeanDefinitionIfRequired()</code>方法进行自定义标签解析</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder originalDef)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> decorateBeanDefinitionIfRequired(ele, originalDef, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果适用,通过命名空间处理器修饰给定的BeanDefinition</span></span><br><span class="line"><span class="comment"> * ele：当前&lt;bean&gt;标签</span></span><br><span class="line"><span class="comment"> * originalDef：当前BeanDefinition</span></span><br><span class="line"><span class="comment"> * containingBd：包含的BeanDefinition(如果有,应该是父&lt;bean&gt;标签,用于继承属性)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder finalDefinition = originalDef;</span><br><span class="line">  <span class="comment">// 首先根据自定义属性进行修饰</span></span><br><span class="line">  NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">    Node node = attributes.item(i);</span><br><span class="line">    finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接着根据自定义嵌套标签进行修饰</span></span><br><span class="line">  NodeList children = ele.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    Node node = children.item(i);</span><br><span class="line">    <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">      finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>decorateBeanDefinitionIfRequired()</code>方法主要用于解析自定义标签，主要调用了<code>decorateIfRequired()</code>方法，此方法介绍自定义标签解析时再介绍</p>
</li>
<li><p>将注册BeanDefinition的任务委托为BeanDefinitionReaderUtils类处理，该方法过于重要，在后面单独介绍</p>
</li>
<li><p>通知监听器完成当前&lt;bean/&gt;标签解析</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong><em>registerBeanDefinition()方法(注册BeanDefinition)</em></strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向给定的BeanFactory注册给定的BeanDefinition</span></span><br><span class="line"><span class="comment">* definitionHolder：包含name和alias的BeanDefinition</span></span><br><span class="line"><span class="comment">* registry：注册的BeanFactory</span></span><br><span class="line"><span class="comment">* 如果注册失败则抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// BeanDefinitionReaderUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 为beanName注册BeanDefinition</span></span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">  <span class="comment">// 为beanName注册alias(如果有的话)</span></span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="comment">// &lt;beanName, BeanDefinition&gt;映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// BeanDefinition名称列表(按注册顺序排列)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 冻结配置时BeanDefinition名称的缓存数组</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String[] frozenBeanDefinitionNames;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此注册表中注册一个新的BeanDefinition</span></span><br><span class="line"><span class="comment"> * 必须支持RootBeanDefinition和ChildBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">  Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是AbstractBeanDefinition类型,进行校验(主要是对属性methodOverrides)</span></span><br><span class="line">      ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存中获取指定beanName的BeanDefinition</span></span><br><span class="line">  BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在同名BeanDefinition但不允许覆盖,抛BeanDefinitionOverrideException异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">      <span class="comment">// 例如是ROLE_APPLICATION,现在覆盖为ROLE_SUPPORT/ROLE_INFRASTRUCTURE</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName + <span class="string">"' with a framework-generated bean definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with a different definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖原有的BeanDefinition,实际注册(就是存入map)</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 检测创建Bean阶段是否已经开启,如果开启了则需要对beanDefinitionMap进行并发控制</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        <span class="comment">// 添加beanName到beanDefinitionNames集合中(CopyOnWrite,可能因为并发)</span></span><br><span class="line">        List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="comment">// 从manualSingletonNames中移除beanName</span></span><br><span class="line">        removeManualSingletonName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 仍处于启动注册阶段</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">      removeManualSingletonName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">    <span class="comment">// 重新设置beanName对应的缓存</span></span><br><span class="line">    resetBeanDefinition(beanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">    clearByTypeCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="comment">// &lt;别名, 规范名&gt;映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">  Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' ignored since it points to same name"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">      <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">          <span class="comment">// 别名已存在,无需二次注册</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot define alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Overriding alias '"</span> + alias + <span class="string">"' definition for registered name '"</span> + registeredName + <span class="string">"' with new target name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      checkForAliasCircle(name, alias);</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' registered for name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>registerBeanDefinition()</code>注册BeanDefinition的过程十分清楚，做了两件事：为beanName注册BeanDefinition以及为beanName注册alias，分别调用了DefaultListableBeanFactory类的<code>registerBeanDefinition()</code>方法以及SimpleAliasRegistry类的<code>registerAlias()</code>方法(DefaultListableBeanFactory继承了SimpleAliasRegistry)<br>在<code>registerBeanDefinition()</code>方法中，做了以下几件事：</p>
</blockquote>
<ol>
<li><p>校验beanName和beanDefinition非空</p>
</li>
<li><p>校验beanDefinition(如果是AbstractBeanDefinition类型)，这里主要是对methodOverrides属性的校验：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证当前BeanDefinition,如果验证失败抛出BeanDefinitionValidationException</span></span><br><span class="line"><span class="comment">// AbstractBeanDefinition.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="comment">// 既存在重写方法又存在工厂方法,抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (hasMethodOverrides() &amp;&amp; getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Cannot combine factory method with container-generated method overrides: "</span> + <span class="string">"the factory method must create the concrete bean instance."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在给定了Class类型的beanClass对象</span></span><br><span class="line">  <span class="keyword">if</span> (hasBeanClass()) &#123;</span><br><span class="line">    <span class="comment">// 准备重写方法</span></span><br><span class="line">    prepareMethodOverrides();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMethodOverrides</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.methodOverrides.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.beanClass <span class="keyword">instanceof</span> Class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证并准备为该bean实例定义的重写方法</span></span><br><span class="line"><span class="comment"> * 检查是否存在具有指定名称的方法</span></span><br><span class="line"><span class="comment"> * 验证失败抛出BeanDefinitionValidationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找并检查方法是否存在并确定其重载状态</span></span><br><span class="line">  <span class="keyword">if</span> (hasMethodOverrides()) &#123;</span><br><span class="line">    getMethodOverrides().getOverrides().forEach(<span class="keyword">this</span>::prepareMethodOverride);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册BeanDefinition(加入(或覆盖)&lt;beanName, BeanDefinition/&gt;映射,如果设置了不允许覆盖则抛出异常)；添加已注册的beanName；从顺序手动注册的单例集合中移除beanName</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="comment">// 按注册手动注册的单例的名称列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeManualSingletonName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  updateManualSingletonNames(set -&gt; set.remove(beanName), set -&gt; set.contains(beanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新工厂内部手动注册单例的名称集合</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateManualSingletonNames</span><span class="params">(Consumer&lt;Set&lt;String&gt;&gt; action, Predicate&lt;Set&lt;String&gt;&gt; condition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">        action.accept(updatedSingletons);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">      action.accept(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行清理工作</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置给定bean的所有BeanDefinition缓存,包括从该bean派生的bean的缓存</span></span><br><span class="line"><span class="comment"> * 在替换或删除现有BeanDefinition后调用</span></span><br><span class="line"><span class="comment"> * 在给定bean和以给定bean为父bean的所有bean定义上触发clearMergedBeanDefinition()、destroySingleton()和resetBeanDefinition()方法</span></span><br><span class="line"><span class="comment"> * beanName：要重置的bean的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 删除给定bean的MergedBeanDefinition(合并的BeanDefinition,如果已经创建)</span></span><br><span class="line">  clearMergedBeanDefinition(beanName);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从单例缓存中删除相应的bean(如果有的话)</span></span><br><span class="line"><span class="comment">   * 通常不需要,而只是为了覆盖context的默认bean(例如StaticApplicationContext中的默认StaticMessageSource)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  destroySingleton(beanName);</span><br><span class="line">  <span class="comment">// 通知所有后置处理器指定的BeanDefinition已被重置</span></span><br><span class="line">  <span class="keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line">    processor.resetBeanDefinition(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重置将给定bean作为父bean的所有bean定义(递归)</span></span><br><span class="line">  <span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">      BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">      <span class="comment">// 由于beanDefinitionMap的潜在并发修改,请确保bd不为空</span></span><br><span class="line">      <span class="keyword">if</span> (bd != <span class="keyword">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">        resetBeanDefinition(bdName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Remove any assumptions about by-type mappings.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearByTypeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.allBeanNamesByType.clear();</span><br><span class="line">  <span class="keyword">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://sobxiong.github.io/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>https://sobxiong.github.io/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-03-06T17:42:37+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2021年3月6日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Spring/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Spring</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sobxiong.github.io/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=Spring源码分析 - SOBXiong的博客&summary=内容
总体流程
资源加载
解析XML
解析Bean
加载Bean
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sobxiong.github.io/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=Spring源码分析 - SOBXiong的博客&summary=内容
总体流程
资源加载
解析XML
解析Bean
加载Bean
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sobxiong.github.io/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=Spring源码分析 - SOBXiong的博客&summary=内容
总体流程
资源加载
解析XML
解析Bean
加载Bean
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2021/02/18/FrontEnd/Basic/JavaScript%E5%9F%BA%E7%A1%80/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>JavaScript基础</p>
                <p class='content'>内容
介绍
基本语法
对象
DOM
事件



介绍
ECMAScript：ECMAScript是一个标准，而这个标准需要由各个厂商去实现，其中Chrome浏览器的JavaScript的实现方式...</p>
              </a>
            
            
              <a class='next' href='/2021/01/23/SpringSeries/MyBatis/'>
                <p class='title'>MyBatis<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>内容
MyBatis入门



MyBatis入门
中文链接：https://mybatis.org/mybatis-3/zh/index.html

</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Spring源码分析',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总体流程"><span class="toc-text">总体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源加载"><span class="toc-text">资源加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析XML"><span class="toc-text">解析XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析Bean"><span class="toc-text">解析Bean</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:1942991710@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/SOBXiong"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="http://xiongjc.top" target="_blank" rel="noopener">Copyright © 2017-2020 SOBXiong</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
