<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2021/02/18/FrontEnd/Basic/JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/02/18/FrontEnd/Basic/JavaScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#介绍">介绍</a></li><li><a href="#基本语法">基本语法</a></li><li><a href="#对象">对象</a></li><li><a href="#DOM">DOM</a></li><li><a href="#事件">事件</a></li></ul><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>ECMAScript：ECMAScript是一个标准，而这个标准需要由各个厂商去实现，其中Chrome浏览器的JavaScript的实现方式为v8</li><li>JavaScript组成：ECMAScript、DOM、BOM</li><li>JavaScript特点：<ol><li>解释型语言(无需被解释为机器码再执行,直接执行;运行较慢,但使用了JIT技术得以改善)</li><li>动态语言(相比静态语言性能较差)</li><li>基于原型的面向对象</li><li>类似C、Java的语法结构</li></ol></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>编写位置：学习的JS都是客户端的JS(浏览器中运行)，因此要在网页中编写。JS代码需要编写到<code>&lt;script&gt;</code>标签中(一般写到<code>&lt;head&gt;</code>中;type————默认为text/javascript,可写不写;src————引入外部js文件时的文件路径)</li><li>注释：同Java，单行注释为<code>//</code>，多行为<code>/**/</code></li><li>变量：<ul><li>使用<code>var</code>关键字进行申明</li><li>数据类型<ul><li>五种基本数据类型(不可变,保存在栈中)：<ol><li>字符串型(String)<blockquote><p>用于表示一个字符序列(字符串)；需用’或”括起来；也有转义字符(\打头)<br> 将其他值转为字符串的三种方式：<code>toString()</code>、<code>String()</code>、拼串</p></blockquote></li><li>数值型(Number)<blockquote><p>表示整数和浮点数；表示的数字大小是有限的，越界会返回±Infinity<br> NaN(Not a Number)是一个特殊的值，对数值进行计算时没有结果则返回NaN<br> 将非数值转为数值的三个函数：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>，前者用于转换任意类型，后者只适用于字符串</p></blockquote></li><li>布尔型(Boolean)<blockquote><p>只能取true和false两种；其他数据类型可通过<code>Boolean()</code>函数转换<br> 转换规则如下：</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>String</td><td>非空字符串</td><td>“”(空串)</td></tr><tr><td>Number</td><td>非0值</td><td>0或NaN</td></tr><tr><td>Object</td><td>任意对象</td><td>null</td></tr><tr><td>Undefined</td><td>/</td><td>undefined</td></tr></tbody></table></blockquote></li><li>null型(Null)<blockquote><p>只有一个值null；null表示一个空对象，使用<code>typeof</code>检查null会返回一个Object<br> undefined值实际上是由null值衍生出的，比较undefined和null相等时会返回true</p></blockquote></li><li>undefined型(Undefined)<blockquote><p>只有一个值，即特殊的undefined；在使用var声明变量但未对其初始化时，该变量值即为undefined<br> <code>typeof</code>对没有初始化和没有声明的变量都返回undefined</p></blockquote></li></ol></li><li>Object类型(除上五种外的其他)</li><li><code>typeof</code>：类似于C，可用来检查一个变量的数据类型</li><li><code>instanceof</code>：任意对象使用typeof都返回Object；获取对象的具体类型可使用instanceof运算符————<code>变量 instanceof 类型</code></li></ul></li></ul></li><li>运算符<ul><li>相等 / 不相等：==(null和undefined返回true) / !=</li><li>全等 / 不全等：===(==在判断两个值时会进行自动的类型转换,===不会) / !==<blockquote><p>“55”==55(true)；”55”===55(false)</p></blockquote></li></ul></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p>Object对象</p><ul><li><p>介绍：是JavaScript中的引用数据类型；是一种复合值；可看作属性的无序集合，每个属性都是名值对；除创建自有属性，还可从名为原型的对象那继承属性；除字符串、数字、true、false、null和undefined外的所有值都是对象</p></li><li><p>创建对象的两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"SOBXiong"</span>;</span><br><span class="line">person.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">"SOBXiong"</span>,</span><br><span class="line">  age:<span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性：</p><ul><li>属性的访问<ol><li>.访问：对象.属性名</li><li>[]访问：对象[‘属性名’]</li></ol></li><li>修改属性值：对象.属性名 = 属性组</li><li>删除属性：delete 对象.属性名</li><li><code>constructor</code>：每个对象中都有一个constructor属性，它引用了当前对象的构造函数</li></ul></li><li><p>引用数据类型(栈保存对象地址;堆保存对象)：</p><ol><li>引用类型的值是保存在内存中的对象</li><li>当变量是对象时，实际上变量中保存的并不是对象本身，而是对象的引用</li><li>当变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中而不是创建一个新的对象。此时两个变量指向的是同一个对象，改变其中一个变量会影响另一个</li></ol></li></ul></li><li><p>基本包装类型：基本数据类型不能调用方法，JS提供了三个特殊的引用类型(typeof返回均为object)：</p><ol><li><p>Boolean：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最好不要使用</span></span><br><span class="line"><span class="keyword">var</span> bObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>Number</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数值时建议使用基本而非包装类</span></span><br><span class="line"><span class="keyword">var</span> nObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>String：<code>var sObj = new String(&quot;Hello world&quot;);</code></p></li></ol></li><li><p>Math对象：</p><ul><li>介绍：JS为保存数学公式和信息提供了一个公共位置；比直接编写的计算功能要快</li><li>常用方法：<ol><li><code>Math.max()</code>：最大值</li><li><code>Math.min()</code>：最小值</li><li><code>Math.ceil()</code>：向上舍</li><li><code>Math.floor()</code>：向下舍</li><li><code>Math.round()</code>：四舍五入</li><li><code>Math.random()</code>：随机数</li></ol></li></ul></li><li><p>Array(数组)：</p><ul><li><p>介绍：一种对象；一种表达有顺序关系的值的集合的数据结构；JS的数组可保存任意类型的数据</p></li><li><p>创建方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造器</span></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">123</span>, <span class="string">"hello"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 使用[]</span></span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Date(时间)：</p><ul><li><p>介绍：采取时间戳形式表示时间(从1970年1月1日0分0秒开始经过的毫秒数)</p></li><li><p>创建方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前默认时间</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(miliseconds);</span><br><span class="line"><span class="comment">// 格式为月/日/年 时:分:秒的字符串构造函数</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">02</span>/<span class="number">18</span>/<span class="number">2021</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Function(函数)：</p><ul><li><p>介绍：一种对象；函数也存储在堆中；参数传递都是按值传递；函数可作为参数传递；函数作为参数时后加()表示将函数执行的结果作为参数，否则将函数本身作为参数</p></li><li><p>声明方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumFunc1 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a + b&#125;;</span><br><span class="line"><span class="comment">// 存在函数声明提升,该方式在函数声明前就可调用函数,上种方式则不行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFunc2</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行环境(类似作用域)：</p><ul><li>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为</li><li>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中</li><li>全局执行环境是最外围的一个执行环境。在浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建</li><li>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁</li><li>在内部环境可以读取外部环境的变量，反之则不行</li></ul></li><li><p>内部属性(特殊对象)：</p><ol><li>arguments：一个数组，用于保存函数的参数；同时该对象还有callee表示当前函数</li><li>this：<ul><li>this引用的是一个对象。对于最外层代码与函数内部的情况，其引用目标是不同的</li><li>即使在函数内部，根据函数调用方式的不同，引用对象也会有所不同。this引用会根据代码的上下文语境自动改变其引用对象</li><li>在最外层代码中，this引用的是全局对象</li><li>在函数内，this根据函数调用方式的不同而有所不同，具体如下表所示：<table><thead><tr><th>函数调用方式</th><th>this引用的对象</th></tr></thead><tbody><tr><td>构造函数</td><td>所生成的对象</td></tr><tr><td>调用对象的方法</td><td>当前对象</td></tr><tr><td>apply或call调用</td><td>参数指定的对象</td></tr><tr><td>其他方式</td><td>全局对象(window)</td></tr></tbody></table></li></ul></li></ol></li><li><p>构造函数：</p><ul><li><p>介绍：</p><ol><li>用于生成对象的函数，例如<code>new Object()</code></li><li>通过new关键字调用；new中this引用了被生成的对象</li><li>任何函数都可通过new来调用，函数都可是构造函数</li></ol></li><li><p>声明方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数对象的方法：</p><ul><li><code>call()</code>：函数对象.call(this对象, 参数数组)</li><li><code>apply()</code>：函数对象.apply(this对象, 参数1, 参数2…)<blockquote><p>每个函数都有两个方法call()和apply()，其可指定一个函数的运行环境对象————this</p></blockquote></li></ul></li><li><p>闭包(closure)：当前作用域总是能够访问外部作用域中的变量。由于函数是JS中唯一拥有自身作用域的结构，闭包的创建依赖于函数。可将闭包的特征理解为————相关的局部变量在函数调用结束之后将会继续存在</p></li></ul></li><li><p>原型：JS是一个基于原型的面向对象语言</p><ul><li><p>原型介绍：在构造函数中存在着一个名为原型(prototype)的对象，该对象中保存着一些属性。凡是通过该构造函数创建的对象都可以访问存在于原型中的属性</p></li><li><p>原型属性举例：<code>toString()</code>————实际上对象中并没有定义这个函数，但却可以调用。因为该函数存在于Object对应的原型中</p></li><li><p>原型获取：</p><ol><li>构造函数.prototype<blockquote><p>原型就是一个对象，和其他对象没有任何区别，可通过构造函数来获取原型对象。prototype属性只存在于函数对象中，其他对象是没有prototype属性的</p></blockquote></li><li>Object.getPrototypeOf(对象)</li><li>对象._proto</li><li>对象.constructor.prototype</li></ol><blockquote><p>和其他对象一样，可添加、修改、删除原型中的属性，也可修改原型对象的引用<br>每个对象都有原型，原型对象也有原型。特殊的是，Object的原型对象没有原型<br>可获取Object的原型对象，也可对它的属性进行操作，但不能修改Object原型对象的引用</p></blockquote></li><li><p>原型链：对象、对象的原型、原型的原型…当从一个对象中获取属性时，首先从当前对象中查找，如果未找到则顺着向上查找原型对象，直到找到Object对象的原型位置，找到则返回，找不到则返回undefined</p></li></ul></li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul><li><p>介绍：DOM(Document Object Model)为文档对象模型；JavaScript可通过DOM对HTML文档进行操作</p><ol><li>文档：整个HTML网页文档</li><li>对象：网页中的每一个部分都转换为一个对象</li><li>模型：表示对象之间的关系</li></ol></li><li><p>节点(Node)：节点是构成网页的最基本的组成部分(构成HTML文档最基本的单元)，网页中的每一个部分都可称为一个节点————比如HTML标签、属性、文本、注释、整个文档等。节点具有不同的类型、属性和方法</p><ol><li><p>常用节点分类：</p><ul><li>文档节点：整个HTML文档<blockquote><p>文档节点document代表的是整个HTML文档，网页中所有节点都是它的子节点<br>document对象作为window对象的属性存在，不用获取即可直接使用<br>通过该对象可以在整个文档内查找节点对象，并可通过该对象创建各种节点对象</p></blockquote></li><li>元素节点：标签<blockquote><p>HTML中的各种标签都是元素节点，这也是最常用的一个节点<br>浏览器会将页面中所有的标签都转换为一个元素节点，可通过document的方法来获取元素节点，比如<code>document.getElementById()</code></p></blockquote></li><li>属性节点：元素的属性<blockquote><p>属性节点表示的是标签中的属性；属性节点并非元素节点的子节点，而是元素节点的一部分<br>可通过元素节点来获取指定的属性节点，比如<code>元素节点.getAttributeNode(&quot;属性名&quot;)</code>。一般不使用属性节点</p></blockquote></li><li>文本节点：标签中的文本内容<blockquote><p>文本节点表示的是HTML标签以外的文本内容，任意非HTML的文本都是文本节点<br>它包括字面解释的纯文本内容；文本节点一般是作为元素节点的子节点存在的<br>获取文本节点时，一般先要获取元素节点再通过元素节点获取文本节点，比如<code>元素节点.firstChild</code></p></blockquote></li></ul></li><li><p>节点属性：</p><table><thead><tr><th></th><th>nodeName</th><th>nodeType</th><th>nodeValue</th></tr></thead><tbody><tr><td>文档节点</td><td>#document</td><td>9</td><td>null</td></tr><tr><td>元素节点</td><td>标签名</td><td>1</td><td>null</td></tr><tr><td>属性节点</td><td>属性名</td><td>2</td><td>属性值</td></tr><tr><td>文本节点</td><td>#text</td><td>3</td><td>文本内容</td></tr></tbody></table></li><li><p>相应API：</p><ul><li><p>获取元素节点(通过document对象调用)：</p><ol><li><code>getElementById()</code>：通过id属性获取一个元素节点对象</li><li><code>getElementsByTagName()</code>： 通过标签名获取一组元素节点对象</li><li><code>getElementsByName()</code>：通过name属性获取一组元素节点对象</li></ol></li><li><p>获取元素节点的子节点(通过具体元素节点调用)：</p><ol><li><code>getElementsByTagName()</code>：返回当前节点的指定标签名的后代节点</li><li>childNodes(属性)：所有子节点</li><li>firstChild(属性)：第一个子节点</li><li>lastChild(属性)：最后一个子节点</li></ol></li><li><p>获取父节点和兄弟节点(通过具体节点调用)：</p><ol><li>parentNode：父节点</li><li>previousSibling：前一个兄弟节点</li><li>nextSibling：后一个兄弟节点</li></ol></li><li><p>元素节点的属性：</p><ol><li>获取：element.xxx</li><li>设置：element.xxx = xxx</li></ol></li><li><p>节点的修改：</p><ol><li><p>创建节点：<code>document.createElement(标签名)</code></p></li><li><p>删除节点：<code>父节点.removeChild(子节点)</code></p></li><li><p>替换节点：<code>父节点.replaceChild(新节点, 旧节点)</code></p></li><li><p>插入节点：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父节点.appendChild(子节点)</span><br><span class="line">父节点.insertBefore(新节点, 旧节点)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>其他属性：</p><ol><li>nodeValue：文本节点可通过该属性获取和设置文本节点的内容</li><li>innerHTML：元素节点可通过该属性获取和设置标签内部的HTML代码</li></ol></li></ul></li></ol></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><p>介绍：事件是文档或浏览器窗口中发生的一些特定的交互瞬间。JavaScript与HTML之间的交互是通过事件实现的。通过为指定事件绑定回调函数的形式来处理事件，当指定事件触发以后回调函数就会被调用，如此页面就可以完成和用户的交互</p></li><li><p>事件处理程序：</p><ol><li><p>通过HTML元素指定事件属性绑定：<code>&lt;button onclick=&quot;alert(&#39;hello&#39;);alert(&#39;world&#39;)&quot;&gt;按钮&lt;/button&gt;</code></p><blockquote><p>示例代码会使点击按钮后，onclick属性中的JavaScript代码将会执行<br> 除了直接将代码编写到onclick属性中，也可事先在外部定义函数<br> 如果在函数最后添加return false，会取消元素默认行为</p></blockquote></li><li><p>通过DOM对象指定属性绑定(推荐)</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello~~~"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法可将HTML代码和JavaScript设置在不同的地方，方便维护</p></blockquote></li><li><p>设置事件监听器：<code>元素对象.addEventListener()</code></p><blockquote><p>前两种方式都可以绑定事件处理程序，但是它们都只能绑定一个程序，而不能为一个事件绑定多个程序<br> 此时可使用addEventListener()来处理，该函数需要两个参数：事件字符串和响应函数————<code>btn.addEventListener(&#39;click&#39; , function() { alert(&quot;hello&quot;); });</code><br> 可使用removeEventListener()和detachEvent()移除事件</p></blockquote></li></ol></li><li><p>事件处理中的this：事件处理程序内的this所引用的对象即是设定了该事件处理程序的元素</p></li><li><p>事件对象：</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FrontEnd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码分析</title>
      <link href="/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/02/16/SpringSeries/Spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#总体流程">总体流程</a></li><li><a href="#资源加载">资源加载</a></li><li><a href="#解析XML">解析XML</a></li><li><a href="#解析Bean">解析Bean</a></li><li><a href="#加载Bean">加载Bean</a></li></ul><a id="more"></a><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><ul><li><p>说明：本文环境Spring版本5.3.1</p></li><li><p>分析入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test1.xml"</span>);</span><br><span class="line">  TestBean testBean = context.getBean(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(<span class="string">"testBean = "</span> + testBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassPathXmlApplicationContext构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassPathXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parent);</span><br><span class="line">  setConfigLocations(configLocations);</span><br><span class="line">  <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先调用<code>setConfigLocations(String[])</code>方法设置配置路径<br>接着调用<code>refresh()</code>方法实现扩展功能，其中包括最重要的加载bean容器过程</p></blockquote></li><li><p>setConfigLocations()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableConfigApplicationContext.java</span></span><br><span class="line"><span class="comment">// 设置应用程序上下文的配置路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableConfigApplicationContext.java</span></span><br><span class="line"><span class="comment">// 解析给定的路径,用相应的环境属性值替换占位符($&#123;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 创建应用环境信息,包括SystemProperties以及SystemEnvironment信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>setConfigLocations(String[])</code>方法用于解析给定的路径数组，如果路径中包含占位符(${})，那么会尝试利用系统配置信息和系统环境信息进行解析<br>可能的系统配置信息和系统环境信息如下：<br><img src="placeholderResolver%E5%86%85%E5%AE%B91.png" alt="placeholderResolver内容(1)"><br><img src="placeholderResolver%E5%86%85%E5%AE%B92.png" alt="placeholderResolver内容(2)"></p></blockquote></li><li><p>refresh()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载或刷新配置的持久表示(可来自基于Java配置、XML文件、属性文件、关系数据库模式或其他格式)</span></span><br><span class="line"><span class="comment"> * 由于这是一个启动方法,如果失败它应该销毁已经创建的单例以避免挂起资源</span></span><br><span class="line"><span class="comment"> * 换句话说,在调用这个方法之后,要么全部实例化,要么根本不实例化</span></span><br><span class="line"><span class="comment"> * 如果无法初始化BeanFactory,抛出BeansException</span></span><br><span class="line"><span class="comment"> * 如果已初始化且不支持多次刷新,抛出IllegalStateException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line">    <span class="comment">// 准备刷新的上下文环境</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// 初始化BeanFactory,进行XML文件读取</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">    <span class="comment">// 对BeanFactory进行各种功能填充</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 子类覆盖方法</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line">      StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line">      <span class="comment">// 激活各种BeanFactory处理器</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// 注册拦截Bean创建的处理器(BeanPostProcessor)</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      beanPostProcess.end();</span><br><span class="line">      <span class="comment">// 为上下文初始化Message源,用于国际化处理</span></span><br><span class="line">      initMessageSource();</span><br><span class="line">      <span class="comment">// 初始化应用消息广播器</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line">      <span class="comment">// 刷新结束的回调函数,交由子类实现</span></span><br><span class="line">      onRefresh();</span><br><span class="line">      <span class="comment">// 在注册的Bean中查找Listener类型的bean实例并注册到消息广播器中</span></span><br><span class="line">      registerListeners();</span><br><span class="line">      <span class="comment">// 初始化剩下所有的非惰性单例Bean</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">      <span class="comment">// 完成刷新过程,通知生命周期处理器lifecycleProcessor刷新过程,发出ContextRefreshEvent通知</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> + <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 销毁bean实例</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// 取消刷新</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">      contextRefresh.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>refresh()</code>方法包含了几乎ApplicationContext中提供的全部功能</p></blockquote></li><li><p>prepareRefresh()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 准备刷新的上下文环境</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录启动时间</span></span><br><span class="line">  <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 设置context状态</span></span><br><span class="line">  <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化上下文环境中任何占位符属性来源</span></span><br><span class="line">  <span class="comment">// 留给子类覆盖</span></span><br><span class="line">  initPropertySources();</span><br><span class="line">  <span class="comment">// 校验需要的配置属性是否已存在于Enviroment中</span></span><br><span class="line">  getEnvironment().validateRequiredProperties();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">    <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>prepareRefresh()</code>方法主要有两个较大作用的方法：</p><ol><li><code>initPropertySources()</code>方法：用户可根据需要重写该方法进行个性化属性处理(如环境变量中必须设置某个值才能运行)，这给予用户了最大扩展Spring能力</li><li><code>validateRequiredProperties()</code>方法：对属性进行验证</li></ol></blockquote></li><li><p><strong><em>obtainFreshBeanFactory()方法</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 通知子类刷新内部BeanFactory并返回</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化BeanFactory,进行XML文件读取,将BeanFactory赋值给属性</span></span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">// 执行上下文底层BeanFactory的实际刷新：关闭以前可能有的BeanFactory,初始化新的BeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在以前的BeanFactory</span></span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    <span class="comment">// 销毁Bean实例</span></span><br><span class="line">    destroyBeans();</span><br><span class="line">    <span class="comment">// 关闭以前的BeanFactory</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建DefaultListableBeanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    <span class="comment">// 设置序列化id(反序列化用)</span></span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    <span class="comment">// 定制化BeanFactory,设置相关属性(是否允许覆盖名称、是否允许循环依赖)</span></span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 初始化DocumentReader,进行XML文件读取并解析</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ApplicationContext是对BeanFactory功能上的扩展，不但包含BeanFactory的全部功能更在其基础上添加了大量扩展。ApplicationContext通过组合BeanFactory的方式进行复用<br><code>obtainFreshBeanFactory()</code>方法将核心实现委托给<code>refreshBeanFactory()</code>方法</p></blockquote><ul><li><p>createBeanFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">// 为上下文创建内部BeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultListableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">(@Nullable BeanFactory parentBeanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  setParentBeanFactory(parentBeanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  ignoreDependencyInterface(BeanNameAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ignoreDependencyInterface(BeanFactoryAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ignoreDependencyInterface(BeanClassLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (IN_NATIVE_IMAGE) &#123;</span><br><span class="line">    <span class="keyword">this</span>.instantiationStrategy = <span class="keyword">new</span> SimpleInstantiationStrategy();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.instantiationStrategy = <span class="keyword">new</span> CglibSubclassingInstantiationStrategy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>createBeanFactory()</code>方法最终构造了DefaultListableBeanFactory并传入可能有的父容器。在构造器链中，AbstractAutowireCapableBeanFactory的无参构造器中做了一些设置：忽略给定接口的自动装配功能(BeanNameAware.class、BeanFactoryAware.class以及BeanClassLoaderAware.class)、设置Bean实例化策略(instantiationStrategy)</p></blockquote></li><li><p>customizeBeanFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否允许覆盖同名称的不同定义的对象,默认null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否允许bean之间存在循环依赖,默认null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>loadBeanDefinitions()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="comment">// 通过XmlBeanDefinitionReader加载BeanDefinition</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为给定的BeanFactory创建XmlBeanDefinitionReader</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的环境变量</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的资源加载器</span></span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 设置beanDefinitionReader的实体解析器</span></span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 初始化BeanDefinitionReader,允许子类覆盖</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  <span class="comment">// 真正执行加载BeanDefinition</span></span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.registry = registry;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = ((EnvironmentCapable) <span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置XML解析的验证方式,默认为true</span></span><br><span class="line">  reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  Resource[] configResources = getConfigResources();</span><br><span class="line">  <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过资源加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configResources);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] configLocations = getConfigLocations();</span><br><span class="line">  <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过配置文件路径加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configLocations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>loadBeanDefinitions()</code>方法创建了XmlBeanDefinitionReader，并对其进行了一系列的设置，接下来将委托该对象进行XML的解析与BeanDefinition的加载工作，这是IOC的核心</p></blockquote></li></ul></li><li><p>prepareBeanFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// 配置BeanFactory的上下文特性,如类加载器和后处理器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置类加载器classLoader</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  <span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">    <span class="comment">// 设置BeanFactory的表达式语言处理器(SpEL)</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为BeanFactory设置默认属性编辑器(对bean属性等设置管理的工具)</span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line">  <span class="comment">// 添加ApplicationContextAwareProcessor</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 设置几个忽略自动装配的接口</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationStartup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">// 设置几个自动装配的特殊规则(可自动装配但在BeanFactory中没有定义为Bean)</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">  <span class="comment">// 注册早期后处理器ApplicationListenerDetector检查ApplicationListener类型的内部Bean</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 增加对AspectJ的支持</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// 为类型匹配设置临时类加载器</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册默认的系统环境Bean</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>prepareBeanFactory()</code>方法主要填充了BeanFactory的功能(具体参见注释)<br>其中Spring表达式语言全称为Spring Expression Language(SpEL)，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等。SpEL使用#{}作为定界符，大括号中的字符都将被认为是SpEL<br>PropertyEditor属性编辑器用于将XML中的String转为特定类的对象，可以通过继承PropertyEditorSupport类并注册实现该功能<br>xxxAwareProcessor后置处理器用于将实现xxxAware的bean初始化时设置相应的资源<br>xxxAwareProcessor注册后，间接调用的xxxAware类已经不是普通的bean了，因此无需在依赖注入时考虑</p></blockquote></li><li><p>postProcessBeanFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在标准初始化后修改ApplicationContext内部的BeanFactory</span></span><br><span class="line"><span class="comment"> * 将加载所有BeanDefinition,但尚未实例化任何Bean</span></span><br><span class="line"><span class="comment"> * 这允许在特定ApplicationContext实现中注册特定的BeanPostProcessor等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目前空实现,交由子类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>invokeBeanFactoryPostProcessors()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并调用所有已注册的BeanFactoryPostProcessor的Bean实例,按照给定的显式顺序(如果给定)</span></span><br><span class="line"><span class="comment"> * 必须在单例Bean实例化之前调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 委托PostProcessorRegistrationDelegate调用BeanFactoryPostProcessor</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">  <span class="comment">// 检测LoadTimeWeaver并准备将来的方法织入</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有,先调用BeanDefinitionRegistry</span></span><br><span class="line">  Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="comment">// 如果beanFactory是BeanDefinitionRegistry类型</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历硬编码注册的后处理器</span></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        <span class="comment">// 对于BeanDefinitionRegistryPostProcessor类型,在BeanFactoryPostProcessor基础上还有自定义的方法,需要先调用</span></span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        <span class="comment">// 记录BeanDefinitionRegistry</span></span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 记录常规BeanFactoryPostProcessor</span></span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不要在这里初始化Factory Bean：需要将所有常规Bean保持为初始化状态,以便BeanFactoryPostProcessor应用于它们</span></span><br><span class="line"><span class="comment">     * 分离实现PriorityOrdered、Ordered接口和其他的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 首先调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">    <span class="comment">// 接着调用实现了Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">    <span class="comment">// 最终调用所有其他BeanDefinitionRegistryPostProcessor,直到不再出现其他BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">      reiterate = <span class="keyword">false</span>;</span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">          processedBeans.add(ppName);</span><br><span class="line">          reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在调用到目前为止处理的所有处理器的postProcessBeanFactory回调</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用在context实例中注册的工厂处理器</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// 跳过,已在上面第一阶段处理过</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">  <span class="comment">// 清除缓存的MergedBeanDefinition,因为后处理器可能已修改了原始的元数据,例如替换值中的占位符...</span></span><br><span class="line">  beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用给定的BeanDefinitionRegistryPostProcessor类型的Bean实例</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    StartupStep postProcessBeanDefRegistry = applicationStartup.start(<span class="string">"spring.context.beandef-registry.post-process"</span>).tag(<span class="string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">    postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    postProcessBeanDefRegistry.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用给定的BeanFactoryPostProcessor类型的Bean实例</span></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start(<span class="string">"spring.context.bean-factory.post-process"</span>).tag(<span class="string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">    postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">    postProcessBeanFactory.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于BeanFactoryPostProcessor的处理分两种情况处理，一种是对BeanDefinitionRegistryPostProcessor类的特殊处理，另一种是普通的BeanFactoryPostProcessor的处理。对于每种情况都需要考虑硬编码以及配置注入的后处理器：<br>硬编码注入一般通过AbstractApplicationContext的<code>addBeanFactoryPostProcessor()</code>方法添加<br>接着每种情况都进行排序(除了没实现PriorityOrdered以及Ordered接口)，接着统一调用<code>postProcessBeanDefinitionRegistry()</code>或<code>postProcessBeanFactory()</code>方法</p></blockquote></li><li><p>registerBeanPostProcessors()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并注册所有BeanPostProcessor的Bean实例,按照给定的显式顺序(如果给定)</span></span><br><span class="line"><span class="comment"> * 必须在任何应用程序Bean实例化之前调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取通过配置文件注入的BeanPostProcessor名称</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="comment">// 统计BeanPostProcessor数目：硬编码 + BeanPostProcessorChecker + 配置文件</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  <span class="comment">// 注册BeanPostProcessorChecker,当BeanPostProcessor实例化期间创建bean时(即当一个bean没有资格被所有BeanPostProcessor处理时),它会记录一条信息</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">  <span class="comment">// 分离实现PriorityOrdered、Ordered接口和其他的BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 首先注册实现了PriorityOrdered接口的BeanPostProcessor</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">  <span class="comment">// 接着注册实现了Ordered接口的BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">  <span class="comment">// 接着注册所有其他BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line">  <span class="comment">// 最后再注册所有的内部BeanPostProcessor(MergedBeanDefinitionPostProcessor类型)</span></span><br><span class="line">  <span class="comment">// 并非重复注册,addBeanPostProcesor中会先移除已存在的BeanPostProcessor</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">  <span class="comment">// 添加用于检测内部Bean实例为ApplicationListener的后处理器ApplicationListenerDetector,将其移动到处理器链的末端(用于获取代理等)</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostProcessorRegistrationDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="comment">// 批量添加比CopyOnWriteArrayList更有效率</span></span><br><span class="line">    ((AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(beanPostProcessor, <span class="string">"BeanPostProcessor must not be null"</span>);</span><br><span class="line">  <span class="comment">// 移除旧的BeanPostProcessor</span></span><br><span class="line">  <span class="keyword">this</span>.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">  <span class="comment">// 添加新的BeanPostProcessor到list尾部</span></span><br><span class="line">  <span class="keyword">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对BeanPostProcessor和BeanFactoryPostProcessor处理极为相似，相同的是都根据PriorityOrdered、Ordered接口和其他BeanPostProcessor进行分别注册<br>不同的是BeanPostProcessor不是立刻使用而是注册，因此只需将所有配置注入的BeanPostProcessor加入到BeanFactory的属性中<br>在注册Bean时通过先<code>remove()</code>再<code>add()</code>确保了BeanPostProcessor的唯一性</p></blockquote></li><li><p>initMessageSource()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SOURCE_BEAN_NAME = <span class="string">"messageSource"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化MessageSource</span></span><br><span class="line"><span class="comment"> * 如果当前context没有定义,使用父容器定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 设置父MessageSource</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用空MessageSource以接收getMessage()调用</span></span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No '"</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">"' bean, using ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MessageSource主要用于国际化(i18n)，Spring通过封装JDK的java.util包中几个支持本地化的格式操作工具类NumberFormat、DateFormat、MessageFormat来支持国际化资源操作</p></blockquote></li><li><p>initApplicationEventMulticaster()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> * 如果context未定义,则使用SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    simpleApplicationEventMulticaster.setApplicationStartup(getApplicationStartup());</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = simpleApplicationEventMulticaster;</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> + <span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ApplicationEventMulticaster使用观察者模式，存放监听器并在合适的时候调用监听器(回调)</p></blockquote></li><li><p>onRefresh()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板方法,可重写该方法(交由子类)以添加特定context的刷新工作</span></span><br><span class="line"><span class="comment"> * 在初始化特殊Bean时调用,在单例Bean实例化之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>registerListeners()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将实现ApplicationListener接口的Bean添加为监听器</span></span><br><span class="line"><span class="comment"> * 不会影响那些被添加但无需成为Bean的其他监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先注册硬编码方法注册的监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不要在这里初始化Factory Bean：需要将所有常规bean保持为未初始化状态以便让后处理器应用于它们</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布早期applicationEvent</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>finishBeanFactoryInitialization()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成此context的BeanFactory的初始化,初始化剩余所有的单例Bean</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为此context初始化转换服务</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">    beanFactory.setConversionService(beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前没有注册Bean后处理器(比如PropertyPlaceholderConfigurer)</span></span><br><span class="line">  <span class="comment">// 那么注册一个默认的EmbeddedValueResolver(嵌入值解析器)：此时主要用于annotation(注解)属性值的解析</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尽早初始化LoadTimeWeaverAware以便尽早注册它们的转换器</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 停止使用临时类加载器进行类型匹配</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 运行缓存所有BeanDefinition元数据,预期没有进一步的修改</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line">  <span class="comment">// 实例化所有剩余的单例Bean(不是lazy init(惰性加载))</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保实例化所有非惰性单例Bean,同时考虑到FactoryBeans</span></span><br><span class="line"><span class="comment"> * 如果需要,通过在工厂设置结束时调用</span></span><br><span class="line"><span class="comment"> * 如果无法创建一个单例Bean,则抛出BeansException</span></span><br><span class="line"><span class="comment"> * 注意：这可能使工厂中的一些Bean实例已经初始化</span></span><br><span class="line"><span class="comment"> * 在这种情况下,调用destorySingletons()进行完全清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 迭代副本以允许init方法注册新的BeanDefinition</span></span><br><span class="line">  <span class="comment">// 尽管这不是常规Factory引导的一部分,但它在其他方面工作正常</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">  <span class="comment">// 触发所有非单例Bean的初始化</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发所有适用Bean的初始化后的回调函数</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">"spring.beans.smart-initialize"</span>).tag(<span class="string">"beanName"</span>, beanName);</span><br><span class="line">      SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">      smartInitialize.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>finishBeanFactoryInitialization()</code>方法主要完成BeanFactory的初始化工作，包括ConversionService的设置、配置冻结以及非延迟单例Bean的初始化工作<br>ConversionService为自定义类型的转换器，大部分是将String转换为指定类型的对象<br><code>freezeConfiguration()</code>方法用于配置冻结，说明注册的BeanDefinition将不被修改或进一步的处理<br><code>preInstantiateSingletons()</code>方法用于实例化所有单例Bean，这也是ApplicationContext实现的默认行为</p></blockquote></li><li><p>finishRefresh()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刷新context的刷新工作,调用LifecycleProcessor的onRefresh()方法并发布ContextRefreshedEvent</span></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清除上下文级别的资源缓存(例如源于扫描的ASM元数据)</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line">  <span class="comment">// 为context初始化LifecycleProcessor</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line">  <span class="comment">// 首先调用LifecycleProcessor的onRefresh()方法</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line">  <span class="comment">// 发布ContextRefreshedEvent事件</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 如果处于活动状态,参与LiveBeansView MBean(用于监控,SpringBoot的actuator模块用到)</span></span><br><span class="line">  <span class="keyword">if</span> (!IN_NATIVE_IMAGE) &#123;</span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring提供了Lifecycle接口，其中包含<code>start()</code>和<code>stop()</code>方法，实现此接口保证在Spring生命周期开始和结束时分别调用这两个方法，通常用于配置后台程序(如对MQ进行轮训)</p></blockquote></li><li><p>ApplicationContext介绍：<br><img src="ApplicationContext%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ApplicationContext继承情况"></p><blockquote><p><strong><em>BeanFactory</em></strong>：Spring管理Bean的顶层接口，ApplicationContext的IOC容器功能通过复用BeanFactory<br><strong><em>ResourceLoader</em></strong>：Spring加载资源的顶层接口，同样通过复用<br>ApplicationEventPublisher：封装事件发布功能<br>MessageSource：解析Message的策略接口，用于国际化<br>EnvironmentCapable：用于获取Environment</p></blockquote><p>常用的ClassPathXmlApplicationContext：<br><img src="ClassPathXmlApplicationContext%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ClassPathXmlApplicationContext继承情况"></p></li></ul><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><ul><li><p>背景：JavaSE中有一个标准类<code>java.net.URL</code>，表示统一资源定位器(Uniform Resource Locator)，但其实现存在局限性，没有定义相对于Classpath或ServletContext等资源的解析方式。因此Spring抽象了Resource用于统一资源，抽象了ResourceLoader用于统一资源加载</p></li><li><p>Resource接口(统一资源抽象)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resource.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exists();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputStreamSource.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line">  <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>InputStreamSource接口封装任何能返回InputStream的类(如File、Classpath下的资源和Byte Array等)，它只定义了一个方法————<code>getInputStream()</code><br>Resource接口抽象了所有Spring内部使用到的底层资源：File、URL、Classpath等，针对不同来源的资源文件，存在多种Resource实现：</p><ol><li>FileSystemResource：对java.io.File类型资源的封装，支持文件和URL的形式，实现WritableResource接口；从Spring5开始，FileSystemResource使用NIO2的API进行读/写交互</li><li>ByteArrayResource：对字节数组类型资源的封装。如果通过InputStream形式访问该类型的资源，该实现会根据字节数组的数据构造一个对应的ByteArrayInputStream</li><li>UrlResource：对java.net.URL类型资源的封装。内部委派URL进行具体操作</li><li>ClassPathResource：获取Classpath类型资源的实现。使用给定的ClassLoader或者给定的Class来加载资源</li><li>InputStreamResource：获取InputStream类型资源的实现</li></ol><p><img src="Resource%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="Resource继承情况"></p></blockquote></li><li><p>ResourceLoader接口(统一资源加载器抽象)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceLoader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">  <span class="comment">// "classpath:"</span></span><br><span class="line">  String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line">  <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring将资源的定义和加载区分开，ResourceLoader资源加载器用于根据给定的资源文件地址返回对应的Resource<br><img src="ResourceLoader%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ResourceLoader继承图"></p></blockquote></li><li><p>loadBeanDefinitions()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的XmlBeanDefinitionReader加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * BeanFactory的生命周期是由refreshBeanFactory()方法处理的；因此该方法只应该是加载和/或注册BeanDefinition</span></span><br><span class="line"><span class="comment"> * 在Bean注册错误的情况下抛出BeansException</span></span><br><span class="line"><span class="comment"> * 在找不到所需的XML文档的情况下抛出IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  Resource[] configResources = getConfigResources();</span><br><span class="line">  <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过资源加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configResources);</span><br><span class="line">  &#125;</span><br><span class="line">  String[] configLocations = getConfigLocations();</span><br><span class="line">  <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过配置文件路径加载BeanDefinition</span></span><br><span class="line">    reader.loadBeanDefinitions(configLocations);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">    count += loadBeanDefinitions(location);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的资源位置加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 如果该BeanDefinitionReader的ResourceLoader是ResourcePatternResolver,那么路径可以是一个路径模式</span></span><br><span class="line"><span class="comment"> * actualResources是一个集合,用于填充加载过程中解析的实际资源对象;可以为null,表示调用者对这些资源对象不感兴趣</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">  <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot load bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">    <span class="comment">// 资源模式匹配可用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">      <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Collections.addAll(actualResources, resources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只能按绝对URL加载单个资源</span></span><br><span class="line">    Resource resource = resourceLoader.getResource(location);</span><br><span class="line">    <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">    <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      actualResources.add(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    count += loadBeanDefinitions(resource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =</span><br><span class="line">  <span class="keyword">new</span> NamedThreadLocal&lt;Set&lt;EncodedResource&gt;&gt;(<span class="string">"XML bean definition resources currently being loaded"</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;EncodedResource&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的XML文件加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 参数encodedResource是XML文件的资源描述符,允许指定用于解析文件的编码</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取当前线程保存的正在加载的资源</span></span><br><span class="line">  Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">  <span class="comment">// 如果有重复,就说明存在循环加载问题,抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取输入流</span></span><br><span class="line">  <span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">    <span class="comment">// 封装成SAX的标准输入流</span></span><br><span class="line">    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">    <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正执行加载BeanDefinition</span></span><br><span class="line">    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清理当前线程保存的正在加载的资源</span></span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在总体流程中分析到<code>loadBeanDefinitions()</code>方法，顺着该方法，方法内部调用了一系列的重载方法<br>比较重要的有两个地方：<br>一个是类AbstractBeanDefinitionReader内<code>loadBeanDefinitions(String, Set&lt;Resource&gt;)</code>方法，该方法首先获取了ResourceLoader，接着用该对象的<code>getResource()</code>方法加载资源，最后通过调用重载的<code>loadBeanDefinitions(Resource[])</code>方法；首先来看看获取的ResourceLoader对象以及<code>getResource()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于将路径模式解析为资源实例的ResourcePatternResolver</span></span><br><span class="line"><span class="comment"> * 默认是支持Ant风格路径模式的PathMatchingResourcePatternResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"><span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null"</span>);</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定的路径默认解析为资源对象</span></span><br><span class="line"><span class="comment"> * 应尽可能避免重叠资源条目指向统一物理资源。结果应该具有set语义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">  <span class="comment">// String CLASSPATH_ALL_URL_PREFIX = "classpath*:";</span></span><br><span class="line">  <span class="comment">// 如果以"classpath*:"开头</span></span><br><span class="line">  <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// 类路径资源(可能有同名的多个资源)</span></span><br><span class="line">    <span class="comment">// 如果路径是表示一种模式(含有'*'、'?'、"&#123;&#125;"等通配符)</span></span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">      <span class="comment">// 单个类路径资源路径模式</span></span><br><span class="line">      <span class="comment">// 解析通配符的路径获取资源</span></span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 具有给定名称的所有类路径资源</span></span><br><span class="line">      <span class="comment">// 返回classpath路径下和所有jar包中的所有相匹配资源</span></span><br><span class="line">      <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不以"classpath*:"开头</span></span><br><span class="line">    <span class="comment">// 通常在这里只查找前缀后面的模式</span></span><br><span class="line">    <span class="keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="string">"war:"</span>) ? locationPattern.indexOf(<span class="string">"*/"</span>) + <span class="number">1</span> : locationPattern.indexOf(<span class="string">':'</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">      <span class="comment">// 单个文件模式</span></span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 具有给定名称的单个资源</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用的ResourceLoader资源加载器其实是传入的applicationContext，它在<code>loadBeanDefinitions()</code>方法中被设置<br>其次ApplicationContext接口继承了ResourceLoader，因此可以被当成是ResourceLoader。而且AbstractApplicationContext继承自DefaultResourceLoader。在AbstractApplicationContext类构造器中，显式地初始化了PathMatchingResourcePatternResolver类的对象作为其委托的ResourceLoader实例并传入了自身。PathMatchingResourcePatternResolver相当于持有了DefaultResourceLoader(ApplicationContext)以及AntPatchMatcher，并将加载资源和路径模式匹配的工作委托给这两个属性<br>接着看获取资源<code>getResources()</code>方法，根据是否以”classpath*:”和是否是路径模式共给出三种获取资源的方式，具体不再展开</p><p>另一处<code>doLoadBeanDefinitions()</code>方法是最重要的，这是核心逻辑部分，用于执行加载BeanDefinition的操作，在后面的XML解析部分说明</p></blockquote></li><li><p>ResourceLoader解析Resource过程简单介绍：</p><ol><li><p>findAllClassPathResources()方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// location：类路径中的绝对路径</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  String path = location;</span><br><span class="line">  <span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    path = path.substring(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 委托给doFindAllClassPathResources()方法执行</span></span><br><span class="line">  Set&lt;Resource&gt; result = doFindAllClassPathResources(path);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Resolved classpath location ["</span> + location + <span class="string">"] to resources "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过类加载器找到具有给定路径的所有类路径资源</span></span><br><span class="line"><span class="comment"> * path：不带前导'/'的类路径中的绝对路径</span></span><br><span class="line"><span class="comment"> * 返回一组匹配的资源实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  ClassLoader cl = getClassLoader();</span><br><span class="line">  <span class="comment">// 根据ClassLoader加载路径下的所有资源</span></span><br><span class="line">  Enumeration&lt;URL&gt; resourceUrls = (cl != <span class="keyword">null</span> ? cl.getResources(path) : ClassLoader.getSystemResources(path));</span><br><span class="line">  <span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = resourceUrls.nextElement();</span><br><span class="line">    <span class="comment">// 将URL转为URLResource</span></span><br><span class="line">    result.add(convertClassLoaderURL(url));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是""(空路径)</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasLength(path)) &#123;</span><br><span class="line">    <span class="comment">// 上述结果可能不完整,即仅包含文件系统引用</span></span><br><span class="line">    <span class="comment">// 同时需要加载类路径下的每个jar文件</span></span><br><span class="line">    addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>findPathMatchingResources()方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过Ant风格的PathMatcher查找与给定路径模式匹配的所有资源</span></span><br><span class="line"><span class="comment"> * 支持jar、zip和文件系统中的资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// PathMatchingResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 确定根路径</span></span><br><span class="line">  String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">  <span class="comment">// 确定子路径</span></span><br><span class="line">  String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">  <span class="comment">// 获取根路径下的资源</span></span><br><span class="line">  Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  <span class="comment">// 遍历根路径下的资源</span></span><br><span class="line">  <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">    URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">    <span class="comment">// bundle资源类型</span></span><br><span class="line">    <span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="string">"bundle"</span>)) &#123;</span><br><span class="line">      URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirUrl);</span><br><span class="line">      <span class="keyword">if</span> (resolvedUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rootDirUrl = resolvedUrl;</span><br><span class="line">      &#125;</span><br><span class="line">      rootDirResource = <span class="keyword">new</span> UrlResource(rootDirUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vfs资源类型</span></span><br><span class="line">    <span class="keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">      result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">      <span class="comment">// jar资源类型</span></span><br><span class="line">      result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他资源类型</span></span><br><span class="line">      result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getResource()方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultResourceLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">  <span class="comment">// 通过ProtocolResolver加载资源</span></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * ProtocolResolver是用户自定义协议资源解决策略,作为DefaultResourceLoader的SPI(Service Provider Interface)</span></span><br><span class="line"><span class="comment">   * 它允许用户自定义资源加载协议,而不需要继承ResourceLoader的子类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">    Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果以'/'开头,返回ClassPathContextResource类型的资源</span></span><br><span class="line">  <span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// 再者,如果以"classpath:"开头,返回ClassPathResource类型的资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试将路径解析为URL</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">      <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">      <span class="comment">// 不是URL,当作资源路径解析</span></span><br><span class="line">      <span class="comment">// 返回ClassPathContextResource类型的资源</span></span><br><span class="line">      <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2><ul><li><p>背景：传统Spring程序均通过XML定义bean实例；因此Spring使用SAX(Simple API for XML)方式解析XML。该方式是sun公司内置于Java的，比传统的DOM解析方式快</p></li><li><p>doLoadBeanDefinitions()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的XML文件实际加载BeanDefinition</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在加载或解析XML错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析XML文档获取XML Document实例</span></span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="comment">// 根据Document实例注册BeanDefinition</span></span><br><span class="line">    <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</span><br><span class="line"><span class="keyword">private</span> ErrorHandler errorHandler = <span class="keyword">new</span> SimpleSaxErrorHandler(logger);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> namespaceAware = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>doLoadBeanDefinitions()</code>方法中主要做了两件事<br>其一是解析XML获取Document实例，另一是注册BeanDefinition<br>在这部分中先说明解析步骤：<br>获取Document实例过程又将解析任务委托给DocumentLoader对象处理，在解析XML中传入了许多参数：</p><ol><li><p>inputSource：加载XML的Document的资源，封装InputStream而来</p></li><li><p>entityResolver：用于解析任何实体的解析器，默认是ResourceEntityResolver，在初始化XmlBeanDefinitionReader时设置</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>errorHandler：用于报告Document加载期间错误的错误处理器</p></li><li><p>validationMode：XML的验证模式</p></li><li><p>namespaceAware：是否要提供对XML名称空间的支持</p></li></ol><p>接着顺序分析<code>getValidationModeForResource()</code>方法以及<code>loadDocument()</code>方法，其中前者用于获取XML的验证模式，后者用于加载Document</p></blockquote></li><li><p>getValidationModeForResource()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确定指定资源的验证模式</span></span><br><span class="line"><span class="comment"> * 如果未显式设置验证模式,则验证模式将通过detectValidationMode()方法检测</span></span><br><span class="line"><span class="comment"> * 如果想完全控制验证模式,则重写此方法(即使设置了VALIDATION_AUTO)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// 禁用验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line"><span class="comment">// 自动获取验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line"><span class="comment">// DTD验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line"><span class="comment">// XSD验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line"><span class="comment">// 默认为自动模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> validationMode = VALIDATION_AUTO;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取指定的验证模式</span></span><br><span class="line">  <span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line">  <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检测XML的验证模式</span></span><br><span class="line">  <span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line">  <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">    <span class="keyword">return</span> detectedMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以XSD验证模式兜底</span></span><br><span class="line">  <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测所提供资源标识的XML的验证模式</span></span><br><span class="line"><span class="comment"> * 如果文件具有DOCTYPE定义则使用DTD验证,否则假定使用XSD验证</span></span><br><span class="line"><span class="comment"> * 如果要自定义自动验证模式的处理策略,重写此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// XML验证检测器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlValidationModeDetector validationModeDetector = <span class="keyword">new</span> XmlValidationModeDetector();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果资源不可读</span></span><br><span class="line">  <span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Passed-in Resource ["</span> + resource + <span class="string">"] contains an open stream: "</span> + <span class="string">"cannot determine validation mode automatically. Either pass in a Resource "</span> + <span class="string">"that is able to create fresh streams, or explicitly specify the validationMode "</span> + <span class="string">"on your XmlBeanDefinitionReader instance."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  InputStream inputStream;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = resource.getInputStream();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: cannot open InputStream. "</span> + <span class="string">"Did you attempt to load directly from a SAX InputSource without specifying the "</span> + <span class="string">"validationMode on your XmlBeanDefinitionReader instance?"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取相应验证模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unable to determine validation mode for ["</span> + resource + <span class="string">"]: an error occurred whilst reading from the InputStream."</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlValidationModeDetector.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DOCTYPE = <span class="string">"DOCTYPE"</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasDoctype</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> content.contains(DOCTYPE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为了寻找DOCTYPE而快速查看文件</span></span><br><span class="line">  <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream))) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</span><br><span class="line">    String content;</span><br><span class="line">    <span class="comment">// 逐行读取XML文件内容</span></span><br><span class="line">    <span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      content = consumeCommentTokens(content);</span><br><span class="line">      <span class="comment">// 跳过注释和空行</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否包含"DOCTYPE",如包含则是DTD模式</span></span><br><span class="line">      <span class="keyword">if</span> (hasDoctype(content)) &#123;</span><br><span class="line">        isDtdValidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 走到正文,跳出</span></span><br><span class="line">      <span class="keyword">if</span> (hasOpeningTag(content)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (CharConversionException ex) &#123;</span><br><span class="line">    <span class="comment">// 被一些字符编码阻塞</span></span><br><span class="line">    <span class="comment">// 把决定权交给调用者</span></span><br><span class="line">    <span class="keyword">return</span> VALIDATION_AUTO;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加载Document首先要获取XML文件的验证模式(验证模式保证了XML文件的正确性)，DTD(Document Type Definition————文档类型定义)和XSD(XML Schemas Definition)是两个用于XML文件的验证机制<br>XSD是为了替代DTD而出现的，基于XML，没有专门的语法(DTD不基于XML)，比DTD更优秀<br><code>getValidationModeForResource()</code>函数首先获取指定的验证模式，默认为自动模式。然后将检测验证模式的职责交由XmlValidationModeDetector类处理————逐行读取XML中的文本，根据是包含”DOCTYPE”判断是否为DTD模式</p></blockquote></li><li><p>loadDocument()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准的JAXP(Java API for XML Processing)配置的XML解析器根据提供的InputStream加载Document</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">  <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DocumentBuilderFactory实例</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">  factory.setNamespaceAware(namespaceAware);</span><br><span class="line">  <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">    factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">      <span class="comment">// 如果为XSD验证模式,强制使用命名空间支持</span></span><br><span class="line">      factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(<span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory + <span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> + <span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);</span><br><span class="line">        pcex.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> pcex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成DocumentBuilder用于解析XML文档</span></span><br><span class="line"><span class="comment">// DefaultDocumentLoader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilder <span class="title">createDocumentBuilder</span><span class="params">(DocumentBuilderFactory factory, @Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span> <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">  DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">  <span class="keyword">if</span> (entityResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">    docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DocumentLoader是Spring用于包装SAX解析XML的类<br><code>loadDocument()</code>方法内部主要通过填充参数的方式创建了DocumentBuilderFactory和DocumentBuilder对象，而后者真正用于解析XML文档。这两个类都是JDK底层SAX部分代码，与Spring无关，Spring委托SAX处理XML解析工作，具体不再展开<br>最后介绍一下EntityResolver，该类也是SAX规定的类，定义寻找解析文件的逻辑</p></blockquote></li><li><p>ResourceEntityResolver介绍(EntityResolver实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EntityResolver.java</span></span><br><span class="line"><span class="comment">// 用于定义寻找解析文件的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityResolver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> InputSource <span class="title">resolveEntity</span> <span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException, IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceEntityResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResourceEntityResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(resourceLoader.getClassLoader());</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(@Nullable String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类DelegatingEntityResolver进行解析</span></span><br><span class="line">  InputSource source = <span class="keyword">super</span>.resolveEntity(publicId, systemId);</span><br><span class="line">  <span class="comment">// 解析失败,使用ResourceLoader解析</span></span><br><span class="line">  <span class="keyword">if</span> (source == <span class="keyword">null</span> &amp;&amp; systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取Resource资源地址</span></span><br><span class="line">    String resourcePath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String decodedSystemId = URLDecoder.decode(systemId, <span class="string">"UTF-8"</span>);</span><br><span class="line">      String givenUrl = <span class="keyword">new</span> URL(decodedSystemId).toString();</span><br><span class="line">      <span class="comment">// 获取解析文件资源的相对路径(相对于系统根路径)</span></span><br><span class="line">      String systemRootUrl = <span class="keyword">new</span> File(<span class="string">""</span>).toURI().toURL().toString();</span><br><span class="line">      <span class="comment">// 如果在系统根目录,尝试相对于资源库</span></span><br><span class="line">      <span class="keyword">if</span> (givenUrl.startsWith(systemRootUrl)) &#123;</span><br><span class="line">        resourcePath = givenUrl.substring(systemRootUrl.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Could not resolve XML entity ["</span> + systemId + <span class="string">"] against system root URL"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是URL(或不是可处理的URL),尝试相对于资源库</span></span><br><span class="line">      resourcePath = systemId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resourcePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Trying to locate XML entity ["</span> + systemId + <span class="string">"] as resource ["</span> + resourcePath + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取Resource资源</span></span><br><span class="line">      Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resourcePath);</span><br><span class="line">      source = <span class="keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">      <span class="comment">// 设置publicId和systemId</span></span><br><span class="line">      source.setPublicId(publicId);</span><br><span class="line">      source.setSystemId(systemId);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found XML entity ["</span> + systemId + <span class="string">"]: "</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 网络请求验证文件</span></span><br><span class="line">      String url = systemId;</span><br><span class="line">      <span class="keyword">if</span> (url.startsWith(<span class="string">"http:"</span>)) &#123;</span><br><span class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        source = <span class="keyword">new</span> InputSource(<span class="keyword">new</span> URL(url).openStream());</span><br><span class="line">        source.setPublicId(publicId);</span><br><span class="line">        source.setSystemId(systemId);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Could not resolve XML entity ["</span> + systemId + <span class="string">"] through URL ["</span> + url + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回到解析器的默认行为</span></span><br><span class="line">        source = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DelegatingEntityResolver.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelegatingEntityResolver</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dtdResolver = <span class="keyword">new</span> BeansDtdResolver();</span><br><span class="line">  <span class="keyword">this</span>.schemaResolver = <span class="keyword">new</span> PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(@Nullable String publicId, @Nullable String systemId)</span> <span class="keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 调用BeansDtdResolver解析</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.dtdResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">      <span class="comment">// 调用PluggableSchemaResolver解析</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.schemaResolver.resolveEntity(publicId, systemId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回到解析器的默认行为</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>EntityResolver主要用于获取解析文件，有了解析文件就可以验证XML编写是否符合规则<br>当前默认采用ResourceEntityResolver获取解析文件(由于构造时传入context————ResourceLoader的子接口)，首先调用父类的<code>resolveEntity()</code>方法进行解析<br>父类DelegatingEntityResolver则分别根据验证文件类型分别交由BeansDtdResolver(DTD)和PluggableSchemaResolver(XSD)类来获取解析文件<br>如果是XSD类型，PluggableSchemaResolver会先获取一个映射表，映射表是通过META-INF/spring.schemas从Spring依赖包(spring-beans)获取的，该配置文件中写明了映射表内容；BeansDtdResolver也先通过文件查找<br>如果以上都解析不出，则通过网络访问</p></blockquote></li></ul><h2 id="解析Bean"><a href="#解析Bean" class="headerlink" title="解析Bean"></a>解析Bean</h2><ul><li><p>背景：目前为止，XML已经被SAX解析为Document文档了，接下来可以进行真正的Bean解析注册过程了</p></li><li><p>registerBeanDefinitions()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册给定DOM文档中包含的BeanDefinition</span></span><br><span class="line"><span class="comment"> * 创建parser的新实例并调用它的registerBeanDefinitions()方法</span></span><br><span class="line"><span class="comment"> * 返回找到的BeanDefinition数量</span></span><br><span class="line"><span class="comment"> * 在解析错误情况下抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建BeanDefinitionDocumentReader对象</span></span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="comment">// 获取已注册的BeanDefinition数量</span></span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  <span class="comment">// 创建XmlReaderContext对象以及注册BeanDefinition</span></span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="comment">// 计算新注册的BeanDefinition数目</span></span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建BeanDefinitionDocumentReader用于实例从XML文档中读取BeanDefinition</span></span><br><span class="line"><span class="comment"> * 默认实现采用指定的documentReaderClass进行实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"><span class="comment">// 创建XmlReaderContext引用传递给DocumentReader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果之前未设置则延迟创建默认的NamespaceHandlerResolver</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandlerResolver <span class="title">getNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.namespaceHandlerResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.namespaceHandlerResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建NamespaceHandlerResolver的默认实现,如果没指定的话</span></span><br><span class="line"><span class="comment"> * 默认实现返回DefaultNamespaceHandlerResolver实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> NamespaceHandlerResolver <span class="title">createDefaultNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = (getResourceLoader() != <span class="keyword">null</span> ? getResourceLoader().getClassLoader() : getBeanClassLoader());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultNamespaceHandlerResolver(cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>registerBeanDefinitions()</code>方法首先创建了BeanDefinitionDocumentReader对象，实例是DefaultBeanDefinitionDocumentReader类型；该对象用于将Document解析为BeanDefinition<br>接着将注册BeanDefinition的任务委托给了BeanDefinitionDocumentReader，在当中创建了XmlReaderContext对象，该对象是在BeanDefinition读取过程中传递的上下文，封装了所有相关的配置和状态，它包括几个重要的属性：</p><ol><li>source：原始资源描述符</li><li>problemReporter：问题报告器————允许工具和其他外部进程处理BeanDefinition解析期间报告的错误和警告</li><li>eventListener：事件回调接口————用于接收在BeanDefinition读取过程中component(组件)、alias(别名)和import(倒入)注册的回调</li><li>sourceExtractor：源数据抽取器————允许工具控制源数据的metadata(元数据)如何附加到BeanDefinition metadata(元数据)的简单策略</li><li>namespaceHandlerResolver：命名空间处理器解析器————由DefaultBeanDefinitionDocumentReader设置，用于定位处理特定命名空间URI的namespaceHandler实现(命名空间处理器实现)</li></ol></blockquote></li><li><p>委托的registerBeanDefinitions()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该实现根据spring-beans的XSD(或者历史上的DTD)解析BeanDefinition</span></span><br><span class="line"><span class="comment"> * 打开一个DOM文档；接着初始化&lt;beans/&gt;标签级别指定的默认设置；然后解析包含的BeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">  <span class="comment">// 获取XML的Document的Root元素,执行注册BeanDefinition</span></span><br><span class="line">  doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROFILE_ATTRIBUTE = <span class="string">"profile"</span>;</span><br><span class="line"><span class="comment">// 在给定的根&lt;beans/&gt;标签中注册每个BeanDefinition</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 任何嵌套的&lt;beans&gt;标签都会导致此方法的递归调用</span></span><br><span class="line"><span class="comment">   * 为了正确地传播和保留&lt;beans&gt;标签的"default-*"属性,请跟踪当前(parent,父)delegate(委托),该委托可能为null</span></span><br><span class="line"><span class="comment">   * 创建新的(子)委托,并引用父代理以进行回退(fallback),然后最终重置此委托为其原始(父)引用</span></span><br><span class="line"><span class="comment">   * 此行为模拟一个委托栈而不用实现一个委托栈</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 记录老的BeanDefinitionParserDelegate对象</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="comment">// 创建新的BeanDefinitionParserDelegate对象,并设置给delegate属性</span></span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">  <span class="comment">// 检查是否是默认命名空间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 获取profile属性并处理</span></span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      <span class="comment">// 使用分隔符切分得到可能的多个profile</span></span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// 不能使用Profiles.of(...)方法,因为XML配置中不支持配置表达式。详见SPR-12458</span></span><br><span class="line">      <span class="comment">// 如果profile都无效,则不进行注册</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec + <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析前处理,模板设计模式,当前空实现</span></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  <span class="comment">// 解析XML成BeanDefinition</span></span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  <span class="comment">// 解析后处理,模板设计模式,当前空实现</span></span><br><span class="line">  postProcessXml(root);</span><br><span class="line">  <span class="comment">// 设置回老的BeanDefinitionParserDelegate对象</span></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>registerBeanDefinitions()</code>方法将具体执行注册BeanDefinition的逻辑委托给<code>doRegisterBeanDefinitions()</code>方法<br>该方法进行进行了许多操作：</p><ol><li><p>记录老(父)BeanDefinitionParserDelegate引用</p></li><li><p>创建新(子)BeanDefinitionParserDelegate引用并赋值给当前delegate属性；在创建新BeanDefinitionParserDelegate时设置了许多default-*属性，其中一些可以从父&lt;bean/&gt;标签(父BeanDefinitionParserDelegate)中部分继承，或为默认值</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 用于解析XML的BeanDefinition的有状态的委托类,供主解析器和任何扩展使用</span></span><br><span class="line">  BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">  delegate.initDefaults(root, parentDelegate);</span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDefaults</span><span class="params">(Element root, @Nullable BeanDefinitionParserDelegate parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 填充默认值</span></span><br><span class="line">  populateDefaults(<span class="keyword">this</span>.defaults, (parent != <span class="keyword">null</span> ? parent.defaults : <span class="keyword">null</span>), root);</span><br><span class="line">  <span class="comment">// 触发默认注册事件</span></span><br><span class="line">  <span class="keyword">this</span>.readerContext.fireDefaultsRegistered(<span class="keyword">this</span>.defaults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALSE_VALUE = <span class="string">"false"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LAZY_INIT_ATTRIBUTE = <span class="string">"default-lazy-init"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_MERGE_ATTRIBUTE = <span class="string">"default-merge"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTOWIRE_ATTRIBUTE = <span class="string">"default-autowire"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_NO_VALUE = <span class="string">"no"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = <span class="string">"default-autowire-candidates"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_INIT_METHOD_ATTRIBUTE = <span class="string">"default-init-method"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DESTROY_METHOD_ATTRIBUTE = <span class="string">"default-destroy-method"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用默认的lazy-init、autowire、依赖项检查设置、init-method、destro-method和合并设置填充给定的DocumentDefaultsDefinition实例</span></span><br><span class="line"><span class="comment"> * 如果没有在本地显式地设置默认值,则通过返回parentDefaults来支持嵌套的&lt;beans&gt;标签实例</span></span><br><span class="line"><span class="comment"> * DocumentDefaultsDefinition：是保存默认值的简单JavaBean，这些默认值指定在标准Spring XML BeanDefinition文档中&lt;beans&gt;标签级别————default-lazy-init、default-autowire等</span></span><br><span class="line"><span class="comment"> * defaults：要填充的默认值</span></span><br><span class="line"><span class="comment"> * parentDefaults：父BeanDefinitionParserDelegate(如果有)的默认值</span></span><br><span class="line"><span class="comment"> * root：当前BeanDefinition文档的根标签(或嵌套的&lt;beans&gt;标签)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateDefaults</span><span class="params">(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root)</span> </span>&#123;</span><br><span class="line">  String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    lazyInit = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getLazyInit() : FALSE_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setLazyInit(lazyInit);</span><br><span class="line">  String merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(merge)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    merge = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getMerge() : FALSE_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setMerge(merge);</span><br><span class="line">  String autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (isDefaultValue(autowire)) &#123;</span><br><span class="line">    <span class="comment">// 可能从外部&lt;beans&gt;标签部分继承,否则返回false</span></span><br><span class="line">    autowire = (parentDefaults != <span class="keyword">null</span> ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setAutowire(autowire);</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setInitMethod(parentDefaults.getInitMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">    defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentDefaults != <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  defaults.setSource(<span class="keyword">this</span>.readerContext.extractSource(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检查是否是默认空间；如果是则获取并分割profile属性，并校验当前profile是否有效(无效退出)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">"http://www.springframework.org/schema/beans"</span>;</span><br><span class="line"><span class="comment">// 确定给定的URI是否指示默认命名空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isDefaultNamespace(getNamespaceURI(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(@Nullable String namespaceUri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;beans/&gt;根标签的命名空间为空</span></span><br><span class="line">  <span class="comment">// 或namespaceUri为http://www.springframework.org/schema/beans</span></span><br><span class="line">  <span class="keyword">return</span> !StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最重要的就是执行真正的解析BeanDefinition的<code>parseBeanDefinitions()</code>方法，在该方法前后提供了两个空实现的模板方法<code>preProcessXml()</code>和<code>postProcessXml()</code>用于扩展(子类继承覆写)</p></li><li><p>设置当前delegate属性为老的BeanDefinitionParserDelegate引用</p></li></ol></blockquote></li><li><p><strong><em>parseBeanDefinitions()方法</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析文档中根级别的标签：&lt;import&gt;、&lt;alias&gt;、&lt;bean&gt;</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点使用默认命名空间</span></span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="comment">// 遍历子节点</span></span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="comment">// 如果该节点使用默认命名空间,执行默认解析</span></span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果该节点不使用默认命名空间,执行自定义解析</span></span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果根节点不使用默认命名空间,执行自定义解析</span></span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT; <span class="comment">// "bean"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NESTED_BEANS_ELEMENT = <span class="string">"beans"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALIAS_ELEMENT = <span class="string">"alias"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALIAS_ATTRIBUTE = <span class="string">"alias"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMPORT_ELEMENT = <span class="string">"import"</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">    processBeanDefinition(ele, delegate);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line">    <span class="comment">// 递归解析</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>parseBeanDefinitions()</code>方法一目了然，首先判断是否标签是否使用默认命名空间，如果否则是自定义标签————调用<code>parseCustomElement()</code>解析；否则是默认标签————根据标签的不同分别进行处理<br>接着依次分析不同标签的解析流程</p></blockquote></li><li><p><strong><em>importBeanDefinitionResource()方法(解析import标签)</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析&lt;import&gt;标签,并将BeanDefinition从给定的资源加载到BeanFactory</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取resource的属性值</span></span><br><span class="line">  String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 为空值,直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析系统配置(占位符)</span></span><br><span class="line">  location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line">  <span class="comment">// 实际Resource集合————从import的地址解析而来</span></span><br><span class="line">  Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 判断location是相对路径还是绝对路径</span></span><br><span class="line">  <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">    <span class="comment">// 无法转换为URI,考虑位置是相对的,除非是Spring前缀"classpath*:"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是绝对路径</span></span><br><span class="line">  <span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将添加的配置文件的Resource通过location解析,并把结果放入actualResources集合中</span></span><br><span class="line">      <span class="comment">// 并递归加载其中的BeanDefinitions</span></span><br><span class="line">      <span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不是URL -&gt; 考虑相对于当前文件的资源位置</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> importCount;</span><br><span class="line">      <span class="comment">// 创建相对路径的Resource</span></span><br><span class="line">      Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">      <span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">        <span class="comment">// 加载relativeResource中的BeanDefinition</span></span><br><span class="line">        importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">        <span class="comment">// 将relativeResource加入actualResources集合</span></span><br><span class="line">        actualResources.add(relativeResource);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取根路径</span></span><br><span class="line">        String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">        <span class="comment">// 根据根路径和location构造相对路径并加载BeanDefinition</span></span><br><span class="line">        importCount = getReaderContext().getReader().loadBeanDefinitions(StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 触发当前&lt;import&gt;标签处理完的事件回调</span></span><br><span class="line">  getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>importBeanDefinitionResource()</code>方法一目了然，可为以下几个步骤：</p><ol><li><p>获取source属性的值————表示资源的路径</p></li><li><p>解析资源路径的系统属性(占位符)</p></li><li><p>判断资源路径是绝对路径还是相对路径</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定的资源位置是否为URL：</span></span><br><span class="line"><span class="comment"> * 特殊的以"classpath:"或"classpath*:"开头的伪URL或标准URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// ResourcePatternUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUrl</span><span class="params">(@Nullable String resourceLocation)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (resourceLocation != <span class="keyword">null</span> &amp;&amp; (resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) || ResourceUtils.isUrl(resourceLocation)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 1.以”classpath*:”或者”classpath:”开头为绝对路径<br> 2.能够通过location构建出URL类对象为绝对路径<br> 3.根据location构造URI类对象并调用<code>isAbsolute()</code>函数返回true为绝对路径</p></li><li><p>创建相对/绝对路径对应的Resource资源，递归调用Bean解析过程进行另一次解析</p></li><li><p>通知监听器完成&lt;import&gt;标签解析</p></li></ol></blockquote></li><li><p><strong><em>processAliasRegistration()方法(解析alias标签)</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的&lt;alias&gt;标签,在注册表中注册别名。</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取name和alias属性</span></span><br><span class="line">  String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">  String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">    getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 真正注册别名</span></span><br><span class="line">      getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias + <span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发当前&lt;alias&gt;标签注册完的事件回调</span></span><br><span class="line">    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从别名到规范名的映射</span></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">  Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">  <span class="comment">// #TODO</span></span><br><span class="line">  <span class="comment">// 锁对象,用于控制并发(既然用了ConcurrentHashMap,为什么还要锁?)</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="comment">// 如果alias与name相同,那么不归alias管,相当于没有alias</span></span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' ignored since it points to same name"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取alias已注册的beanName</span></span><br><span class="line">      String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">      <span class="comment">// 已存在</span></span><br><span class="line">      <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 相同,无需重复注册</span></span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否允许覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot define alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Overriding alias '"</span> + alias + <span class="string">"' definition for registered name '"</span> + registeredName + <span class="string">"' with new target name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检验是否存在循环指向</span></span><br><span class="line">      checkForAliasCircle(name, alias);</span><br><span class="line">      <span class="comment">// 注册alias,实际就是放入hash表</span></span><br><span class="line">      <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' registered for name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否出现alias循环：A -&gt; B , B -&gt; A</span></span><br><span class="line"><span class="comment"> * 捕获一个循环引用并抛出IllegalStateExceptio异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkForAliasCircle</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasAlias(alias, name)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': Circular reference - '"</span> + name + <span class="string">"' is a direct or indirect alias for '"</span> + alias + <span class="string">"' already"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定给定name是否已注册给定alias</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">  <span class="keyword">return</span> ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != <span class="keyword">null</span> &amp;&amp; hasAlias(name, registeredName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>processAliasRegistration()</code>方法一目了然，可为以下几个步骤：</p><ol><li><p>获取name和alias属性并校验非空</p></li><li><p>委托给SimpleAliasRegistry类真正执行注册别名逻辑，构造ReaderContext时传入了XmlBeanDefinitionReader的引用，而构造XmlBeanDefinitionReader时传入了DefaultListableBeanFactory的引用；DefaultListableBeanFactory隔代继承了SimpleAliasRegistry，因此最终交由SimpleAliasRegistry真正注册别名</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="comment">// 创建XmlReaderContext引用传递给DocumentReader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 为给定的BeanFactory创建XmlBeanDefinitionReader</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册别名主要执行逻辑参见注释</p></li><li><p>通知监听器完成当前&lt;alias&gt;标签解析</p></li></ol></blockquote></li><li><p><strong><em>processBeanDefinition()方法(解析bean标签)</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的Bean标签,解析成BeanDefinition并将其注册到注册表</span></span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析bean元素,如果成功返回BeanDefinitionHolder;否则返回null</span></span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 进行自定义标签解析</span></span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册最终的包装实例</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> + bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发当前&lt;bean&gt;标签处理完(注册完当前BeanDefinition)的事件回调</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>processBeanDefinition()</code>方法一目了然，可为以下几个步骤：</p><ol><li><p>将解析&lt;bean/&gt;标签成BeanDefinitionHolder的任务委托给BeanDefinitionParserDelegate(该类囊括了许多解析功能)；BeanDefinitionHolder类是封装了name和alias的BeanDefinition</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有name和alias的BeanDefinition的持有者。可注册为内部Bean的占位符</span></span><br><span class="line"><span class="comment">// BeanDefinitionHolder.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析提供的&lt;bean&gt;标签。如果解析过程出现错误则可能返回null,并向ProblemReporter报告错误</span></span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析id和name属性</span></span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 别名集合</span></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    <span class="comment">// 切分name属性</span></span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// beanName优先使用id</span></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="comment">// 其次使用alias别名的第一个</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">"No XML 'id' specified - using '"</span> + beanName + <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查beanName的唯一性</span></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析其他属性,封装成AbstractBeanDefinition对象</span></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有beanName,使用beanName生成规则生成唯一的beanName</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// 如果生成器返回加上后缀的类名,则为Plain Bean类名注册一个别名(如果仍然可能)</span></span><br><span class="line">          <span class="comment">// 这是Spring 1.2/2.0向后兼容的预期结果</span></span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> + <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="comment">// 创建BeanDefinitionHolder对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储所有使用过的beanName,以便可以在每个&lt;beans&gt;标签基础上强制唯一性</span></span><br><span class="line"><span class="comment"> * 重复的bean id/name可能不存在于同一级别的&lt;beans&gt;嵌套标签中,但可以跨级别存在同名bean id/name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; usedNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 验证指定的beanName和alias是否尚未在当前级别的&lt;beans&gt;嵌套标签中使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查看beanName或alias是否已被使用</span></span><br><span class="line">  String foundName = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">    foundName = beanName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">    error(<span class="string">"Bean name '"</span> + foundName + <span class="string">"' is already used in this &lt;beans&gt; element"</span>, beanElement);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">  <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>parseBeanDefinitionElement()</code>方法流程也较为清晰，分为以下几个部分：<br>  1.首先解析id和name属性，并设置beanName(首先考虑beanId,其次是首个alias)<br>  2.检查name的唯一性(alias也会参与验证)<br>  3.解析其他属性，封装成AbstractBeanDefinition对象；这部分后续介绍<br>  4.如果没有beanName，使用beanName生成规则生成唯一的beanName<br>  5.返回封装beanName和alias的BeanDefinitionHolder对象</p></li><li><p>传入将生成的BeanDefinitionHolder对象调用BeanDefinitionParserDelegate类的<code>decorateBeanDefinitionIfRequired()</code>方法进行自定义标签解析</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder originalDef)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> decorateBeanDefinitionIfRequired(ele, originalDef, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果适用,通过命名空间处理器修饰给定的BeanDefinition</span></span><br><span class="line"><span class="comment"> * ele：当前&lt;bean&gt;标签</span></span><br><span class="line"><span class="comment"> * originalDef：当前BeanDefinition</span></span><br><span class="line"><span class="comment"> * containingBd：包含的BeanDefinition(如果有,应该是父&lt;bean&gt;标签,用于继承属性)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateBeanDefinitionIfRequired</span><span class="params">(Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder finalDefinition = originalDef;</span><br><span class="line">  <span class="comment">// 首先根据自定义属性进行修饰</span></span><br><span class="line">  NamedNodeMap attributes = ele.getAttributes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">    Node node = attributes.item(i);</span><br><span class="line">    finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接着根据自定义嵌套标签进行修饰</span></span><br><span class="line">  NodeList children = ele.getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    Node node = children.item(i);</span><br><span class="line">    <span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">      finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>decorateBeanDefinitionIfRequired()</code>方法主要用于解析自定义标签，主要调用了<code>decorateIfRequired()</code>方法，此方法介绍自定义标签解析时再介绍</p></li><li><p>将注册BeanDefinition的任务委托为BeanDefinitionReaderUtils类处理，该方法过于重要，在后面单独介绍</p></li><li><p>通知监听器完成当前&lt;bean/&gt;标签解析</p></li></ol></blockquote></li><li><p><strong><em>registerBeanDefinition()方法(注册BeanDefinition)</em></strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向给定的BeanFactory注册给定的BeanDefinition</span></span><br><span class="line"><span class="comment">* definitionHolder：包含name和alias的BeanDefinition</span></span><br><span class="line"><span class="comment">* registry：注册的BeanFactory</span></span><br><span class="line"><span class="comment">* 如果注册失败则抛出BeanDefinitionStoreException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// BeanDefinitionReaderUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 为beanName注册BeanDefinition</span></span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">  <span class="comment">// 为beanName注册alias(如果有的话)</span></span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="comment">// &lt;beanName, BeanDefinition&gt;映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// BeanDefinition名称列表(按注册顺序排列)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// 冻结配置时BeanDefinition名称的缓存数组</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String[] frozenBeanDefinitionNames;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此注册表中注册一个新的BeanDefinition</span></span><br><span class="line"><span class="comment"> * 必须支持RootBeanDefinition和ChildBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">  Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是AbstractBeanDefinition类型,进行校验(主要是对属性methodOverrides)</span></span><br><span class="line">      ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存中获取指定beanName的BeanDefinition</span></span><br><span class="line">  BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在同名BeanDefinition但不允许覆盖,抛BeanDefinitionOverrideException异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">      <span class="comment">// 例如是ROLE_APPLICATION,现在覆盖为ROLE_SUPPORT/ROLE_INFRASTRUCTURE</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName + <span class="string">"' with a framework-generated bean definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with a different definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName + <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖原有的BeanDefinition,实际注册(就是存入map)</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 检测创建Bean阶段是否已经开启,如果开启了则需要对beanDefinitionMap进行并发控制</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        <span class="comment">// 添加beanName到beanDefinitionNames集合中(CopyOnWrite,可能因为并发)</span></span><br><span class="line">        List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="comment">// 从manualSingletonNames中移除beanName</span></span><br><span class="line">        removeManualSingletonName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 仍处于启动注册阶段</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">      removeManualSingletonName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">    <span class="comment">// 重新设置beanName对应的缓存</span></span><br><span class="line">    resetBeanDefinition(beanName);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">    clearByTypeCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="comment">// &lt;别名, 规范名&gt;映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验非空</span></span><br><span class="line">  Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">  Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' ignored since it points to same name"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">      <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">          <span class="comment">// 别名已存在,无需二次注册</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot define alias '"</span> + alias + <span class="string">"' for name '"</span> + name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Overriding alias '"</span> + alias + <span class="string">"' definition for registered name '"</span> + registeredName + <span class="string">"' with new target name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      checkForAliasCircle(name, alias);</span><br><span class="line">      <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Alias definition '"</span> + alias + <span class="string">"' registered for name '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>registerBeanDefinition()</code>注册BeanDefinition的过程十分清楚，做了两件事：为beanName注册BeanDefinition以及为beanName注册alias，分别调用了DefaultListableBeanFactory类的<code>registerBeanDefinition()</code>方法以及SimpleAliasRegistry类的<code>registerAlias()</code>方法(DefaultListableBeanFactory继承了SimpleAliasRegistry)<br>在<code>registerBeanDefinition()</code>方法中，做了以下几件事：</p></blockquote><ol><li><p>校验beanName和beanDefinition非空</p></li><li><p>校验beanDefinition(如果是AbstractBeanDefinition类型)，这里主要是对methodOverrides属性的校验：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证当前BeanDefinition,如果验证失败抛出BeanDefinitionValidationException</span></span><br><span class="line"><span class="comment">// AbstractBeanDefinition.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="comment">// 既存在重写方法又存在工厂方法,抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (hasMethodOverrides() &amp;&amp; getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Cannot combine factory method with container-generated method overrides: "</span> + <span class="string">"the factory method must create the concrete bean instance."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果存在给定了Class类型的beanClass对象</span></span><br><span class="line">  <span class="keyword">if</span> (hasBeanClass()) &#123;</span><br><span class="line">    <span class="comment">// 准备重写方法</span></span><br><span class="line">    prepareMethodOverrides();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMethodOverrides</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="keyword">this</span>.methodOverrides.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.beanClass <span class="keyword">instanceof</span> Class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证并准备为该bean实例定义的重写方法</span></span><br><span class="line"><span class="comment"> * 检查是否存在具有指定名称的方法</span></span><br><span class="line"><span class="comment"> * 验证失败抛出BeanDefinitionValidationException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">  <span class="comment">// 查找并检查方法是否存在并确定其重载状态</span></span><br><span class="line">  <span class="keyword">if</span> (hasMethodOverrides()) &#123;</span><br><span class="line">    getMethodOverrides().getOverrides().forEach(<span class="keyword">this</span>::prepareMethodOverride);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册BeanDefinition(加入(或覆盖)&lt;beanName, BeanDefinition/&gt;映射,如果设置了不允许覆盖则抛出异常)；添加已注册的beanName；从顺序手动注册的单例集合中移除beanName</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="comment">// 按注册手动注册的单例的名称列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; manualSingletonNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeManualSingletonName</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  updateManualSingletonNames(set -&gt; set.remove(beanName), set -&gt; set.contains(beanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新工厂内部手动注册单例的名称集合</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateManualSingletonNames</span><span class="params">(Consumer&lt;Set&lt;String&gt;&gt; action, Predicate&lt;Set&lt;String&gt;&gt; condition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">        action.accept(updatedSingletons);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition.test(<span class="keyword">this</span>.manualSingletonNames)) &#123;</span><br><span class="line">      action.accept(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行清理工作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置给定bean的所有BeanDefinition缓存,包括从该bean派生的bean的缓存</span></span><br><span class="line"><span class="comment"> * 在替换或删除现有BeanDefinition后调用</span></span><br><span class="line"><span class="comment"> * 在给定bean和以给定bean为父bean的所有bean定义上触发clearMergedBeanDefinition()、destroySingleton()和resetBeanDefinition()方法</span></span><br><span class="line"><span class="comment"> * beanName：要重置的bean的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 删除给定bean的MergedBeanDefinition(合并的BeanDefinition,如果已经创建)</span></span><br><span class="line">  clearMergedBeanDefinition(beanName);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从单例缓存中删除相应的bean(如果有的话)</span></span><br><span class="line"><span class="comment">   * 通常不需要,而只是为了覆盖context的默认bean(例如StaticApplicationContext中的默认StaticMessageSource)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  destroySingleton(beanName);</span><br><span class="line">  <span class="comment">// 通知所有后置处理器指定的BeanDefinition已被重置</span></span><br><span class="line">  <span class="keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line">    processor.resetBeanDefinition(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重置将给定bean作为父bean的所有bean定义(递归)</span></span><br><span class="line">  <span class="keyword">for</span> (String bdName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!beanName.equals(bdName)) &#123;</span><br><span class="line">      BeanDefinition bd = <span class="keyword">this</span>.beanDefinitionMap.get(bdName);</span><br><span class="line">      <span class="comment">// 由于beanDefinitionMap的潜在并发修改,请确保bd不为空</span></span><br><span class="line">      <span class="keyword">if</span> (bd != <span class="keyword">null</span> &amp;&amp; beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">        resetBeanDefinition(bdName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Remove any assumptions about by-type mappings.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearByTypeCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.allBeanNamesByType.clear();</span><br><span class="line">  <span class="keyword">this</span>.singletonBeanNamesByType.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2021/01/23/SpringSeries/MyBatis/"/>
      <url>/2021/01/23/SpringSeries/MyBatis/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#MyBatis入门">MyBatis入门</a></li></ul><a id="more"></a><h2 id="MyBatis入门"><a href="#MyBatis入门" class="headerlink" title="MyBatis入门"></a>MyBatis入门</h2><ul><li>中文链接：<a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL源码分析</title>
      <link href="/2021/01/08/Middleware/MySQL/MySQL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/01/08/Middleware/MySQL/MySQL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#环境搭建">环境搭建</a></li><li><a href="#查询分析">查询分析</a></li><li><a href="#事务">事务</a></li><li><a href="#故障恢复">故障恢复</a></li></ul><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h2 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h2><ul><li><p>源码启动首先从sql/main.cc的main()方法开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mysqld_main(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>紧接着调用了sql/mysqld.cc的mysqld_main()方法，最主要调用了sql/conn_handler/connection_acceptor.h中connection_event_loop()方法的<br><code>mysqld_socket_acceptor-&gt;connection_event_loop();</code>语句进行端口监听，等待client客户端的连接</p><p>connection_event_loop()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection acceptor loop to accept connections from clients. 连接接收器循环接收来自客户端的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connection_event_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Connection_handler_manager *mgr= Connection_handler_manager::get_instance();</span><br><span class="line">  <span class="keyword">while</span> (!abort_loop)</span><br><span class="line">  &#123;</span><br><span class="line">    Channel_info *channel_info= m_listener-&gt;listen_for_connection_event();</span><br><span class="line">    <span class="keyword">if</span> (channel_info != <span class="literal">NULL</span>)</span><br><span class="line">      mgr-&gt;process_new_connection(channel_info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在监听到客户端的连接后，调用sql/conn_handler/connection_handler_manager.cc中process_new_connection()方法的<code>mgr-&gt;process_new_connection(channel_info);</code>语句添加新的客户端连接并设置信息</p><p>process_new_connection()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connection_handler_manager::process_new_connection</span><span class="params">(Channel_info* channel_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (abort_loop || !check_and_incr_conn_count())</span><br><span class="line">  &#123;</span><br><span class="line">    channel_info-&gt;send_error_and_close_channel(ER_CON_COUNT_ERROR, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">delete</span> channel_info;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (m_connection_handler-&gt;add_connection(channel_info))</span><br><span class="line">  &#123;</span><br><span class="line">    inc_aborted_connects();</span><br><span class="line">    <span class="keyword">delete</span> channel_info;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在处理新的连接方法中，主要调用了connection_handler_manager.cc中process_new_connection()方法的<code>m_connection_handler-&gt;add_connection(channel_info)</code>语句新增连接</p><p>add_connection()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Per_thread_connection_handler::add_connection</span><span class="params">(Channel_info* channel_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error= <span class="number">0</span>;</span><br><span class="line">  my_thread_handle id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    There are no idle threads avaliable to take up the new</span></span><br><span class="line"><span class="comment">    connection. Create a new thread to handle the connection</span></span><br><span class="line"><span class="comment">    没有空闲线程可以占用新连接</span></span><br><span class="line"><span class="comment">    创建一个新线程来处理连接</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  channel_info-&gt;set_prior_thr_create_utime();</span><br><span class="line">  error= mysql_thread_create(key_thread_one_connection, &amp;id, &amp;connection_attrib, handle_connection, (<span class="keyword">void</span>*) channel_info);</span><br><span class="line"></span><br><span class="line">handle_error:</span><br><span class="line">  <span class="keyword">if</span> (error)</span><br><span class="line">  &#123;</span><br><span class="line">    connection_errors_internal++;</span><br><span class="line">    <span class="keyword">if</span> (!create_thd_err_log_throttle.<span class="built_in">log</span>())</span><br><span class="line">      sql_print_error(<span class="string">"Can't create thread to handle new connection(errno= %d)"</span>, error);</span><br><span class="line">    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD, error, <span class="literal">true</span>);</span><br><span class="line">    Connection_handler_manager::dec_connection_count();</span><br><span class="line">  &#125;</span><br><span class="line">  Global_THD_manager::get_instance()-&gt;inc_thread_created();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/conn_handler/connection_handler_per_thread.cc的add_connection()方法中主要通过<code>mysql_thread_create();</code>语句创建了线程监听连接的事件。在传入的参数中包含一个函数<code>handle_connection</code>，该函数主要处理接收的事件操作</p><p>handle_connection()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Thread handler for a connection 一个连接的线程处理器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param arg   Connection object (Channel_info)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This function (normally) does the following:</span></span><br><span class="line"><span class="comment">- Initialize thread 初始化线程</span></span><br><span class="line"><span class="comment">- Initialize THD to be used with this thread 初始化THD信息</span></span><br><span class="line"><span class="comment">- Authenticate user 鉴权用户</span></span><br><span class="line"><span class="comment">- Execute all queries sent on the connection 处理所有连接发送的请求</span></span><br><span class="line"><span class="comment">- Take connection down 断开连接</span></span><br><span class="line"><span class="comment">- End thread  / Handle next connection using thread from thread cache 结束线程 / 从线程缓存中使用线程处理下一个连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> *<span class="title">handle_connection</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// init ...</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    THD *thd= init_new_thd(channel_info);</span><br><span class="line">    <span class="keyword">if</span> (thd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      connection_errors_internal++;</span><br><span class="line">      handler_manager-&gt;inc_aborted_connects();</span><br><span class="line">      Connection_handler_manager::dec_connection_count();</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// We are out of resources, no sense in continuing.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_reused) <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">if</span> (thd_prepare_connection(thd)) handler_manager-&gt;inc_aborted_connects();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (thd_connection_alive(thd))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_command(thd)) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      end_connection(thd);</span><br><span class="line">    &#125;</span><br><span class="line">    close_connection(thd, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  my_thread_end();</span><br><span class="line">  my_thread_exit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/conn_handler/connection_handler_per_thread.cc的handle_connection()方法中通过无限的for循环接收连接发送的事件，最主要通过<code>do_command()</code>方法进行事件的回调处理</p><p>do_command()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Read one command from connection and execute it (query or simple command).</span></span><br><span class="line"><span class="comment">从连接中读取一条命令并执行</span></span><br><span class="line"><span class="comment">This function is called in loop from thread function. </span></span><br><span class="line"><span class="comment">这个方法被线程方法循环调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For profiling to work, it must never be called recursively.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval 0  success 成功</span></span><br><span class="line"><span class="comment">@retval 1  request of thread shutdown (see dispatch_command() description) 线程关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_command</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> return_value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  return_value= dispatch_command(thd, &amp;com_data, command);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_parse.cc中的do_command()方法读取客户端传递的命令并进行分发，最主要调用了<code>dispatch_command()</code>方法进行命令的分发调用</p><p>dispatch_command()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Perform one connection-level (COM_XXXX) command. </span></span><br><span class="line"><span class="comment">执行一条连接级别的命令(以COM_为前缀)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd             connection handle 连接句柄</span></span><br><span class="line"><span class="comment">@param command         type of command to perform 执行的命令类型</span></span><br><span class="line"><span class="comment">@com_data              com_data union to store the generated command 保存的命令信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval 0   ok 成功</span></span><br><span class="line"><span class="comment">@retval 1   request of thread shutdown, i. e. if command is </span></span><br><span class="line"><span class="comment">            COM_QUIT/COM_SHUTDOWN 线程关闭,比如命令是quit或shutdown</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dispatch_command</span><span class="params">(THD *thd, <span class="keyword">const</span> COM_DATA *com_data, <span class="keyword">enum</span> enum_server_command command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">    <span class="keyword">case</span> COM_INIT_DB:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_EXECUTE:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_FETCH:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_SEND_LONG_DATA:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_PREPARE:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_CLOSE:</span><br><span class="line">    <span class="keyword">case</span> COM_STMT_RESET:</span><br><span class="line">    <span class="keyword">case</span> COM_QUERY:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 从网络数据包中读取Query并存入thd-&gt;query</span></span><br><span class="line">      <span class="comment">// 如果发生致命错误,返回true</span></span><br><span class="line">      <span class="keyword">if</span> (alloc_query(thd, com_data-&gt;com_query.query, com_data-&gt;com_query.length)) <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 记录原始SQL</span></span><br><span class="line">      <span class="keyword">if</span> (opt_general_log_raw) query_logger.general_log_write(thd, command, thd-&gt;query().str, thd-&gt;query().length);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 解析SQL语句</span></span><br><span class="line">      mysql_parse(thd, &amp;parser_state);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 从网络返回结果</span></span><br><span class="line">  thd-&gt;send_statement_status();</span><br><span class="line">  thd-&gt;rpl_thd_ctx.session_gtids_ctx().notify_after_response_packet(thd);</span><br><span class="line">  query_cache.end_of_result(thd);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_parse.cc中的dispatch_command()方法根据具体的方法类型分别进行处理，在查询操作中首先调用alloc_query()方法从packet数据包中读取query信息并封装到线程数据结构中；接着最主要调用了mysql_parse()方法进行sql语句的解析和执行；在解析完毕后，调用<code>thd-&gt;send_statement_status();</code>语句从网络返回结果，查询调用完成</p><p>mysql_parse()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a query 解析一个查询语句</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_parse</span><span class="params">(THD *thd, Parser_state *parser_state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mysql_reset_thd_for_next_command(thd);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 如果不存在查询缓存</span></span><br><span class="line">  <span class="keyword">if</span> (query_cache.send_result_to_client(thd, thd-&gt;query()) &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">bool</span> err= thd-&gt;get_stmt_da()-&gt;is_error();</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// SQL语句词法语法解析</span></span><br><span class="line">      err= parse_sql(thd, parser_state, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (!thd-&gt;is_error())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(thd-&gt;security_context()-&gt;password_expired() &amp;&amp;!lex-&gt;is_set_password_sql &amp;&amp; lex-&gt;sql_command != SQLCOM_SET_OPTION &amp;&amp; lex-&gt;sql_command != SQLCOM_ALTER_USER))</span><br><span class="line">        &#123;</span><br><span class="line">          my_error(ER_MUST_CHANGE_PASSWORD, MYF(<span class="number">0</span>));</span><br><span class="line">          error= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询语句具体执行</span></span><br><span class="line">        <span class="keyword">else</span> error= mysql_execute_command(thd, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_parse.cc中的mysql_parse()方法通过<code>query_cache.send_result_to_client(thd, thd-&gt;query()) &lt;= 0</code>语句首先判断当前查询是否已经有缓存结果，如果没有，则首先调用parse_sql()方法进行词法语法的解析工作，随后通过mysql_execute_command()方法进行sql语句的执行</p><p>parse_sql()方法的主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">This is a wrapper of MYSQLparse(). All the code should call parse_sql()</span></span><br><span class="line"><span class="comment">instead of MYSQLparse(). </span></span><br><span class="line"><span class="comment">这是MYSQLparse()方法的包装器,所有的代码应该调用parse_sql()方法而不是MYSQLparse()方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">As a by product of parsing, the parser can also generate a query digest. </span></span><br><span class="line"><span class="comment">作为解析的副产品,解析器还可以生成查询摘要.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd Thread context. 线程上下文</span></span><br><span class="line"><span class="comment">@param parser_state Parser state. 解析器状态</span></span><br><span class="line"><span class="comment">@param creation_ctx Object creation context. 对象创建上下文</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@return Error status.</span></span><br><span class="line"><span class="comment">@retval FALSE on success.</span></span><br><span class="line"><span class="comment">@retval TRUE on parsing error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_sql</span><span class="params">(THD *thd, Parser_state *parser_state, Object_creation_ctx *creation_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 调用bison进行词法分析</span></span><br><span class="line">  <span class="keyword">bool</span> mysql_parse_status= MYSQLparse(thd) != <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from sql_yacc.cc</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">MYSQLparse</span><span class="params">(class THD *thd)</span></span>;</span><br></pre></td></tr></table></figure><p>mysql_execute_command()方法的主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Execute command saved in thd and lex-&gt;sql_command. </span></span><br><span class="line"><span class="comment">执行存储在线程句柄和lex中的sql语句</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd Thread handle 线程句柄</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval FALSE OK</span></span><br><span class="line"><span class="comment">@retval TRUE Error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_execute_command</span><span class="params">(THD *thd, <span class="keyword">bool</span> first_level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取解析后的sql语法树</span></span><br><span class="line">  LEX *<span class="keyword">const</span> lex= thd-&gt;lex;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 根据解析后的sql语法树的类型,决定下一步具体执行</span></span><br><span class="line">  <span class="keyword">switch</span> (lex-&gt;sql_command) &#123;</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_STATUS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_DATABASES:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_TABLES:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_TRIGGERS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_TABLE_STATUS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_PLUGINS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_FIELDS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_KEYS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_VARIABLES:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_CHARSETS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_COLLATIONS:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_STORAGE_ENGINES:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SHOW_PROFILE:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_SELECT:</span><br><span class="line">    &#123;</span><br><span class="line">      DBUG_EXECUTE_IF(<span class="string">"use_attachable_trx"</span>, thd-&gt;begin_attachable_ro_transaction(););</span><br><span class="line">      thd-&gt;clear_current_query_costs();</span><br><span class="line">      res= select_precheck(thd, lex, all_tables, first_table);</span><br><span class="line">      <span class="comment">// 具体执行select</span></span><br><span class="line">      <span class="keyword">if</span> (!res) res= execute_sqlcom_select(thd, all_tables);</span><br><span class="line">      <span class="comment">// 保存当前查询花费</span></span><br><span class="line">      thd-&gt;save_current_query_costs();</span><br><span class="line">      DBUG_EXECUTE_IF(<span class="string">"use_attachable_trx"</span>, thd-&gt;end_attachable_transaction(););</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_PREPARE:</span><br><span class="line">    &#123;</span><br><span class="line">      mysql_sql_stmt_prepare(thd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_EXECUTE:</span><br><span class="line">    &#123;</span><br><span class="line">      mysql_sql_stmt_execute(thd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_CREATE_TABLE:</span><br><span class="line">    <span class="keyword">case</span> SQLCOM_UNLOCK_TABLES:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_parse.cc中的parse_sql()方法最主要调用了MYSQLparse()方法(具体实现复杂)调用bison(类似yacc)进行词法分析。简单地说，主要通过调用<code>yychar = yylex(&amp;yylval, &amp;yylloc, YYTHD)</code>获取到SQL语句中的一个个token，然后根据事先的规则进行处理<br>在sql/sql_parse.cc中的mysql_execute_command()方法中首先通过<code>LEX *const lex= thd-&gt;lex;</code>语句得到解析后的sql语法树，再根据sql语法树的类型决定下一步操作。在当前为SELECT操作，具体首先通过select_precheck()方法进行查询前的检查，如果通过检查，那么最主要调用<code>res= execute_sqlcom_select(thd, all_tables);</code>语句具体执行SELECT操作</p><p>execute_sqlcom_select()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">execute_sqlcom_select</span><span class="params">(THD *thd, TABLE_LIST *all_tables)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取解析后的sql语法树</span></span><br><span class="line">  LEX *lex= thd-&gt;lex;</span><br><span class="line">  <span class="comment">// 打开查询或statement所需all_tables中的所有表</span></span><br><span class="line">  <span class="keyword">if</span> (!(res= open_tables_for_query(thd, all_tables, <span class="number">0</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">    MYSQL_SELECT_START(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(thd-&gt;query().str));</span><br><span class="line">    <span class="comment">// 判断是否是EXPLAIN语句</span></span><br><span class="line">    <span class="keyword">if</span> (lex-&gt;is_explain())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        We always use Query_result_send for EXPLAIN, even if it's an EXPLAIN</span></span><br><span class="line"><span class="comment">        for SELECT ... INTO OUTFILE: a user application should be able</span></span><br><span class="line"><span class="comment">        to prepend EXPLAIN to any query and receive output for it,</span></span><br><span class="line"><span class="comment">        even if the query itself redirects the output.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      Query_result *<span class="keyword">const</span> result= <span class="keyword">new</span> Query_result_send;</span><br><span class="line">      <span class="keyword">if</span> (!result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* purecov: inspected */</span></span><br><span class="line">      res= handle_query(thd, lex, result, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Query_result *result= lex-&gt;result;</span><br><span class="line">      <span class="keyword">if</span> (!result &amp;&amp; !(result= <span class="keyword">new</span> Query_result_send()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* purecov: inspected */</span></span><br><span class="line">      Query_result *save_result= result;</span><br><span class="line">      Query_result *analyse_result= <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (lex-&gt;proc_analyse)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ((result = analyse_result= <span class="keyword">new</span> Query_result_analyse(result, lex-&gt;proc_analyse)) == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 具体处理sql语句</span></span><br><span class="line">      res= handle_query(thd, lex, result, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">delete</span> analyse_result;</span><br><span class="line">      <span class="keyword">if</span> (save_result != lex-&gt;result) <span class="keyword">delete</span> save_result;</span><br><span class="line">    &#125;</span><br><span class="line">    MYSQL_SELECT_DONE((<span class="keyword">int</span>) res, (ulong) thd-&gt;current_found_rows);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_parse.cc中的execute_sqlcom_select()方法中首先调用<code>LEX *lex= thd-&gt;lex;</code>获取解析后的sql语法树；接着调用<code>res= open_tables_for_query(thd, all_tables, 0)</code>语句打开查询或者statement所需的表(包括锁的判断、获取等准备操作)；最后主要调用handle_query()方法进行最终sql语句的处理</p><p>handle_query()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Handle a data manipulation query, from preparation through cleanup </span></span><br><span class="line"><span class="comment">从准备到清理处理数据操作查询</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd       thread handler 线程句柄</span></span><br><span class="line"><span class="comment">@param lex       query to be processed 解析后的sql语法树</span></span><br><span class="line"><span class="comment">@param result    sink of result of query execution.</span></span><br><span class="line"><span class="comment">                 may be protocol object (for passing result to a client),</span></span><br><span class="line"><span class="comment">                 insert object, update object, delete object, etc.</span></span><br><span class="line"><span class="comment">                 查询执行结果的接收器</span></span><br><span class="line"><span class="comment">                 可能是协议对象(用于将结果传递给客户端),也可能是插入对象、更新对象、删除对象等</span></span><br><span class="line"><span class="comment">@param added_options additional options for detailed control over execution 执行详细控制的附加选项</span></span><br><span class="line"><span class="comment">@param removed_options options that are not applicable for this command 不适用于此命令的选项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@returns false if success, true if error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@details</span></span><br><span class="line"><span class="comment">  Processing a query goes through 5 phases (parsing is already done) 处理一个查询需要经历5个阶段(解析已经完成)</span></span><br><span class="line"><span class="comment">   - Preparation 准备</span></span><br><span class="line"><span class="comment">   - Locking of tables 表的锁定</span></span><br><span class="line"><span class="comment">   - Optimization 优化</span></span><br><span class="line"><span class="comment">   - Execution or explain 执行或解释</span></span><br><span class="line"><span class="comment">   - Cleanup 清理</span></span><br><span class="line"><span class="comment">  The queries handled by this function are: 此函数处理的查询有</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  SELECT</span></span><br><span class="line"><span class="comment">  INSERT ... SELECT</span></span><br><span class="line"><span class="comment">  REPLACE ... SELECT</span></span><br><span class="line"><span class="comment">  UPDATE (multi-table)</span></span><br><span class="line"><span class="comment">  DELETE (multi-table)</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  The function processes simple query expressions without UNION and</span></span><br><span class="line"><span class="comment">  without multi-level ORDER BY/LIMIT separately. </span></span><br><span class="line"><span class="comment">  这个函数处理简单的表达式查询,而不使用并集或分别进行多级排序</span></span><br><span class="line"><span class="comment">  Such queries are executed with a more direct code path. </span></span><br><span class="line"><span class="comment">  这样的查询使用更直接的代码路径执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_query</span><span class="params">(THD *thd, LEX *lex, Query_result *result, ulonglong added_options, ulonglong removed_options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  SELECT_LEX_UNIT *<span class="keyword">const</span> unit= lex-&gt;unit;</span><br><span class="line">  SELECT_LEX *<span class="keyword">const</span> select= unit-&gt;first_select();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> single_query= unit-&gt;is_simple();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 步骤1: Preparation</span></span><br><span class="line">  <span class="keyword">if</span> (single_query)</span><br><span class="line">  &#123;</span><br><span class="line">    unit-&gt;set_limit(unit-&gt;global_parameters());</span><br><span class="line">    select-&gt;context.resolve_in_select_list= <span class="literal">true</span>;</span><br><span class="line">    select-&gt;set_query_result(result);</span><br><span class="line">    select-&gt;make_active_options(added_options, removed_options);</span><br><span class="line">    select-&gt;fields_list= select-&gt;item_list;</span><br><span class="line">    <span class="keyword">if</span> (select-&gt;<span class="built_in">prepare</span>(thd)) <span class="keyword">goto</span> err;</span><br><span class="line">    unit-&gt;set_prepared();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit-&gt;<span class="built_in">prepare</span>(thd, result, SELECT_NO_UNLOCK | added_options, removed_options)) <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Locking of tables is done after preparation but before optimization.</span></span><br><span class="line"><span class="comment">  This allows to do better partition pruning and avoid locking unused</span></span><br><span class="line"><span class="comment">  partitions. As a consequence, in such a case, prepare stage can rely only</span></span><br><span class="line"><span class="comment">  on metadata about tables used and not data from them.</span></span><br><span class="line"><span class="comment">  表的锁定在准备之后但在优化之前完成</span></span><br><span class="line"><span class="comment">  这允许更好地进行分区修剪并避免锁定未使用的分区。因此,在这种情况下,准备阶段只能依靠关于所用表的元数据,而不是来自表的数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 步骤2:Locking of tables</span></span><br><span class="line">  <span class="keyword">if</span> (lock_tables(thd, lex-&gt;query_tables, lex-&gt;table_count, <span class="number">0</span>)) <span class="keyword">goto</span> err;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Register query result in cache.</span></span><br><span class="line"><span class="comment">  Tables must be locked before storing the query in the query cache.</span></span><br><span class="line"><span class="comment">  Transactional engines must be signalled that the statement has started,</span></span><br><span class="line"><span class="comment">  by calling external_lock().</span></span><br><span class="line"><span class="comment">  在缓存中注册查询结果</span></span><br><span class="line"><span class="comment">  必须先锁定表,然后才能将查询存储在查询缓存中</span></span><br><span class="line"><span class="comment">  必须通知事务引擎statement已启动,通过调用external_lock()方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  query_cache.store_query(thd, lex-&gt;query_tables);</span><br><span class="line">  <span class="comment">// 步骤3: Optimization</span></span><br><span class="line">  <span class="keyword">if</span> (single_query)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (select-&gt;optimize(thd)) <span class="keyword">goto</span> err;</span><br><span class="line">    unit-&gt;set_optimized();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (unit-&gt;optimize(thd)) <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 步骤4: Execution or explain</span></span><br><span class="line">  <span class="keyword">if</span> (lex-&gt;is_explain())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (explain_query(thd, unit)) <span class="keyword">goto</span> err;     <span class="comment">/* purecov: inspected */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (single_query)</span><br><span class="line">    &#123;</span><br><span class="line">      select-&gt;join-&gt;exec();</span><br><span class="line">      unit-&gt;set_executed();</span><br><span class="line">      <span class="keyword">if</span> (thd-&gt;is_error()) <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (unit-&gt;execute(thd)) <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 步骤5: Cleanup</span></span><br><span class="line">  res= unit-&gt;cleanup(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/sql_select.cc中的handle_query()方法依次经过五个步骤：Preparation、Locking of tables、Optimization、Execution or explain和Cleanup</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>事务部分知识：</p><ul><li><p>MySQL采用XA-2PC(two phrase commit————两阶段提交)进行事务的提交</p><blockquote><p>第一阶段(prepare)：TM(事务管理器————Transaction Manager)向RM(资源管理器————Resource Manager)发出prepare指令，RM进行操作，然后返回成功与否的信息给TM<br>第二阶段(commit or rollback)：如果TM收到所有RM的成功消息，则TM向RM发出提交指令；否则发出回滚指令</p></blockquote></li><li><p>MySQL通过两阶段提交很好地解决了binlog和redo log的一致性问题</p><blockquote><p>第一阶段：InnoDB prepare，持有prepare_commit_mutex，并且write/sync redo log；将回滚段设置为Prepared状态，binlog不作任何操作<br>第二阶段：包含两步</p><ol><li>write/sync binlog；</li><li>InnoDB commit(写入commit标记后释放prepare_commit_mutex)</li></ol></blockquote></li><li><p>以binlog的写入与否作为事务提交成功与否的标志：innodb commit标志并不是事务成功与否的标志，因为事务崩溃恢复过程如下：</p><ol><li>崩溃恢复时，扫描最后一个binlog文件，提取其中的xid</li><li>InnoDB维持了状态为prepare的事务链表，将这些事务的xid和binlog中记录的xid做比较，如果在binlog中存在，则提交，否则回滚事务</li></ol><p>通过这种方式，InnoDB和binlog中的事务状态保持一致</p></li><li><p>MySQL5.7中binlog的组提交：</p><blockquote><p>从XA(XA协议,采用两阶段提交方式管理分布式事务)恢复的逻辑可得————只要保证InnoDB prepare的redo日志在写binlog前完成write/sync即可，具体步骤如下：</p><ol><li>InnoDB Prepare，记录当前的LSN(日志序列号————log sequence number)到thd中</li><li>进入Group Commit的flush stage</li><li>Leader搜集队列，同时算出队列中最大的LSN</li><li>将InnoDB的redo log write/fsync到指定的LSN</li><li>写binlog并进行随后的工作(sync binlog, InnoDB commit, etc)</li></ol><p>将redo log的write/sync延迟到了binlog group commit的flush stage之后，sync binlog之前。通过延迟写redo log的方式，显式地为redo log做了一次组写入(redo log group write)，并减少了(redo log)log_sys-&gt;mutex的竞争</p></blockquote></li></ul></li><li><p>以commit命令为例分析事务执行流程，与查询命令一致，最终走到sql/sql_parse.cc中的mysql_execute_command()方法</p><p>mysql_execute_command()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_execute_command</span><span class="params">(THD *thd, <span class="keyword">bool</span> first_level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (lex-&gt;sql_command) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> SQLCOM_COMMIT:</span><br><span class="line">    &#123;</span><br><span class="line">      DBUG_ASSERT(thd-&gt;lock == <span class="literal">NULL</span> || thd-&gt;locked_tables_mode == LTM_LOCK_TABLES);</span><br><span class="line">      <span class="keyword">bool</span> tx_chain= (lex-&gt;tx_chain == TVL_YES || (thd-&gt;variables.completion_type == <span class="number">1</span> &amp;&amp; lex-&gt;tx_chain != TVL_NO));</span><br><span class="line">      <span class="keyword">bool</span> tx_release= (lex-&gt;tx_release == TVL_YES || (thd-&gt;variables.completion_type == <span class="number">2</span> &amp;&amp; lex-&gt;tx_release != TVL_NO));</span><br><span class="line">      <span class="keyword">if</span> (trans_commit(thd)) <span class="keyword">goto</span> error;</span><br><span class="line">      thd-&gt;mdl_context.release_transactional_locks();</span><br><span class="line">      <span class="comment">/* Begin transaction with the same isolation level. */</span></span><br><span class="line">      <span class="keyword">if</span> (tx_chain)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (trans_begin(thd)) <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Reset the isolation level and access mode if no chaining transaction.*/</span></span><br><span class="line">        trans_reset_one_shot_chistics(thd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Disconnect the current client connection. */</span></span><br><span class="line">      <span class="keyword">if</span> (tx_release) thd-&gt;killed= THD::KILL_CONNECTION;</span><br><span class="line">      my_ok(thd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!thd-&gt;in_sub_stmt &amp;&amp; thd-&gt;transaction_rollback_request)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We are not in sub-statement and transaction rollback was requested by</span></span><br><span class="line"><span class="comment">      one of storage engines (e.g. due to deadlock). Rollback transaction in</span></span><br><span class="line"><span class="comment">      all storage engines including binary log.</span></span><br><span class="line"><span class="comment">      不在子statement中并且事务回滚是由某个存储引擎请求的(例如: 由于死锁)</span></span><br><span class="line"><span class="comment">      回滚所有存储引擎中的事务,包括binlog</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    trans_rollback_implicit(thd);</span><br><span class="line">    thd-&gt;mdl_context.release_transactional_locks();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (stmt_causes_implicit_commit(thd, CF_IMPLICIT_COMMIT_END))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      No transaction control allowed in sub-statements.</span></span><br><span class="line"><span class="comment">      子statement不允许事务控制</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    DBUG_ASSERT(!thd-&gt;in_sub_stmt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If commit fails, we should be able to reset the OK status.</span></span><br><span class="line"><span class="comment">      如果提交失败,应该设置OK状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    thd-&gt;get_stmt_da()-&gt;set_overwrite_status(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Commit the normal transaction if one is active.</span></span><br><span class="line"><span class="comment">      如果处于活动状态,提交正常事务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    trans_commit_implicit(thd);</span><br><span class="line">    thd-&gt;get_stmt_da()-&gt;set_overwrite_status(<span class="literal">false</span>);</span><br><span class="line">    thd-&gt;mdl_context.release_transactional_locks();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在mysql_execute_command()方法中关于commit命令的case语句标识为SQLCOM_COMMIT，在其中最主要调用了trans_commit()方法<br>同时，在switch-case匹配代码块后，可能会触发事务的隐式提交<code>trans_commit_implicit();</code>或回滚<code>trans_rollback_implicit</code>操作，其中前者最终触发<code>tc_log-&gt;commit();</code>语句；后者最终触发<code>ha_rollback_trans;</code>语句，具体参照后面内容</p><p>trans_commit()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Commit the current transaction, making its changes permanent.</span></span><br><span class="line"><span class="comment">提交当前事务,使其更改永久化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd     Current thread 当前线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval FALSE  Success</span></span><br><span class="line"><span class="comment">@retval TRUE   Failure</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trans_commit</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (trans_check_state(thd)) DBUG_RETURN(TRUE);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res= ha_commit_trans(thd, TRUE);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/transaction.cc中的trans_commit()方法进行事务的提交操作，其中最主要调用了ha_commit_trans()方法</p><p>ha_commit_trans()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">@param[in] ignore_global_read_lock   Allow commit to complete even if a</span></span><br><span class="line"><span class="comment">                                     global read lock is active. This can be</span></span><br><span class="line"><span class="comment">                                     used to allow changes to internal tables</span></span><br><span class="line"><span class="comment">                                     (e.g. slave status tables).</span></span><br><span class="line"><span class="comment">                                     允许提交完成,即是全局读锁定处于活动状态</span></span><br><span class="line"><span class="comment">                                     这可能用于允许更改内部表(例如从库状态表)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval 0   ok</span></span><br><span class="line"><span class="comment">@retval 1   transaction was rolled back 事务回滚</span></span><br><span class="line"><span class="comment">@retval 2   error during commit, data may be inconsistent 提交时出错,数据可能不一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ha_commit_trans</span><span class="params">(THD *thd, <span class="keyword">bool</span> all, <span class="keyword">bool</span> ignore_global_read_lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (ha_info)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (rw_trans &amp;&amp; !ignore_global_read_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Acquire a metadata lock which will ensure that COMMIT is blocked</span></span><br><span class="line"><span class="comment">        by an active FLUSH TABLES WITH READ LOCK (and vice versa:</span></span><br><span class="line"><span class="comment">        COMMIT in progress blocks FTWRL).</span></span><br><span class="line"><span class="comment">        获取一个元数据锁,这将保证提交被一个FTWRL(MySQL全局锁————整个库处于只读状态)阻止(反之亦然: 正在提交阻塞了FTWRL)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        We allow the owner of FTWRL to COMMIT; we assume that it knows</span></span><br><span class="line"><span class="comment">        what it does.</span></span><br><span class="line"><span class="comment">        允许FTWRL的所有者提交; 并假设他知道它的作用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (thd-&gt;mdl_context.acquire_lock(&amp;mdl_request, thd-&gt;variables.lock_wait_timeout))</span><br><span class="line">      &#123;</span><br><span class="line">        ha_rollback_trans(thd, all);</span><br><span class="line">        DBUG_RETURN(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rw_trans &amp;&amp; (stmt_has_updated_trans_table(ha_info) || trans_has_noop_dml(ha_info)) &amp;&amp; check_readonly(thd, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      ha_rollback_trans(thd, all);</span><br><span class="line">      error= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!trn_ctx-&gt;no_2pc(trx_scope) &amp;&amp; (trn_ctx-&gt;rw_ha_count(trx_scope) &gt; <span class="number">1</span>)) error= tc_log-&gt;<span class="built_in">prepare</span>(thd, all);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error || (error= tc_log-&gt;commit(thd, all)))</span><br><span class="line">  &#123;</span><br><span class="line">    ha_rollback_trans(thd, all);</span><br><span class="line">    error= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/handler.cc中的ha_commit_trans()方法具体进行事务操作，首先经过一系列判断，如果条件不满足则调用ha_rollback_trans()方法进行回滚，否则先调用<code>tc_log-&gt;prepare(thd, all);</code>进行prepare操作；接着调用<code>tc_log-&gt;commit(thd, all);</code>进行commit操作；如果其中有错误，则调用a_rollback_trans()方法进行回滚</p><blockquote><p>tc_log对象为MYSQL_BIN_LOG</p></blockquote><p>tc_log-&gt;prepare()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Prepare the transaction in the transaction coordinator.</span></span><br><span class="line"><span class="comment">在事务处理协调器中准备事务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This function will prepare the transaction in the storage engines</span></span><br><span class="line"><span class="comment">(by calling @c ha_prepare_low) what will write a prepare record</span></span><br><span class="line"><span class="comment">to the log buffers.</span></span><br><span class="line"><span class="comment">此方法将在存储引擎中准备事务(通过调用ha_prepare_low()方法),这将写入准备记录到日志缓存区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval 0    success</span></span><br><span class="line"><span class="comment">@retval 1    error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::prepare</span><span class="params">(THD *thd, <span class="keyword">bool</span> all)</span></span></span><br></pre></td></tr></table></figure><p>tc_log-&gt;commit()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Commit the transaction in the transaction coordinator.</span></span><br><span class="line"><span class="comment">在事务协调器中提交事务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This function will commit the sessions transaction in the binary log</span></span><br><span class="line"><span class="comment">and in the storage engines (by calling @c ha_commit_low). If the</span></span><br><span class="line"><span class="comment">transaction was successfully logged (or not successfully unlogged)</span></span><br><span class="line"><span class="comment">but the commit in the engines did not succed, there is a risk of</span></span><br><span class="line"><span class="comment">inconsistency between the engines and the binary log.</span></span><br><span class="line"><span class="comment">此方法将在binlog和存储引擎(通过调用ha_commit_low()方法)中提交会话事务</span></span><br><span class="line"><span class="comment">如果事务已成功记录(或未成功取消记录),但在引擎中的提交没有成功,这会存在一个binlog和存储引擎不一致的风险</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For binary log group commit, the commit is separated into three</span></span><br><span class="line"><span class="comment">parts:</span></span><br><span class="line"><span class="comment">对于binlog组提交,提交分为三个部分:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. First part consists of filling the necessary caches and</span></span><br><span class="line"><span class="comment">   finalizing them (if they need to be finalized). After this,</span></span><br><span class="line"><span class="comment">   nothing is added to any of the caches.</span></span><br><span class="line"><span class="comment">   第一部分包括填充必要的缓存和并清除他们(如果需要清除)</span></span><br><span class="line"><span class="comment">   此后,不会向任何缓存添加任何内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. Second part execute an ordered flush and commit. This will be</span></span><br><span class="line"><span class="comment">   done using the group commit functionality in ordered_commit.</span></span><br><span class="line"><span class="comment">   第二部分执行有序的flush和commit</span></span><br><span class="line"><span class="comment">   这将使用有序提交中的组提交功能完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Third part checks any errors resulting from the ordered commit</span></span><br><span class="line"><span class="comment">   and handles them appropriately.</span></span><br><span class="line"><span class="comment">   第三部分检查由有序提交导致的任何错误并妥善处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval RESULT_SUCCESS   success</span></span><br><span class="line"><span class="comment">@retval RESULT_ABORTED   error, transaction was neither logged nor committed</span></span><br><span class="line"><span class="comment">        中止              错误,事务不会被记录或提交</span></span><br><span class="line"><span class="comment">@retval RESULT_INCONSISTENT  error, transaction was logged but not committed</span></span><br><span class="line"><span class="comment">        不一致                错误,事务会被记录但不会被提交</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TC_LOG::enum_result <span class="title">MYSQL_BIN_LOG::commit</span><span class="params">(THD *thd, <span class="keyword">bool</span> all)</span></span></span><br></pre></td></tr></table></figure><p>ha_rollback_trans()方法具体逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ha_rollback_trans</span><span class="params">(THD *thd, <span class="keyword">bool</span> all)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (tc_log) error= tc_log-&gt;rollback(thd, all);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Write a rollback record of the transaction to the binary log.</span></span><br><span class="line"><span class="comment">将事务的回滚记录写入binlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For binary log group commit, the rollback is separated into three</span></span><br><span class="line"><span class="comment">parts:</span></span><br><span class="line"><span class="comment">对于binlog组提交,回滚分为三个部分:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. First part consists of filling the necessary caches and</span></span><br><span class="line"><span class="comment">   finalizing them (if they need to be finalized). After a cache is</span></span><br><span class="line"><span class="comment">   finalized, nothing can be added to the cache.</span></span><br><span class="line"><span class="comment">   第一部分包括填充必要的缓存和并清除他们(如果需要清除)</span></span><br><span class="line"><span class="comment">   在缓存被清除后,不能向缓存中添加任何内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. Second part execute an ordered flush and commit. This will be</span></span><br><span class="line"><span class="comment">   done using the group commit functionality in @c ordered_commit.</span></span><br><span class="line"><span class="comment">   第二部分执行有序的flush和commit,这将使用组提交完成(在ordered_commit()方法中)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Since we roll back the transaction early, we call @c</span></span><br><span class="line"><span class="comment">   ordered_commit with the @c skip_commit flag set. The @c</span></span><br><span class="line"><span class="comment">   ha_commit_low call inside @c ordered_commit will then not be</span></span><br><span class="line"><span class="comment">   called.</span></span><br><span class="line"><span class="comment">   因为提前回滚事务,所以需要调用ordered_commit()方法并设置skip_commit标识</span></span><br><span class="line"><span class="comment">   ha_commit_low()方法内部的ordered_commit()方法将不会被调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. Third part checks any errors resulting from the flush and handles</span></span><br><span class="line"><span class="comment">   them appropriately.</span></span><br><span class="line"><span class="comment">   第三部分检查检查由flush导致的任何错误,并对其进行适当的处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@see MYSQL_BIN_LOG::ordered_commit</span></span><br><span class="line"><span class="comment">@see ha_commit_low</span></span><br><span class="line"><span class="comment">@see ha_rollback_low</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param thd Session to commit 要提交的会话</span></span><br><span class="line"><span class="comment">@param all This is @c true if this is a real transaction rollback, and</span></span><br><span class="line"><span class="comment">           @false otherwise.</span></span><br><span class="line"><span class="comment">           true：一个真正的事务回滚</span></span><br><span class="line"><span class="comment">           false：其他情况</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@return Error code, or zero if there were no error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::rollback</span><span class="params">(THD *thd, <span class="keyword">bool</span> all)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul><li><p>故障恢复部分知识</p><ul><li><p>crash recovery过程中，binlog需保证：</p><ol><li>所有已提交事务的binlog已存在</li><li>所有未提交事务的binlog不存在</li></ol></li><li><p>MySQL使用两阶段提交解决binlog和InnoDB redo log的一致性问题：将普通事务当做内部XA事务处理，为每个事务分配一个XID，binlog作为事务的协调者</p><ol><li>阶段1：InnoDB redo log写盘，InnoDB事务进入prepare状态</li><li>阶段2：binlog写盘，InooDB事务进入commit状态</li></ol><p>每个事务binlog的末尾，会记录一个XID event，标志着事务是否提交成功。也就是说recovery过程中，binlog最后一个XID event之后的内容都应该被purge(清除)。InnoDB日志可能也需要回滚或者提交</p></li></ul></li><li><p>sql/mysqld.cc中的mysqld_main()方法启动mysqld服务端，在其中进行恢复工作</p><p>mysqld_main()方法的主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysqld_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (init_server_components()) unireg_abort(MYSQLD_ABORT_EXIT);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在mysqld_main()方法中，启动恢复工作的方法为<code>init_server_components()</code>，目的为初始化服务端组件</p><p>init_server_components()方法的主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_server_components</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (opt_bin_log)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Skip opening the index file if we start with --help. This is necessary</span></span><br><span class="line"><span class="comment">      to avoid creating the file in an otherwise empty datadir, which will</span></span><br><span class="line"><span class="comment">      cause a succeeding 'mysqld --initialize' to fail.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!opt_help &amp;&amp; mysql_bin_log.open_index_file(opt_binlog_index_name, ln, TRUE)) unireg_abort(MYSQLD_ABORT_EXIT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (total_ha_2pc &gt; <span class="number">1</span> || (<span class="number">1</span> == total_ha_2pc &amp;&amp; opt_bin_log))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (opt_bin_log) tc_log= &amp;mysql_bin_log;</span><br><span class="line">    <span class="keyword">else</span> tc_log= &amp;tc_log_mmap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tc_log-&gt;<span class="built_in">open</span>(opt_bin_log ? opt_bin_logname : opt_tc_log_file))</span><br><span class="line">  &#123;</span><br><span class="line">    sql_print_error(<span class="string">"Can't init tc log"</span>);</span><br><span class="line">    unireg_abort(MYSQLD_ABORT_EXIT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/mysqld.cc中的init_server_components()方法中，首先根据参数设置事务协调者(tc,Transaction Coordinator)即代码中的tc_log对象，在MySQL启动时默认初始化为mysql_bin_log对象。之后最主要调用了<code>tc_log-&gt;open()</code>也即binlog的open()方法</p><blockquote><p>在事务提交时会依次执行<code>tc_log-&gt;prepare();tc_log-&gt;commit();</code>————即执行binlog的prepare()和commit()方法</p></blockquote><p>MYSQL_BIN_LOG::open()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *opt_name)</span> </span>&#123; <span class="keyword">return</span> open_binlog(opt_name); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::open_binlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *opt_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 确保index文件初始化成功</span></span><br><span class="line">  <span class="keyword">if</span> (!my_b_inited(&amp;index_file))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* There was a failure to open the index file, can't open the binlog */</span></span><br><span class="line">    cleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 找到index中第一个binlog</span></span><br><span class="line">  <span class="keyword">if</span> ((error= find_log_pos(&amp;log_info, NullS, <span class="literal">true</span><span class="comment">/*need_lock_index=true*/</span>)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (error != LOG_INFO_EOF) sql_print_error(<span class="string">"find_log_pos() failed (error: %d)"</span>, error);</span><br><span class="line">    <span class="keyword">else</span> error= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 找到index中最后一个binlog</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      strmake(log_name, log_info.log_file_name, <span class="keyword">sizeof</span>(log_name)<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!(error= find_next_log(&amp;log_info, <span class="literal">true</span><span class="comment">/*need_lock_index=true*/</span>)));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      打开最后一个binlog;校验文件头的Magic Number————\xfe\x62\x69\x6e</span></span><br><span class="line"><span class="comment">      如果Magic Number校验失败,报错退出,无法完成recovery</span></span><br><span class="line"><span class="comment">      如果确定最后一个binlog没有内容,可删除binlog文件再重试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((file= open_binlog_file(&amp;<span class="built_in">log</span>, log_name, &amp;errmsg)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sql_print_error(<span class="string">"%s"</span>, errmsg);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the binary log was not properly closed it means that the server</span></span><br><span class="line"><span class="comment">    may have crashed. In that case, we need to call MYSQL_BIN_LOG::recover</span></span><br><span class="line"><span class="comment">    to:</span></span><br><span class="line"><span class="comment">    如果binlog没有正常关闭,mysql服务端可能crash</span></span><br><span class="line"><span class="comment">    此时我们需要调用MYSQL_BIN_LOG::recover,为了:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      a) collect logged XIDs; 找出已记录的XIDs</span></span><br><span class="line"><span class="comment">      b) complete the 2PC of the pending XIDs; 完成待处理的XIDs的两阶段提交(InnoDB commit)</span></span><br><span class="line"><span class="comment">      c) collect the last valid position. 找到最后一个合法位点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Therefore, we do need to iterate over the binary log, even if</span></span><br><span class="line"><span class="comment">    total_ha_2pc == 1, to find the last valid group of events written.</span></span><br><span class="line"><span class="comment">    Later we will take this value and truncate the log if need be.</span></span><br><span class="line"><span class="comment">    因此我们需要遍历binlog文件,找出最后写入的一个合法event集合</span></span><br><span class="line"><span class="comment">    稍后截断无效的binlog,如果有必要的话</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((ev= Log_event::read_log_event(&amp;<span class="built_in">log</span>, <span class="number">0</span>, &amp;fdle, opt_master_verify_checksum)) &amp;&amp; ev-&gt;get_type_code() == binary_log::FORMAT_DESCRIPTION_EVENT &amp;&amp; (ev-&gt;common_header-&gt;flags &amp; LOG_EVENT_BINLOG_IN_USE_F || DBUG_EVALUATE_IF(<span class="string">"eval_force_bin_log_recovery"</span>, <span class="literal">true</span>, <span class="literal">false</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">      sql_print_information(<span class="string">"Recovering after a crash using %s"</span>, opt_name);</span><br><span class="line">      <span class="comment">// 初始化合法点位</span></span><br><span class="line">      valid_pos= my_b_tell(&amp;<span class="built_in">log</span>);</span><br><span class="line">      <span class="comment">// 执行recover恢复过程,并计算出合法点位</span></span><br><span class="line">      error= recover(&amp;<span class="built_in">log</span>, (Format_description_log_event *)ev, &amp;valid_pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> error=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Trim the crashed binlog file to last valid transaction</span></span><br><span class="line"><span class="comment">    or event (non-transaction) base on valid_pos. */</span></span><br><span class="line">    <span class="comment">// 将崩溃的binlog文件修剪到最后一个有效的事务或基于有效位置的event(非事务)</span></span><br><span class="line">    <span class="keyword">if</span> (valid_pos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((file= mysql_file_open(key_file_binlog, log_name, O_RDWR | O_BINARY, MYF(MY_WME))) &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Change binlog file size to valid_pos */</span></span><br><span class="line">      <span class="comment">// 将binlog文件大小更改为有效位置</span></span><br><span class="line">      <span class="keyword">if</span> (valid_pos &lt; binlog_size)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 将valid_pos后面的binlog截断</span></span><br><span class="line">        <span class="keyword">if</span> (my_chsize(file, valid_pos, <span class="number">0</span>, MYF(MY_WME)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          mysql_file_close(file, MYF(MY_WME));</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/**/</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Clear LOG_EVENT_BINLOG_IN_USE_F */</span></span><br><span class="line">      <span class="keyword">my_off_t</span> offset= BIN_LOG_HEADER_SIZE + FLAGS_OFFSET;</span><br><span class="line">      uchar flags= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (mysql_file_pwrite(file, &amp;flags, <span class="number">1</span>, offset, MYF(<span class="number">0</span>)) != <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        mysql_file_close(file, MYF(MY_WME));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mysql_file_close(file, MYF(MY_WME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/binlog.h中的open()方法直接调用了sql/binlog.cc中的MYSQL_BIN_LOG::open_binlog()方法，其中最主要调用了recover()方法进行恢复操作</p><p>recover()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">MYSQLD server recovers from last crashed binlog.</span></span><br><span class="line"><span class="comment">MySQL服务端从上次崩溃的binlog中恢复</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param log           IO_CACHE of the crashed binlog. </span></span><br><span class="line"><span class="comment">                     崩溃binlog的IO缓存</span></span><br><span class="line"><span class="comment">@param fdle          Format_description_log_event of the crashed binlog.</span></span><br><span class="line"><span class="comment">                     崩溃binlog的格式化描述</span></span><br><span class="line"><span class="comment">@param valid_pos     The position of the last valid transaction or</span></span><br><span class="line"><span class="comment">                     event(non-transaction) of the crashed binlog.</span></span><br><span class="line"><span class="comment">                     最后一个有效的事务或崩溃binlog的event(非事务)的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@retval 0 ok</span></span><br><span class="line"><span class="comment">@retval 1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::recover</span><span class="params">(IO_CACHE *<span class="built_in">log</span>, Format_description_log_event *fdle, <span class="keyword">my_off_t</span> *valid_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 初始化XID hash,用于记录binlog中的xid</span></span><br><span class="line">  <span class="keyword">if</span> (!fdle-&gt;is_valid() || my_hash_init(&amp;xids, &amp;my_charset_bin, memory_page_size / <span class="number">3</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_xid), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, key_memory_binlog_recover_exec)) <span class="keyword">goto</span> err1;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 依次读取binlog</span></span><br><span class="line">  <span class="keyword">while</span> ((ev= Log_event::read_log_event(<span class="built_in">log</span>, <span class="number">0</span>, fdle, TRUE)) &amp;&amp; ev-&gt;is_valid())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;get_type_code() == binary_log::QUERY_EVENT &amp;&amp; !<span class="built_in">strcmp</span>(((Query_log_event*)ev)-&gt;query, <span class="string">"BEGIN"</span>)) in_transaction= TRUE; <span class="comment">/* begin表示事务开始 */</span></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;get_type_code() == binary_log::QUERY_EVENT &amp;&amp; !<span class="built_in">strcmp</span>(((Query_log_event*)ev)-&gt;query, <span class="string">"COMMIT"</span>)) <span class="comment">/* commit表示事务结束 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      DBUG_ASSERT(in_transaction == TRUE);</span><br><span class="line">      in_transaction= FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ev-&gt;get_type_code() == binary_log::XID_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// xid event表示事务结束</span></span><br><span class="line">      DBUG_ASSERT(in_transaction == TRUE);</span><br><span class="line">      in_transaction= FALSE;</span><br><span class="line">      Xid_log_event *xev=(Xid_log_event *)ev;</span><br><span class="line">      uchar *x= (uchar *) memdup_root(&amp;mem_root, (uchar*) &amp;xev-&gt;xid, <span class="keyword">sizeof</span>(xev-&gt;xid));</span><br><span class="line">      <span class="comment">// 记录xid</span></span><br><span class="line">      <span class="keyword">if</span> (!x || my_hash_insert(&amp;xids, x)) <span class="keyword">goto</span> err2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Recorded valid position for the crashed binlog file</span></span><br><span class="line"><span class="comment">      which did not contain incorrect events. The following</span></span><br><span class="line"><span class="comment">      positions increase the variable valid_pos:</span></span><br><span class="line"><span class="comment">      为崩溃的binlog文件记录的有效位置,其中不包含不正确的事件</span></span><br><span class="line"><span class="comment">      以下位置增加有效位置变量：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      1 -</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        &lt;---&gt; HERE IS VALID &lt;---&gt;</span></span><br><span class="line"><span class="comment">        GTID </span></span><br><span class="line"><span class="comment">        BEGIN</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        COMMIT</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">      2 -</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">        &lt;---&gt; HERE IS VALID &lt;---&gt;</span></span><br><span class="line"><span class="comment">        GTID </span></span><br><span class="line"><span class="comment">        DDL/UTILITY</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In other words, the following positions do not increase</span></span><br><span class="line"><span class="comment">      the variable valid_pos:</span></span><br><span class="line"><span class="comment">      换句话说,以下位置不会增加有效位置变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      1 -</span></span><br><span class="line"><span class="comment">        GTID </span></span><br><span class="line"><span class="comment">        &lt;---&gt; HERE IS VALID &lt;---&gt;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      2 -</span></span><br><span class="line"><span class="comment">        GTID </span></span><br><span class="line"><span class="comment">        BEGIN</span></span><br><span class="line"><span class="comment">        &lt;---&gt; HERE IS VALID &lt;---&gt;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      如果不在事务中,且不是gtid event,则更新valid_pos</span></span><br><span class="line"><span class="comment">      如果在事务中,且最后一段event不是一个完整事务,pos不合法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">log</span>-&gt;error &amp;&amp; !in_transaction &amp;&amp; !is_gtid_event(ev)) *valid_pos= my_b_tell(<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">delete</span> ev;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Call ha_recover if and only if there is a registered engine that</span></span><br><span class="line"><span class="comment">    does 2PC, otherwise in DBUG builds calling ha_recover directly</span></span><br><span class="line"><span class="comment">    will result in an assert. (Production builds would be safe since</span></span><br><span class="line"><span class="comment">    ha_recover returns right away if total_ha_2pc &lt;= opt_log_bin.)</span></span><br><span class="line"><span class="comment">    当且仅当注册的引擎执行两阶段提交调用ha_recover()方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (total_ha_2pc &gt; <span class="number">1</span> &amp;&amp; ha_recover(&amp;xids)) <span class="keyword">goto</span> err2;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql/binlog.cc中的recover()方法主要逻辑为————遍历最后一个binlog的所有event，每次事务结尾(或者非事务event结尾)更新valid_pos(gtid event不更新)。并在一个hash中记录所有xid，用于引擎层恢复</p></li><li><p>在<code>tc_log-&gt;open();</code>语句执行恢复操作前，会调用MYSQL_BIN_LOG对象的open_index_file()方法</p><blockquote><p>为了保证binlog index的crash safe，MySQL引入了一个临时文件————crash_safe_index_file<br>新的binlog_file_name写入binlog_index_file，流程如下：</p><ol><li>创建临时文件crash_safe_index_file</li><li>拷贝binlog_index_file中的内容到crash_safe_index_file</li><li>新的binlog_file_name写入crash_safe_index_file</li><li>删除binlog_index_file</li><li>重命名crash_safe_index_file到binlog_index_file<br>这个流程保证了在任何时候崩溃时，binlog_index_file和crash_safe_index_file至少有一个可用这样恢复时只需判断这两个文件是否可用，如果binlog_index_file可用则无需特殊处理，如果binlog_index_file不可用则重命名crash_safe_index_file到binlog_index_file<br>binlog index的恢复过程主要在<code>MYSQL_BIN_LOG::open_index_file()</code>方法中</li></ol></blockquote><p>open_index_file()方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MYSQL_BIN_LOG::open_index_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *index_file_name_arg, <span class="keyword">const</span> <span class="keyword">char</span> *log_name, <span class="keyword">bool</span> need_lock_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 拼接index_file_name</span></span><br><span class="line">  fn_format(index_file_name, index_file_name_arg, mysql_data_home, <span class="string">".index"</span>, opt);</span><br><span class="line">  <span class="comment">// 拼接crash_safe_index_file_name</span></span><br><span class="line">  <span class="keyword">if</span> (set_crash_safe_index_file_name(index_file_name_arg))</span><br><span class="line">  &#123;</span><br><span class="line">    sql_print_error(<span class="string">"MYSQL_BIN_LOG::set_crash_safe_index_file_name failed."</span>);</span><br><span class="line">    error= <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  We need move crash_safe_index_file to index_file if the index_file</span></span><br><span class="line"><span class="comment">  does not exist and crash_safe_index_file exists when mysqld server</span></span><br><span class="line"><span class="comment">  restarts.</span></span><br><span class="line"><span class="comment">  检查index_file_name和crash_safe_index_file_name是否存在</span></span><br><span class="line"><span class="comment">  如果index_file_name不存在,crash_safe_index_file_name存在</span></span><br><span class="line"><span class="comment">  那么将crash_safe_index_file_name重命名为index_file_name</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (my_access(index_file_name, F_OK) &amp;&amp; !my_access(crash_safe_index_file_name, F_OK) &amp;&amp; my_rename(crash_safe_index_file_name, index_file_name, MYF(MY_WME)))</span><br><span class="line">  &#123;</span><br><span class="line">    sql_print_error(<span class="string">"MYSQL_BIN_LOG::open_index_file failed to "</span></span><br><span class="line">                    <span class="string">"move crash_safe_index_file to index file."</span>);</span><br><span class="line">    error= <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Middleware </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础</title>
      <link href="/2021/01/01/FrontEnd/Basic/H5+CSS3/"/>
      <url>/2021/01/01/FrontEnd/Basic/H5+CSS3/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#HTML介绍">HTML介绍</a></li><li><a href="#CSS介绍">CSS介绍</a></li></ul><a id="more"></a><h2 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h2><ul><li><p>注释</p><ul><li>介绍：会被浏览器忽视，不会直接显示；注释不能嵌套</li><li>语法：<code>&lt;!-- --&gt;</code></li></ul></li><li><p>文档声明(doctype)</p><ul><li>介绍：用来告知浏览器当前网页的版本</li><li>HTML5的文档声明：<code>&lt;!doctype html&gt;</code>或<code>&lt;!Doctype HTML&gt;</code></li></ul></li><li><p>HTML网页的基本构成</p><ol><li><code>&lt;!doctype html&gt;</code>：文档声明，声明当前网页的版本</li><li><code>&lt;html&gt;</code>：html的根标签(元素)，网页中所有内容都要写在根标签中</li><li><code>&lt;head&gt;</code>：网页头部，head中的内容不会直接出现，主要用来帮助浏览器或搜索引擎来解析网页</li><li><code>&lt;meta&gt;</code>：设置网页的元数据，可用来设置字符集避免乱码问题</li><li><code>&lt;title&gt;</code>：title中的内容会显示在浏览器的标题栏，搜索引擎主要根据title中的内容来判断网页的主要内容</li><li><code>&lt;body&gt;</code>：body是html的子元素，表示网页的主体，网页中所有的可见内容都应该写在body中</li></ol></li><li><p>实体：</p><ul><li>介绍：在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格。在HTML中有些时候不能直接书写一些特殊符号————比如多个连续的空格、字母两侧的大于和小于。如果需要在网页中书写这些特殊的符号，则需要使用html中的实体(转义字符)</li><li>实体的语法：&amp;实体的名字;</li><li>示例：<ol><li>&amp;nbsp; 空格(&nbsp;)</li><li>&amp;gt; 大于号(&gt;)</li><li>&amp;lt; 小于号(&lt;)</li><li>&amp;copy; 版权符号(&copy;)</li><li>...</li></ol></li></ul></li><li><p>meta标签</p><ul><li>介绍：meta主要用于设置网页中的一些元数据(不是给用户使用,而是给浏览器和搜索引擎使用)</li><li>主要属性：<ol><li>charset：指定网页的字符集<br> <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></li><li>name：指定数据的名称；content：指定数据的内容<br> <code>&lt;meta name=&quot;keywords&quot; content=&quot;SOBXiong&quot;&gt;</code><br> <code>&lt;meta name=&quot;description&quot; content=&quot;SOBXiong&quot;&gt;</code><blockquote><p>keywords：表示网站的关键词，可同时指定多个(使用’,’隔开)<br> description：用于指定网站的描述，网站的描述会显示在搜索引擎的搜索结果中<br> title：标签的内容会作为搜索结果的超链接上的文字显示</p></blockquote></li><li>http-equiv以及content可用于重定向到其他页面：<br> <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt;</code><blockquote><p>默认3秒后重定向到百度</p></blockquote></li></ol></li></ul></li><li><p>语义化标签</p><ul><li><p>介绍：在网页中HTML专门用来负责网页的结构，因此在使用html标签时应关注标签的语义，而不是样式</p><blockquote><p>浏览器在解析网页时，会自动对网页中不符合规范的内容进行修正。比如：</p><ol><li>标签写在了根元素的外部</li><li>p元素中嵌套了块元素</li><li>根元素中出现了除head和body以外的子元素</li><li>...</li></ol></blockquote></li><li><p>标签总体分类：</p><ol><li><p>块元素(Block Element)：在页面中独占一行的元素</p><blockquote><p>在网页中一般通过块元素来对页面进行布局</p></blockquote></li><li><p>行内元素(Inline Element)：在页面中不会独占一行的元素</p><blockquote><ol><li>行内元素主要用来包裹文字</li><li>一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素</li><li>块元素中基本上什么都能放</li><li>p元素中不能放任何的块元素</li></ol></blockquote></li></ol></li><li><p>标签具体分类：</p><ul><li>标题标签：<ol><li>介绍：分为h1～h6(一共有六级标题)，h1～h6重要性依次递减，h1最重要，h6最不重要。h1在网页中的重要性仅次于title标签。一般情况下一个页面中只会有一个h1，且标题标签一般只会使用到h1～h3，h4～h6很少用。块元素</li><li>hgroup：为标题分组，可将一组相关的标题同时放入hgroup</li></ol></li><li>p标签：页面中的一个段落；块元素</li><li>em标签：表示语音语调的一个加重；行内元素</li><li>strong标签：表示强调，属于重要内容；行内元素</li><li>blockquote标签：表示一个长引用；块元素</li><li>q标签：短引用；行内元素</li><li>br标签：页面中的换行；行内元素</li><li>布局标签(结构化语义标签)<ol><li>header：网页的头部</li><li>main：网页的主体部分(一个页面中只会有一个main)</li><li>footer：网页的底部</li><li>nav：网页中的导航</li><li>aside：和主体相关的其他内容(侧边栏)</li><li>article：一个独立的文章</li><li>section：一个独立的区块，以上标签都不能表示时可使用section</li><li>div：无语义，用来表示一个区块；目前div是主要的布局元素</li><li>span：行内元素，无语义，一般用于在网页中选中文字</li></ol></li><li>列表：<ul><li>介绍：列表之间可以相互嵌套，共有三种列表</li><li>分类：<ol><li>无序列表：使用&lt;ol&gt;标签创建，用&lt;li&gt;表示列表项</li><li>有序列表：使用&lt;ul&gt;标签创建，用&lt;li&gt;表示列表项</li><li>定义列表：使用&lt;dl&gt;标签创建，用&lt;dt&gt;表示定义的内容，使用&lt;dd&gt;表示对内容的解释说明</li></ol></li></ul></li><li>超链接：<ul><li>介绍：超链接可使从一个页面跳转到其他页面，或者是当前页面的其他的位置。超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素</li><li>标签：&lt;a&gt;</li><li>属性：<ul><li>href：用于指定跳转的目标路径(一个外部网站或内部页面)<blockquote><p>使用’#’作为占位符，会跳转到页面顶部<br>可设置为’javascript:;’作为占位符，点击无效果<br>如需跳转到指定位置，可设置为’#x’(目标元素的id值)</p></blockquote></li><li>target：用来指定超链接打开的位置<blockquote><p>_self：默认值，在当前页面中打开超链接<br>_blank：在一个新的页面中打开超链接</p></blockquote></li></ul></li></ul></li><li>图片标签：<ul><li>介绍：用于向当前页面中引入一个外部图片，是一个自结束标签，属于替换元素(块和行内元素之间,具有两种元素的特点)</li><li>标签：&lt;img&gt;</li><li>属性：<ul><li>src：指定外部图片的路径(路径规则和超链接一样)</li><li>alt：图片的描述，该描述默认情况下不会显示，有些浏览器图片无法加载时会显示。搜索引擎会根据alt中的内容来识别图片，如果不写alt属性则图片不会被搜索引擎收录</li><li>width、height：图片的高度和宽度(单位为px,像素)。如果只修改其中一个，另一个默认会等比例缩放。一般在pc端不建议修改图片的大小，需要多大的图片就裁多大；但在移动端经常需要对图片进行缩放(大图缩小)</li></ul></li><li>图片格式(效果一样用小的,不一样用好的)：<ul><li>jpeg(jpg)：<ol><li>支持的颜色比较丰富，不支持透明效果和动图</li><li>一般用来显示照片</li></ol></li><li>gif：<ol><li>支持的颜色比较少，支持简单透明效果和动图</li><li>颜色单一的图片，动图</li></ol></li><li>png：<ol><li>支持的颜色丰富，支持复杂透明但不支持动图</li><li>颜色丰富，复杂透明(专为网页而生)</li></ol></li><li>webp：<ol><li>谷歌新推出的专门用来表示网页中的图片的一种格式</li><li>具备其他图片格式的所有优点，而且文件还特别小</li><li>缺点：兼容性不好</li></ol></li></ul></li><li>base64编码：将图片使用base64编码，可将图片转换为字符。通过字符的形式来引入图片，一般都是一些需要和网页一起加载的图片才会使用base64</li></ul></li><li>内联框架：<ul><li>介绍：用于向当前页面中引入其他页面</li><li>属性：<ul><li>src：指定要引入的网页路径</li><li>frameborder：指定内联框架的边框</li></ul></li></ul></li><li>音视频标签：<ul><li>audio标签：<ul><li>介绍：用来向页面中引入一个外部的音频文件；引入时默认情况下不允许用户自己控制播放停止</li><li>属性：<ul><li>src：指定文件路径</li><li>controls：是否允许用户控制播放</li><li>autoplay：音频文件是否自动播放(如果设置了则打开页面时会自动播放,但目前大部分浏览器都不支持)</li><li>loop：音乐是否循环播放</li></ul></li></ul></li><li>video标签：用来向页面中引入一个视频，属性和audio基本一致</li></ul></li></ul></li></ul></li></ul><h2 id="CSS介绍"><a href="#CSS介绍" class="headerlink" title="CSS介绍"></a>CSS介绍</h2><ul><li>网页组成：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FrontEnd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂项</title>
      <link href="/2020/12/31/BasicSkill/Others/"/>
      <url>/2020/12/31/BasicSkill/Others/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#Idea常用快捷键">Idea常用快捷键</a></li></ul><a id="more"></a><h2 id="Idea常用快捷键"><a href="#Idea常用快捷键" class="headerlink" title="Idea常用快捷键"></a>Idea常用快捷键</h2><ul><li>查找相关：<ol><li>Command + O：查询任意存在Class，并跳转到源码</li><li>Command + F12：查看当前类的方法</li><li>Option + H：查看当前类的继承结构</li></ol></li><li>跳转相关：<ol><li>Option + Command + 左：上次查看地方</li><li>Option + Command + 右：下次查看地方</li><li>Command + 上：查看当前类所在包所有文件</li><li>Command + 下：maven定位当前类的包</li><li>Command + Fn + 左：查看当前文件的顶部</li><li>Command + Fn + 右：查看当前文件的底部</li><li>Command + L：通过行号快速跳转到某行</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2020/12/24/SpringSeries/SpringBoot/SpringBoot%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/12/24/SpringSeries/SpringBoot/SpringBoot%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#SpringBoot概述">SpringBoot概述</a></li><li><a href="#SpringBoot入门">SpringBoot入门</a></li><li><a href="#自动配置原理介绍">自动配置原理介绍</a></li><li><a href="#Web场景">Web场景</a></li><li><a href="#杂项">杂项</a></li></ul><a id="more"></a><h2 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h2><ul><li>SpringBoot是什么：整合Spring技术栈的一站式框架，简化Spring技术栈的快速开发脚手架<blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”————能快速创建出生产级别的Spring应用</p></blockquote></li><li>SpringBoot优点：<ol><li>快速创建独立Spring应用</li><li>内嵌web服务器(Tomcat、Jetty、Undertow)</li><li>自动starter依赖，简化构建配置</li><li>自动配置Spring以及第三方功能</li><li>提供生产级别的监控、健康检查及外部化配置</li><li>无代码生成、无需编写XML</li></ol></li><li>SpringBoot资料：<ol><li>官方资料：<ul><li><a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">https://spring.io/projects/spring-boot#learn</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></li></ul></li><li>Github(介绍版本差别和新特性)：<a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a></li><li>中文资料：<a href="https://www.docs4dev.com/" target="_blank" rel="noopener">https://www.docs4dev.com/</a></li></ol></li></ul><h2 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h2><ul><li><p>HelloWorld(根据官网手册)</p><ol><li><p>创建maven项目</p></li><li><p>导入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        加入SpringBoot maven打包工具</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写yml配置文件</p></li><li><p>创建主程序(@SpringBootApplication、SpringApplication.run(xxxApplication.class))</p><blockquote><p>SpringApplication.run()方法有返回值，返回值为IOC容器对象</p></blockquote></li></ol></li><li><p>依赖管理：</p><ul><li><p>父项目定义依赖：</p><blockquote><p>我们的SpringBoot项目依赖spring-boot-starter-parent<br>spring-boot-starter-parent依赖spring-boot-dependencies<br>spring-boot-dependencies管理了大部分依赖关系和版本</p></blockquote></li><li><p>starter场景启动器(只要引入starter，该场景的所有依赖和基本配置都自动引入了)：</p><blockquote><p>spring-boot-starter-*表示官方编写的场景启动器<br>SpringBoot支持的所有官方场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a><br>*-spring-boot-starter表示第三方提供的场景启动器<br>所以场景启动器最底层都依赖了spring-boot-starter</p></blockquote></li><li><p>依赖版本号</p><blockquote><p>引入依赖默认都不需要写版本号(都经过SpringBoot的版本仲裁)<br>引入非版本仲裁的依赖需要指定版本号<br>修改默认版本号的方式</p></blockquote>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  查看spring-boot-dependencies中规定的当前依赖的版本所用的property属性名</span></span><br><span class="line"><span class="comment">  在当前maven配置中重写</span></span><br><span class="line"><span class="comment">  maven默认以子项目的版本号为主</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xxx.version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">xxx.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>自动配置</p><ul><li><p>自动配置Tomcat(引入starter-web)：内嵌tomcat服务器</p></li><li><p>自动配置SpringMVC(引入starter-web)</p><ol><li>dispatcherServlet中央处理器</li><li>characterEncodingFilter解决字符编码问题</li><li>jackson解决json转换</li><li>viewResolver解决资源映射问题</li><li>multipartResolver解决上传文件问题</li><li>…</li></ol></li><li><p>自动配置扫描包组件：</p><ul><li><p>主程序Application所在包及子包中的组件都会被默认扫描</p></li><li><p>修改扫描路径：@SpringBootApplication(scanBasePackages = “xxx”)</p></li><li><p>@SpringBootApplication注解的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @SpringBootApplication注解属于合成注解，相当于使用了以下三个注解：</span></span><br><span class="line"><span class="comment">//  @SpringBootConfiguration</span></span><br><span class="line"><span class="comment">//  @EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">//  @ComponentScan</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>自动配置项属性</p><ul><li>默认配置最终都会映射到某个类上(如MultipartProperties)</li><li>配置文件的值最终会绑定到一个配置属性类上，该类对象会保存在容器中</li></ul></li><li><p>按需加载自动配置项</p><ul><li>引入某场景，对应场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在spring-boot-autoconfigure包中</li></ul></li></ul></li><li><p>组件添加</p><ul><li>@Configuration：<ol><li>起到配置类的作用，相当于Spring中xml配置文件的作用</li><li>配置类本身也是组件，可以在容器中拿到</li><li>配置类中可使用@Bean注解给容器注册组件，默认也是单实例的</li><li>属性proxyBeanMethods描述代理bean的方法：<blockquote><p>Full模式(proxyBeanMethods = true)：保证每个@Bean方法被调用返回的组件都是从容器中找————单实例(组件依赖的情况必须使用Full模式,true也是默认值)<br> Lite模式(proxyBeanMethods = false)：每个@Bean方法被调用返回的组件都是新创建的</p></blockquote></li></ol></li><li>@Bean、@Component、@Controller、@Service、@Repository<blockquote><p>@Bean注册的组件名默认为方法名</p></blockquote></li><li>@ComponentScan</li><li>@Import：根据类型在容器中创建组件，默认组件名是全类名</li><li>@Conditional：<ol><li>条件装配(满足Conditional指定的条件才进行组件注册)</li><li>SpringBoot按需自动加载配置项大量用到条件装配</li></ol></li><li>@ImportResource：导入指定路径的原生Spring xml配置文件(适合老项目迁移)</li></ul></li><li><p>配置绑定</p><ul><li><p>介绍：读取application.properties或applicaiton.yml的内容并封装到JavaBean中；其中对应的JavaBean必须是在容器中的组件</p></li><li><p>实现方式：</p><ol><li>@Component + @ConfigurationProperties(同一个类上)：@Component保证将该配置Bean注册进容器，@ConfigurationProperties开启配置绑定功能</li><li>@EnableConfigurationProperties + @ConfigurationProperties(不同类上)：@EnableConfigurationProperties可指定注册进容器的@ConfigurationProperties标注的配置Bean(一般用于第三方配置)</li></ol></li><li><p>IDE启用properties或yml配置文件的提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="自动配置原理介绍"><a href="#自动配置原理介绍" class="headerlink" title="自动配置原理介绍"></a>自动配置原理介绍</h2><ul><li><p>引导加载自动配置类</p><ul><li><p>@SpringBootConfiguration：代表当前是一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ComponentScan：指定包扫描组件路径</p></li><li><p>@EnableAutoConfiguration：</p><ol><li><p>@EnableAutoConfiguration是一个合成注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@AutoConfigurationPackage通过@Import注解导入另一个类AutoConfigurationPackages.Registrar</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Registrar通过调用register()方法进行批量注册(导入一系列组件)</p><p> Registrar源码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImports(metadata));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>AnonotationMetadata就是指标注了@AutoConfigurationPackages的类的注解元信息，又由于@EnableAutoConfiguration是一个合成注解，因此相当于@AutoConfigurationPackages标注在MainApplicaiton上<br> 其中new PackageImports(metadata).getPackageNames().toArray(new String[0])就是获取当前MainApplication的所在的包名；因此register()方法就是把当前MainApplication所在的包下的所有组件都注册进容器</p></blockquote></li><li><p>@EnableAutoConfiguration通过@Import导入AutoConfigurationImportSelector类</p><p> AutoConfigurationImportSelector部分源码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,<span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">        getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最主要的就是通过getAutoConfigurationEntry(annotationMetadata)方法得到自动配置的组件。该方法通过getCandidateConfigurations()获取所有候选的配置configurations，接下来反复操作configurations，比如removeDuplicates()方法去重、removeAll()排除部分...最终封装并返回</p></blockquote><p> 方法调用链如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">  <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String factoryTypeName = factoryType.getName();</span><br><span class="line">  <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">  Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">      URL url = urls.nextElement();</span><br><span class="line">      UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">        String[] factoryImplementationNames =</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">        <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">          result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">              .add(factoryImplementationName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">    result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">        .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">    cache.put(classLoader, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">        FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>loadSpringFactories()方法最终是通过<br> <code>Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</code><br> 加载文件的。其中FACTORIES_RESOURCE_LOCATION值为”META-INF/spring.factories”，因此会默认扫描当前系统中所有META-INF/spring.factories位置的文件<br> <img src="spring-boot-autoconfigure.jar%E5%86%85%E5%AE%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="spring-boot-autoconfigure.jar内容示意图"><br> <img src="spring.factories%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9.png" alt="spring.factories部分内容"><br> spring.factories中Auto Configure部分写死了SpringBoot一启动就要向容器中加载的所有配置类</p></blockquote></li></ol></li></ul></li><li><p>按需开启自动配置项</p><ul><li><p>介绍：上面介绍了启动时会默认全部加载所有场景的自动配置；按照条件装配规则，最终按需配置加载</p></li><li><p>例子1：Aop场景(AopAutoConfiguration自动配置类)：</p><p>  AopAutoConfiguration源码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">        matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">        matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.aspectj.weaver.Advice"</span>)</span><br><span class="line">  <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">      matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只有主类上的条件装配满足，才需要看子类和方法的条件装配<br>  <code>@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</code>表示如果在配置文件中声明了spring.aop.name为true时当前aop的自动配置生效，但因为matchIfMissing属性，所以没声明也认为是true，也自动生效<br>  AspectJAutoProxyingConfiguration使用<code>@ConditionalOnClass(Advice.class)</code>标注只有在导入了Advice.class(aspectj的包)之后才会生效<br>  由于Advice.class没被导入，此时ClassProxyingConfiguration生效。因为它使用<code>@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</code>标注，表示没有导入Adivce.class时生效，此时开启了简单的AOP功能</p></blockquote></li><li><p>例子2：Web场景(DispatcherServletAutoConfiguration自动配置类)</p><p>DispatcherServletAutoConfiguration源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">ServletWebServerFactoryAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@Conditional</span>(DefaultDispatcherServletCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  @<span class="title">ConditionalOnClass</span>(<span class="title">ServletRegistration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">  @<span class="title">EnableConfigurationProperties</span>(<span class="title">WebMvcProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">protected</span> <span class="title">static</span> <span class="title">class</span> <span class="title">DispatcherServletConfiguration</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DispatcherServlet <span class="title">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> </span>&#123;</span><br><span class="line">      DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">      dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">      dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">      dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">      dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">      dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">      <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean</span>(MultipartResolver<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">      <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ConditionalOnWebApplication注解判断当前是否是一个web应用，而且是一个传统的原生servlet web应用(区别于响应式WebFlux)<br>@ConditionalOnClass注解判断当前是否导入了DispatcherServlet类(Spring-webmvc包下)<br>@AutoConfigureOrder指定最先的加载顺序<br>@AutoConfigureAfter指定在web服务器配置加载之后加载<br>子类DispatcherServletConfiguration启用了WebMvcProperties配置，并在dispatcherServlet()方法中返回一个封装好各种参数的dispatcherServlet，且beanName默认为dispatcherServlet————<code>public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;;</code><br>还配置了一个MultipartResolver文件上传解析器(优先使用用户自定义的)：@ConditionalOnMissingBean表示如果用户自定义的解析器名称不合乎规范，那么就将它原样返回(方法参数会默认从容器中找)</p></blockquote></li><li><p>总结：</p><ul><li>SpringBoot先加载所有的自动配置类xxxAutoConfiguration</li><li>每个自动配置类按照条件装配，默认会绑定一个xxxProperties配置类，xxxProperties配置类又和和配置文件application.properties/application.yml进行了绑定</li><li>生效的配置类会给容器装配很多组件；只要容器中有对应的组件，就相当于启用了对应的功能</li><li>定制化配置(默认以用户配置为主)<ul><li>修改配置文件中的对应属性值</li><li>使用@Bean替换底层组件</li></ul></li></ul></li></ul></li><li><p>最佳实践</p><ul><li>引入场景依赖：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a></li><li>查看自动配置了哪些<ul><li>引入场景后，一般对应的自动配置都生效</li><li>在配置文件中声明debug=true开启打印自动配置报告并查看自动配置情况</li></ul></li><li>按需修改<ul><li>参照文档修改配置：<ul><li>官网资料：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties</a></li><li>查看并分析xxxProperties中的属性</li></ul></li><li>自定义加入或替换组件：@Bean、@Component...</li><li>自定义器：xxxCustomizer</li><li>...</li></ul></li></ul></li></ul><h2 id="Web场景"><a href="#Web场景" class="headerlink" title="Web场景"></a>Web场景</h2><ul><li><p>SpringMVC自动配置概览</p><ol><li>内容协商视图解析器<code>ContentNegotiatingViewResolver</code>和BeanName视图解析器<code>BeanNameViewResolver</code></li><li>静态资源映射(包括webjars)</li><li>自动注册<code>Converter, GenericConverter, Formatter</code></li><li>支持<code>HttpMessageConverters</code></li><li>自动注册<code>MessageCodesResolver</code>(国际化)</li><li>静态index.html支持</li><li>自定义<code>Favicon</code></li><li>自动使用<code>ConfigurableWebBindingInitializer</code>(DataBinder负责将请求数据绑定到JavaBean上)</li></ol></li><li><p>定制化SpringMVC功能：通过在配置类中导入WebMvcConfigurer的Bean，并在创建时重写一系列方法</p></li><li><p>静态资源访问相关</p><ul><li><p>静态资源访问：<br>参考地址：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content</a></p><ol><li><p>静态资源目录：<br> 只要静态资源放在<strong>类路径(classpath)下</strong>————/static、/public、/resources、/META-INF/resources，就可以通过使用<strong>当前项目跟路径/静态资源名</strong>来访问<br> 原理：默认静态资源映射为/**，请求进来先去找Controller能不能处理，不能处理的所有请求全都交给静态资源处理器(默认从上面的路径下找)，再找不到则响应404页面<br> 改变默认静态资源路径示例如下：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> <span class="string">[classpath:/res/]</span></span><br></pre></td></tr></table></figure></li><li><p>静态资源访问前缀：<br> 默认情况无前缀，静态资源访问路径 = 项目名/static-path-pattern/资源名，示例如下：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">mvc:</span> </span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure></li><li><p>欢迎页支持：</p><ul><li>默认路径为静态资源路径下的index.html，配置静态资源的访问前缀会导致欢迎页失效</li><li>可以使用controller处理/index请求</li></ul></li><li><p>自定义Favicon：favicon.ico放在静态资源目录下即可；同样地，配置静态资源的访问前缀会导致欢迎页失效(浏览器默认请求/favicon获取)</p></li></ol></li><li><p>静态资源配置原理分析：</p><ul><li><p>导入web场景后，SpringMVC的自动配置类WebMvcAutoConfiguration生效</p><p>WebMvcAutoConfiguration源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurer</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">TaskExecutionAutoConfiguration</span>.<span class="title">class</span>, <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">  <span class="meta">@Import</span>(EnableWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  @<span class="title">EnableConfigurationProperties</span>(</span>&#123; WebMvcProperties<span class="class">.<span class="keyword">class</span>, <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">boot</span>.<span class="title">autoconfigure</span>.<span class="title">web</span>.<span class="title">ResourceProperties</span>.<span class="title">class</span>, <span class="title">WebProperties</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">  @<span class="title">Order</span>(0)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebMvcAutoConfigurationAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    org.springframework.boot.autoconfigure.web.ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">    WebProperties webProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.resourceProperties = <span class="function">resourceProperties <span class="title">hasBeenCustomized</span><span class="params">()</span> ? resourceProperties : webProperties.<span class="title">getResources</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="keyword">this</span>.mvcProperties = mvcProperties;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      <span class="keyword">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line">      <span class="keyword">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line">      <span class="keyword">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line">      <span class="keyword">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line">      <span class="keyword">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123; <span class="comment">/**/ &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">    public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; /**/</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在WebMvcAutoConfigurationAdapter中启用了WebMvcProperties(绑定spring.mvc)和ResourceProperties配置类(绑定spring.resources)<br>在WebMvcAutoConfigurationAdapter构造器中的参数都从容器中获取：</p></blockquote><ol><li>其中properties是绑定的配置类对象</li><li>ListableBeanFactory是spring的beanFactory(容器)</li><li>ObjectProvider&lt;HttpMessageConverters&gt;：所有的HttpMessageConveter</li><li>ObjectProvider&lt;ResourceHandlerRegistrationCustomize&gt;：资源处理器的自定义器</li></ol></li><li><p>静态资源映射原理分析：<br>相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">  CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">      .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">      .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)</span><br><span class="line">      .setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">  &#125;</span><br><span class="line">  String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">      .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">      .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)</span><br><span class="line">      .setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>!this.resourceProperties.isAddMappings()</code>如果resourceProperties的addMappings属性为false(对应properties配置文件中的spring.web.resources.add-mappings)，那么直接跳过，这表明禁用静态资源映射<br>接下来的两行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br></pre></td></tr></table></figure><p>表明可通过resourceProperties配置类配置静态资源的缓存规则(对应properties配置文件的spring.web.resources.cache)</p><p>接着指定webjars的映射和缓存规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">  customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">    .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">    .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)</span><br><span class="line">    .setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后设置静态资源的加载规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">  customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">    .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">    .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)</span><br><span class="line">    .setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>staticPathPattern默认值为/**，静态资源和webjars的映射和缓存规则几乎相同，除了映射地址不同。其中静态资源地址的默认值源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">"classpath:/META-INF/resources/"</span>,</span><br><span class="line">      <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>欢迎页处理规则分析：<br>相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">  WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line">    <span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line">    <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">  welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">  welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">  <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;</span><br><span class="line">  <span class="keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="string">"/**"</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">    logger.info(<span class="string">"Adding welcome page: "</span> + welcomePage.get());</span><br><span class="line">    setRootViewName(<span class="string">"forward:index.html"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">    logger.info(<span class="string">"Adding welcome page template: index"</span>);</span><br><span class="line">    setRootViewName(<span class="string">"index"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在WelcomePageHandlerMapping构造函数中<code>welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)</code>表明如果欢迎页存在并且静态资源路径前缀是/**才会转发到index.html，否则就调用controller响应index请求。这就解释了为什么配置静态资源前缀会使欢迎页失效</p></blockquote></li></ul></li></ul></li><li><p>请求参数处理</p><ul><li><p>请求映射</p><ul><li><p>rest介绍与原理：</p><ul><li><p>Rest介绍：</p><ol><li>Controller方法使用@xxxMapping注释</li><li>Rest风格使用：GET————获取、POST————保存、DELETE————删除、PUT————修改</li><li>表单的核心Filter：HiddenHttpMethodFilter<ul><li>用法：表单method设置为post，隐藏域_method=xxx</li><li>SpringBoot手动开启：spring.mvc.hiddenmethod.filter.enable=true(开启页面表单的Rest功能)</li></ul></li><li>客户端默认支持Rest(表单只支持GET、POST)</li></ol></li><li><p>Rest简要原理(表单提交)：</p><ol><li>表单提交会带上_method=PUT/DELETE</li><li>请求时被HiddenHttpMethodFilter拦截处理</li></ol></li><li><p>源码分析：</p><p>WebMvcAutoConfiguration源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(HiddenHttpMethodFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.mvc.hiddenmethod.filter"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>matchIfMissing = false，如果不手动开启就不使用隐藏表单提交Rest请求</p></blockquote><p>HiddenHttpMethodFilter源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_METHOD_PARAM = <span class="string">"_method"</span>;</span><br><span class="line">  <span class="keyword">private</span> String methodParam = DEFAULT_METHOD_PARAM;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest requestToUse = request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      String paramValue = request.getParameter(<span class="keyword">this</span>.methodParam);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">        String method = paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">        <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">          requestToUse = <span class="keyword">new</span> HttpMethodRequestWrapper(request, method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(requestToUse, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>&quot;POST&quot;.equals(request.getMethod()</code>请求必须为POST请求<br><code>request.getParameter(this.methodParam)</code>又有methodParam默认为”_method”，因此默认获取_method请求参数(PUT/DELETE)<br><code>paramValue.toUpperCase(Locale.ENGLISH)</code>表明_method大小写均可<br><code>ALLOWED_METHODS.contains(method)</code>验证请求方式是否支持(PUT、DELETE、PATCH)<br>最后通过wrapper包装原生的request(重写了getMethod()方法)，最终交由过滤器链运行</p></blockquote></li></ul></li><li><p>请求映射原理</p><ul><li><p>SpringMVC中的Servlet继承结构：<br><img src="Servlet%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Servlet继承结构图"></p></li><li><p>请求过程分析：</p><ol><li><p>请求经过HttpServlet的doGet(doPost等等同)方法：</p></li><li><p>子类FrameworkServlet重写doGet(doPost等等同)方法统一调用processRequest()方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>processRequest()最终调用doService()处理逻辑</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doService(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">    failureCause = ex;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    failureCause = ex;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">    <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestAttributes.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    logResult(request, response, failureCause, asyncManager);</span><br><span class="line">    publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类DispatcherServlet重写抽象方法doService()，最终调用doDispatch()方法进行转发</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DispatcherServlet.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doDispatch(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">      <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">      <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (requestPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>doDispatch()方法解析</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  HttpServletRequest processedRequest = request;</span><br><span class="line">  HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">    Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      processedRequest = checkMultipart(request);</span><br><span class="line">      multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">      mappedHandler = getHandler(processedRequest);</span><br><span class="line">      <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        noHandlerFound(processedRequest, response);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      dispatchException = ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">      HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>processedRequest = checkMultipart(request)</code>检查是否进行文件上传请求<br> <code>mappedHandler = getHandler(processedRequest)</code>决定当前请求的处理方法<br> <img src="%E5%88%9D%E5%A7%8B%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E8%A1%A8.png" alt="初始处理器映射表"><br> @RequestMappingHandlerMapping：保存了所有@RequestMapping和handler的映射规则<br> <img src="RequestMappingHandlerMapping%E7%9A%84%E5%A4%84%E7%90%86%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png" alt="RequestMappingHandlerMapping的处理映射规则"></p></blockquote></li><li><p>getHandler()获取处理方法解析</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractHandlerMapping.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object handler = getHandlerInternal(request);</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = getDefaultHandler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">  <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String handlerName = (String) handler;</span><br><span class="line">    handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMappingInfoHandlerMapping.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  request.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getHandlerInternal(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    ProducesRequestCondition.clearMediaTypesAttribute(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHandlerMethodMapping.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String lookupPath = initLookupPath(request);</span><br><span class="line">  <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">    <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">  <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">    addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getRegistrations().keySet(), matches, request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">    Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">      matches.sort(comparator);</span><br><span class="line">      bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(matches.size() + <span class="string">" matching mappings: "</span> + matches);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">      &#125;</span><br><span class="line">      Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">        Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">        Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="string">"': &#123;"</span> + m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">    handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">    <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getRegistrations().keySet(), lookupPath, request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DispatcherServlet的getHandler()调用AbstractHandlerMapping的getHandler()方法<br> getHandler()方法调用getHandlerInternal()抽象方法，实际调用了RequestMappingInfoHandlerMapping的getHandlerInternal()方法<br> getHandlerInternal()方法实际调用了父类AbstractHandlerMethodMapping的getHandlerInternal()方法<br> 最后getHandlerInternal()方法调用了lookupHandlerMethod()方法决定选择处理请求的处理器方法</p></blockquote><p> <img src="%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="请求映射时序图"></p></li></ol></li><li><p>自动的添加映射器源码分析</p><p>WebMvcAutoConfiguration源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @Qualifier(<span class="string">"mvcContentNegotiationManager"</span>)</span> ContentNegotiationManager contentNegotiationManager,</span></span><br><span class="line"><span class="function">    @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcConversionService"</span>)</span> FormattingConversionService conversionService,</span></span><br><span class="line"><span class="function">    @<span class="title">Qualifier</span><span class="params">(<span class="string">"mvcResourceUrlProvider"</span>)</span> ResourceUrlProvider resourceUrlProvider) </span>&#123;</span><br><span class="line">  <span class="comment">// Must be @Primary for MvcUriComponentsBuilder to work</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.requestMappingHandlerMapping(contentNegotiationManager, conversionService,</span><br><span class="line">      resourceUrlProvider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">  WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(</span><br><span class="line">      <span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),</span><br><span class="line">      <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">  welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">  welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">  <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SpringBoot默认添加RequestMappingHandlerMapping用于映射Controller编写的@RequestMapping修饰的方法；默认添加WelcomePageHandlerMapping映射欢迎页</p></blockquote></li><li><p>总结</p><ol><li>自动配置欢迎页的WelcomePageHandlerMapping，访问’/‘能访问到index.html</li><li>自动配置了默认的RequestMappingHandlerMapping</li><li>请求进来后挨个尝试所有的HandlerMapping看是否有请求信息(如果有就找到这个请求对应的handler,没有就继续遍历)</li><li>若需要一些自定义的映射处理，也可给容器中放HandlerMapping(自定义 HandlerMapping)</li></ol></li></ul></li></ul></li><li><p>请求参数</p><ul><li><p>相关类：</p><ul><li>注解：@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody</li><li>Servlet API：WebRequest、ServletRequest、MultipartRequest、HttpSession等(具体见ServletRequestMethodArgumentResolver类的supportsParameter()方法)</li><li>复杂参数：Map、Model(<strong>map、model里面的数据会被放在request的请求域中————相当于request.setAttribute()</strong>)、RedirectAttributes(重定向携带数据)、ServletResponse(response)<blockquote><p>无论是Map还是Model类型，底层都会使用<code>mavContainer.getModel();</code>方法返回BindingAwareModelMap(即是Model也是Map)</p></blockquote></li></ul></li><li><p>参数处理：</p><ul><li><p>介绍：</p><ol><li>HandlerMapping中找到能够处理请求的Handler(Controller中的处理方法)</li><li>为当前Handler找一个适配器HandlerAdapter————<strong>RequestMappingHandlerAdapter</strong><br> <img src="%E9%BB%98%E8%AE%A4handlerAdapter.png" alt="默认handlerAdapter"><ol><li>RequestMappingHandlerAdapter支持标注@RequestMapping的方法</li><li>HandlerFunctionAdapter支持函数式变成的方法</li></ol></li><li>使用参数解析器argumentResolver解析目标方法的每一个参数的值<br> <img src="%E9%BB%98%E8%AE%A4argumentResolver%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8.png" alt="默认argumentResolver参数解析器"><br> SpringMVC目标方法能支持多少种参数类型取决于参数解析器<br> <img src="%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E6%8E%A5%E5%8F%A3HandlerMethodArgumentResolver%E7%9A%84%E6%96%B9%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="参数解析器接口HandlerMethodArgumentResolver的方法示意图"><ol><li>supportsParameter()方法表示当前解析器是否支持解析这种参数</li><li>resolveArgument()方法表示具体解析的逻辑</li></ol></li><li>执行目标方法</li></ol></li><li><p>源码分析：</p><p>DispatcherServlet的doDispatch()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">    Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">      mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">      HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">      mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      dispatchException = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">        <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先通过<code>mappedHandler = getHandler(processedRequest);</code>找到能够响应当前请求的处理器方法<br>然后通过<code>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</code>找到处理当前请求的handler适配器<br>最后通过<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>执行处理器方法并返回modelAndView</p></blockquote><p>handle()方法执行流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractHandlerMethodAdapter.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMappingHandlerAdapter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">    HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">      mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">    mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DispatcherServlet中的doDispatcher方法调用<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>执行目标方法<br>之后handle方法调用的是AbstractHandlerMethodAdapter的handle方法，其实质上又调用了子类RequestMappingHandlerAdapter的handleInternal方法，最终调用了RequestMappingHandlerAdapter的invokeHandlerMethod方法</p></blockquote><p>invokeHandlerMethod()方法执行流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerAdapter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    webRequest.requestCompleted();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletInvocableHandlerMethod.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">  setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvocableHandlerMethod.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Arguments: "</span> + Arrays.toString(args));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>invokeHandlerMethod首先设置参数解析器和返回值解析器，最终调用类ServletInvocableHandlerMethod的<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code>解析参数、执行目标方法并获得返回值<br>invokeAndHandle通过调用父类InvocableHandlerMethod的invokeForRequest执行目标方法，invokeForRequest先调用getMethodArgumentValues获取方法参数值，最终调用doInvoke方法执行目标处理器方法的逻辑(反射执行)</p></blockquote><p>getMethodArgumentValues方法流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocableHandlerMethod.class</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">  <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">    MethodParameter parameter = parameters[i];</span><br><span class="line">    parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">    args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">"No suitable resolver"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String exMsg = ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (exMsg != <span class="keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">          logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerMethodArgumentResolverComposite.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getArgumentResolver(parameter) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">  HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">        result = resolver;</span><br><span class="line">        <span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line">  <span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported parameter type ["</span> +</span><br><span class="line">        parameter.getParameterType().getName() + <span class="string">"]. supportsParameter should be called first."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>MethodParameter[] parameters = getMethodParameters();</code>首先获取方法的参数声明<br><code>this.resolvers.supportsParameter(parameter)</code>使用参数解析器列表判断当前是否能解析参数————supportsParameter()方法最终调用类HandlerMethodArgumentResolverComposite的getArgumentResolver()方法判断是否支持(通过遍历所有的参数解析器)，判断支持后进行缓存<br><code>args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</code>使用上一步确定的参数解析器对参数进行解析(最终使用具体的解析器解析————大部分通过原生ServletAPI获取相应的参数)</p></blockquote></li></ul></li><li><p>自定义参数(POJO封装过程)分析：</p><ul><li><p>表单提交：</p><p>支持的请求参数解析器分析流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModelAttributeMethodProcessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (parameter.hasParameterAnnotation(ModelAttribute<span class="class">.<span class="keyword">class</span>) || (<span class="title">this</span>.<span class="title">annotationNotRequired</span> &amp;&amp; !<span class="title">BeanUtils</span>.<span class="title">isSimpleProperty</span>(<span class="title">parameter</span>.<span class="title">getParameterType</span>())))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanUtils.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSimpleProperty</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(type, <span class="string">"'type' must not be null"</span>);</span><br><span class="line">  <span class="keyword">return</span> isSimpleValueType(type) || (type.isArray() &amp;&amp; isSimpleValueType(type.getComponentType()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSimpleValueType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Void<span class="class">.<span class="keyword">class</span> !</span>= type &amp;&amp; <span class="keyword">void</span><span class="class">.<span class="keyword">class</span> !</span>= type &amp;&amp;</span><br><span class="line">      (ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">      Enum<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">CharSequence</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">Number</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">Date</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">Temporal</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">URI</span>.<span class="title">class</span> </span>== type ||</span><br><span class="line">      URL<span class="class">.<span class="keyword">class</span> </span>== type ||</span><br><span class="line">      Locale<span class="class">.<span class="keyword">class</span> </span>== type ||</span><br><span class="line">      Class<span class="class">.<span class="keyword">class</span> </span>== type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>紧接着上述的分析，通过InvocableHandlerMethod类的getMethodArgumentValues()方法中的<code>!this.resolvers.supportsParameter(parameter)</code>开始判断<br>首先调用HandlerMethodArgumentResolverComposite类的getArgumentResolver()方法找到能够处理的请求参数解析器<br>最终找到的能够支持的请求参数解析器为ServletModelAttributeMethodProcessor类(ModelAttributeMethodProcessor的子类)<br>首先ModelAttribute注解没有，前者为false；其次annotationNotRequired属性默认初始化为true；然后isSimpleProperty方法返回是否为简单属性————规定的class类本身或其数组(此处是自定义的数据类,因此不满足),后者条件为true，当前解析器满足。跳出循环并放入缓存</p></blockquote><p>调用请求参数解析器解析流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMethodArgumentResolverComposite.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line">  <span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported parameter type ["</span> +</span><br><span class="line">        parameter.getParameterType().getName() + <span class="string">"]. supportsParameter should be called first."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModelAttributeMethodProcessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">    attribute = mavContainer.getModel().get(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Create attribute instance</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      attribute = createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BindException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBindExceptionRequired(parameter)) &#123;</span><br><span class="line">        <span class="comment">// No BindingResult parameter -&gt; fail with BindException</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise, expose null/empty value and associated BindingResult</span></span><br><span class="line">      <span class="keyword">if</span> (parameter.getParameterType() == Optional<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        attribute = Optional.empty();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        attribute = ex.getTarget();</span><br><span class="line">      &#125;</span><br><span class="line">      bindingResult = ex.getBindingResult();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bindingResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Bean property binding and validation;</span></span><br><span class="line">    <span class="comment">// skipped in case of binding failure on construction.</span></span><br><span class="line">    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">    <span class="keyword">if</span> (binder.getTarget() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;</span><br><span class="line">        bindRequestParameters(binder, webRequest);</span><br><span class="line">      &#125;</span><br><span class="line">      validateIfApplicable(binder, parameter);</span><br><span class="line">      <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindException(binder.getBindingResult());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Value type adaptation, also covering java.util.Optional</span></span><br><span class="line">    <span class="keyword">if</span> (!parameter.getParameterType().isInstance(attribute)) &#123;</span><br><span class="line">      attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    bindingResult = binder.getBindingResult();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过InvocableHandlerMethod类的getMethodArgumentValues()方法中的<code>args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</code>开始解析<br>首先getArgumentResolver就是调用之前的流程，因为已经缓存，所以直接可以找到。最主要是语句<code>return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</code>调用ModelAttributeMethodProcessor类的resolveArgument()方法<br>在resolveArgument()方法中：</p></blockquote><ol><li><code>attribute = createAttribute(name, parameter, binderFactory, webRequest);</code>得到通过反射创建的JavaBean(属性全为默认值————null、0、false)</li><li><code>WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</code>创建web数据绑定器，该类能够将请求参数值绑定到指定的JavaBean中</li><li><code>bindRequestParameters(binder, webRequest);</code>真正通过web数据绑定器绑定参数值</li><li>根据validate条件(数据校验条件,@Valid注解校验)，进行数据校验并返回校验结果，可在处理器方法中通过BindingResult参数获取</li><li>最终返回绑定好的参数值</li></ol><p>绑定器绑定参数流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServletModelAttributeMethodProcessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindRequestParameters</span><span class="params">(WebDataBinder binder, NativeWebRequest request)</span> </span>&#123;</span><br><span class="line">  ServletRequest servletRequest = request.getNativeRequest(ServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  Assert.state(servletRequest != <span class="keyword">null</span>, <span class="string">"No ServletRequest"</span>);</span><br><span class="line">  ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;</span><br><span class="line">  servletBinder.bind(servletRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletRequestDataBinder.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ServletRequest request)</span> </span>&#123;</span><br><span class="line">  MutablePropertyValues mpvs = <span class="keyword">new</span> ServletRequestParameterPropertyValues(request);</span><br><span class="line">  MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (multipartRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bindMultipart(multipartRequest.getMultiFileMap(), mpvs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(request.getContentType(), <span class="string">"multipart/"</span>)) &#123;</span><br><span class="line">    HttpServletRequest httpServletRequest = WebUtils.getNativeRequest(request, HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (httpServletRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      StandardServletPartUtils.bindParts(httpServletRequest, mpvs, isBindEmptyMultipartFiles());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addBindValues(mpvs, request);</span><br><span class="line">  doBind(mpvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExtendedServletRequestDataBinder.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addBindValues</span><span class="params">(MutablePropertyValues mpvs, ServletRequest request)</span> </span>&#123;</span><br><span class="line">  String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  Map&lt;String, String&gt; uriVars = (Map&lt;String, String&gt;) request.getAttribute(attr);</span><br><span class="line">  <span class="keyword">if</span> (uriVars != <span class="keyword">null</span>) &#123;</span><br><span class="line">    uriVars.forEach((name, value) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (mpvs.contains(name)) <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">else</span> mpvs.addPropertyValue(name, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过ServletModelAttributeMethodProcessor类的bindRequestParameters()方法进行绑定<br>首先通过<code>ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);</code>获取原始的ServletRequest请求对象(参数都在其上)<br>主要调用了<code>servletBinder.bind(servletRequest);</code>实际绑定参数值<br>ServletRequestDataBinder的bind()方法中，首先通过<code>MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);</code>得到所有的kv参数值mpvs，然后通过<code>addBindValues(mpvs, request);</code>方法把uri中的参数值也添加到mpvs中，最终通过<code>doBind(mpvs)</code>最终进行绑定</p></blockquote><p>doBind()方法执行流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebDataBinder.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> </span>&#123;</span><br><span class="line">  checkFieldDefaults(mpvs);</span><br><span class="line">  checkFieldMarkers(mpvs);</span><br><span class="line">  adaptEmptyArrayIndices(mpvs);</span><br><span class="line">  <span class="keyword">super</span>.doBind(mpvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataBinder.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(MutablePropertyValues mpvs)</span> </span>&#123;</span><br><span class="line">  checkAllowedFields(mpvs);</span><br><span class="line">  checkRequiredFields(mpvs);</span><br><span class="line">  applyPropertyValues(mpvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(MutablePropertyValues mpvs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Bind request parameters onto target object.</span></span><br><span class="line">    getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (PropertyBatchUpdateException ex) &#123;</span><br><span class="line">    <span class="comment">// Use bind error processor to create FieldErrors.</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyAccessException pae : ex.getPropertyAccessExceptions()) &#123;</span><br><span class="line">      getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractPropertyAccessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues pvs, <span class="keyword">boolean</span> ignoreUnknown, <span class="keyword">boolean</span> ignoreInvalid)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  List&lt;PropertyValue&gt; propertyValues = (pvs <span class="keyword">instanceof</span> MutablePropertyValues ? ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : propertyValues) &#123;</span><br><span class="line">      <span class="comment">// setPropertyValue may throw any BeansException, which won't be caught</span></span><br><span class="line">      <span class="comment">// here, if there is a critical failure such as no matching field.</span></span><br><span class="line">      <span class="comment">// We can attempt to deal only with less serious exceptions.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        setPropertyValue(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NotWritablePropertyException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ignoreUnknown) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, just ignore it and continue...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... Other catch</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyValue pv)</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">  setPropertyValue(pv.getName(), pv.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNestablePropertyAccessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, @Nullable Object value)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  nestedPa.setPropertyValue(tokens, <span class="keyword">new</span> PropertyValue(propertyName, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tokens.keys != <span class="keyword">null</span>) processKeyedProperty(tokens, pv);</span><br><span class="line">  <span class="keyword">else</span> processLocalProperty(tokens, pv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLocalProperty</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Object oldValue = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object originalValue = pv.getValue();</span><br><span class="line">    Object valueToApply = originalValue;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">        valueToApply = pv.getConvertedValue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        valueToApply = convertForProperty(</span><br><span class="line">            tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());</span><br><span class="line">      &#125;</span><br><span class="line">      pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);</span><br><span class="line">    &#125;</span><br><span class="line">    ph.setValue(valueToApply);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... Other catch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">convertForProperty</span><span class="params">(String propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td)</span> <span class="keyword">throws</span> TypeMismatchException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">convertIfNecessary</span><span class="params">(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class&lt;?&gt; requiredType, @Nullable TypeDescriptor td)</span> <span class="keyword">throws</span> TypeMismatchException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ConverterNotFoundException | IllegalStateException ex) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... Other catch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeConverterDelegate.class</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">convertIfNecessary</span><span class="params">(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class&lt;T&gt; requiredType, @Nullable TypeDescriptor typeDescriptor)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (editor == <span class="keyword">null</span> &amp;&amp; conversionService != <span class="keyword">null</span> &amp;&amp; newValue != <span class="keyword">null</span> &amp;&amp; typeDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);</span><br><span class="line">    <span class="keyword">if</span> (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ConversionFailedException ex) &#123;</span><br><span class="line">        <span class="comment">// fallback to default conversion logic below</span></span><br><span class="line">        conversionAttemptEx = ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先ServletRequestDataBinder类的doBind()方法调用父类WebDataBinder的doBind()方法，在父类的doBind()方法中继续调用父类DataBinder的doBind()方法，最终调用了applyPropertyValues()方法<br>DataBinder的applyPropertyValues()方法调用了AbstractPropertyAccessor类的setPropertyValues()方法，并循环mpvs(请求参数的键值对)并通过setPropertyValue()方法设置属性值<br>AbstractPropertyAccessor类的setPropertyValue()方法在内部调用了其子类AbstractNestablePropertyAccessor类的setPropertyValue()方法，在其中又调用了setPropertyValue()方法，最终调用了processLocalProperty()方法<br>在processLocalProperty()方法中最主要调用了<code>valueToApply = convertForProperty(tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());</code>，在其中又调用了convertIfNecessary()方法，最终在convertIfNecessary()方法中调用了TypeConverterDelegate类的convertIfNecessary()方法，在该方法中调用ConversionService类的canConvert()方法判断是否能转换参数，如果能就通过convert()方法进行转换，至此请求参数交由ConversionService进行处理</p></blockquote><p>在请求中一般由GenericConversionService类进行解析，详细流程分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericConversionService.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  Assert.notNull(targetType, <span class="string">"Target type to convert to cannot be null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  GenericConverter converter = getConverter(sourceType, targetType);</span><br><span class="line">  <span class="keyword">return</span> (converter != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> GenericConverter <span class="title">getConverter</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  ConverterCacheKey key = <span class="keyword">new</span> ConverterCacheKey(sourceType, targetType);</span><br><span class="line">  GenericConverter converter = <span class="keyword">this</span>.converterCache.get(key);</span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (converter != NO_MATCH ? converter : <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  converter = <span class="keyword">this</span>.converters.find(sourceType, targetType);</span><br><span class="line">  <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    converter = getDefaultConverter(sourceType, targetType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.converterCache.put(key, converter);</span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.converterCache.put(key, NO_MATCH);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Converters.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericConverter <span class="title">find</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Search the full type hierarchy</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; sourceCandidates = getClassHierarchy(sourceType.getType());</span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; targetCandidates = getClassHierarchy(targetType.getType());</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br><span class="line">      ConvertiblePair convertiblePair = <span class="keyword">new</span> ConvertiblePair(sourceCandidate, targetCandidate);</span><br><span class="line">      GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  GenericConverter converter = getConverter(sourceType, targetType);</span><br><span class="line">  <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);</span><br><span class="line">    <span class="keyword">return</span> handleResult(sourceType, targetType, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handleConverterNotFound(source, sourceType, targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConversionUtils.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeConverter</span><span class="params">(GenericConverter converter, @Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> converter.convert(source, sourceType, targetType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ConversionFailedException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConversionFailedException(sourceType, targetType, source, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenericConversionService.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> convertNullSource(sourceType, targetType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.converterFactory.getConverter(targetType.getObjectType()).convert(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringToNumberConverterFactory.class</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringToNumber.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NumberUtils.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function">T <span class="title">parseNumber</span><span class="params">(String text, Class&lt;T&gt; targetClass)</span> </span>&#123;</span><br><span class="line">  String trimmed = StringUtils.trimAllWhitespace(text);</span><br><span class="line">  <span class="keyword">if</span> (Byte<span class="class">.<span class="keyword">class</span> </span>== targetClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Short<span class="class">.<span class="keyword">class</span> </span>== targetClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Integer<span class="class">.<span class="keyword">class</span> </span>== targetClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (Long<span class="class">.<span class="keyword">class</span> </span>== targetClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先调用GenericConversionService的canConvert()方法，在其中调用getConverter()方法获取满足条件的converter对象<br>在getConverter()方法中首先去缓存中找如果没有则通过Converters类的find()方法进行寻找<br>在find()方法中会通过类继承规则过滤一部分类，并通过双重循环得到能够转换源类型到目的类型的converter再进行缓存。默认存在的converter如下图所示：<br><img src="GenericConversionService%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4converter%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="GenericConversionService类中默认converter示意图"><br>找到符合的converter后再依次退出函数调用栈，最终调用GenericConversionService类的convert()方法进行转换，首先得到之前缓存的converter，然后使用ConversionUtils类的invokeConverter()方法进行转换<br>在invokeConverter()方法中又调用了GenericConversionService类的重载convert()方法，最终调用了具体的converter工厂的构造方法和具体converter的convert()方法。以String转Number为例：<br>使用StringToNumberConverterFactory类的getConverter()方法新建内部的转换bean————StringToNumber，再使用StringToNumber类的convert()方法实现将String转为Number</p></blockquote></li></ul></li></ul></li></ul></li><li><p>数据响应与内容协商</p><ul><li><p>数据响应</p><ul><li><p>响应Json</p><ul><li><p>依赖：jackson</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-starter-web</span><br><span class="line">|- spring-boot-starter-json</span><br><span class="line">   |- jackson-datatype-jdk8</span><br><span class="line">   |- jackson-datatype-jsr310</span><br><span class="line">   |- jackson-module-parameter-names</span><br></pre></td></tr></table></figure></li><li><p>使用：需要在处理器方法上标注@ResponseBody或在处理器类上标注@RestController</p></li><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHandlerMethodAdapter.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMappingHandlerAdapter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">      invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    webRequest.requestCompleted();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletInvocableHandlerMethod.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">        returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先是流程的回顾，跟请求参数解析的过程一样，都是通过DispatcherServlet的doDispatch()方法进行响应，接着方法调用链依次为AbstractHandlerMethodAdapter类的handle()方法、RequestMappingHandlerAdapter类的handleInternal()方法以及invokeHandlerMethod()方法<br>在invokeHandlerMethod()方法中，首先准备了argumentResolvers请求参数解析器以及returnValueHandlers返回值处理器，SpringBoot默认装配的返回值处理器如下：<br><img src="%E9%BB%98%E8%AE%A4returnValueHandler%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8.png" alt="默认returnValueHandler返回值处理器"><br>返回值处理器接口方法如下：<br><img src="HandlerMethodReturnValueHandler%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="HandlerMethodReturnValueHandler返回值处理器接口示意图"><br>其中supportsReturnType()方法返回是否支持特定的返回值类型，handleReturnValue()方法进行具体的处理逻辑<br>装配好处理器后就调用ServletInvocableHandlerMethod类的invokeAndHandle()方法<br>在invokeAndHandle()方法中invokeForRequest()首先将请求参数解析后，再通过反射调用编写的处理器方法，最后通过<code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code>进行返回值的处理</p></blockquote><p>handleReturnValue()方法处理流程分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMethodReturnValueHandlerComposite.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown return value type: "</span> + returnType.getParameterType().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">selectHandler</span><span class="params">(@Nullable Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);</span><br><span class="line">  <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="keyword">this</span>.returnValueHandlers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody<span class="class">.<span class="keyword">class</span>) ||</span></span><br><span class="line"><span class="class">      <span class="title">returnType</span>.<span class="title">hasMethodAnnotation</span>(<span class="title">ResponseBody</span>.<span class="title">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">  mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">  ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">  ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line">  <span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">  writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在handleReturnValue()方法中首先调用selectHandler()方法查找能处理当前返回值类型的处理器。在查找处理器方法中，根据处理器是否支持返回值类型进行匹配，最终返回相应的处理器，这里以能处理标注@ResponseBody注解的处理器方法为例(RequestResponseBodyMethodProcessor)：<br>由于标注了@ResponseBody注解，因此supportsReturnType()方法返回true，该类能处理<br>然后调用处理器的handleReturnValue()处理返回值，主要是调用writeWithMessageConverters()方法进行处理</p></blockquote><p>writeWithMessageConverters()方法的处理流程解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractMessageConverterMethodProcessor.class</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithMessageConverters</span><span class="params">(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">    body = value.toString();</span><br><span class="line">    valueType = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    targetType = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body = value;</span><br><span class="line">    valueType = getReturnValueType(body, returnType);</span><br><span class="line">    targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isResourceType(value, returnType)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  MediaType selectedMediaType = <span class="keyword">null</span>;</span><br><span class="line">  MediaType contentType = outputMessage.getHeaders().getContentType();</span><br><span class="line">  <span class="keyword">boolean</span> isContentTypePreset = contentType != <span class="keyword">null</span> &amp;&amp; contentType.isConcrete();</span><br><span class="line">  <span class="keyword">if</span> (isContentTypePreset) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    HttpServletRequest request = inputMessage.getServletRequest();</span><br><span class="line">    List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request);</span><br><span class="line">    List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    List&lt;MediaType&gt; mediaTypesToUse = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MediaType requestedType : acceptableTypes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (MediaType producibleType : producibleTypes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">          mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</span><br><span class="line">    <span class="keyword">for</span> (MediaType mediaType : mediaTypesToUse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">        selectedMediaType = mediaType;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;</span><br><span class="line">        selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (selectedMediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">    <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">      GenericHttpMessageConverter genericConverter = (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">          (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ?</span><br><span class="line">          ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :</span><br><span class="line">          converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">        body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),inputMessage, outputMessage);</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Object theBody = body;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在writeWithMessageConverters()方法中，首先获取返回值的数据和类型，然后判断是否是资源类型，如果是，进行一系列操作；否则，从requestHeaders请求头中获取contentType媒体类型，这就涉及到内容协商<br>浏览器默认会以请求头方式告诉服务器它能接受的内容类型，示例如下：<br><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%8F%AF%E6%8E%A5%E5%8F%97%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="浏览器请求可接受的媒体类型示意图"><br>其中q=0.9表示为权重<br>由于当前为首次请求，不存在contentType所以走else块————使用原生ServletRequest通过<code>List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request);</code>获取浏览器可接收的媒体类型，接着通过<code>List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);</code>获取服务器可响应的媒体类型。示例如下：<br><img src="acceptableTypes%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E6%8E%A5%E6%94%B6%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="acceptableTypes浏览器可接收的媒体类型示意图"><br><img src="producibleTypes%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E5%93%8D%E5%BA%94%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="producibleTypes服务器可响应的媒体类型示意图"><br>随后通过两个双层循环进行匹配，最终得到两边都可用的媒体类型，示例如下：<br><img src="%E5%8D%8F%E5%95%86%E5%90%8E%E8%BE%BE%E6%88%90%E4%B8%80%E8%87%B4%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="协商后达成一致的媒体类型示意图"><br>然后通过<code>MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</code>进行权重的排序，最终通过遍历messageConverters消息转换器得到能处理当前返回值数据的消息转换器</p></blockquote><p>消息转换流程分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractMessageConverterMethodProcessor.class中截取的writeWithMessageConverters()方法</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">  GenericHttpMessageConverter genericConverter = (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">      (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ?</span><br><span class="line">      ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :</span><br><span class="line">      converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">    body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),inputMessage, outputMessage);</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object theBody = body;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractGenericHttpMessageConverter.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(@Nullable Type type, Class&lt;?&gt; clazz, @Nullable MediaType mediaType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> canWrite(clazz, mediaType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractJackson2HttpMessageConverter.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, @Nullable MediaType mediaType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!canWrite(mediaType)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  AtomicReference&lt;Throwable&gt; causeRef = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.objectMapper.canSerialize(clazz, causeRef)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  logWarningIfNecessary(clazz, causeRef.get());</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHttpMessageConverter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(@Nullable MediaType mediaType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mediaType == <span class="keyword">null</span> || MediaType.ALL.equalsTypeAndSubtype(mediaType)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (MediaType supportedMediaType : getSupportedMediaTypes()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (supportedMediaType.isCompatibleWith(mediaType)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractGenericHttpMessageConverter.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">final</span> T t, @Nullable <span class="keyword">final</span> Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> HttpHeaders headers = outputMessage.getHeaders();</span><br><span class="line">  addDefaultHeaders(headers, t, contentType);</span><br><span class="line">  <span class="keyword">if</span> (outputMessage <span class="keyword">instanceof</span> StreamingHttpOutputMessage) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    writeInternal(t, type, outputMessage);</span><br><span class="line">    outputMessage.getBody().flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractJackson2HttpMessageConverter.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Object object, @Nullable Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">  MediaType contentType = outputMessage.getHeaders().getContentType();</span><br><span class="line">  JsonEncoding encoding = getJsonEncoding(contentType);</span><br><span class="line">  OutputStream outputStream = StreamUtils.nonClosing(outputMessage.getBody());</span><br><span class="line">  <span class="keyword">try</span> (JsonGenerator generator = <span class="keyword">this</span>.objectMapper.getFactory().createGenerator(outputStream, encoding)) &#123;</span><br><span class="line">    writePrefix(generator, object);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    objectWriter.writeValue(generator, value);</span><br><span class="line">    writeSuffix(generator, object);</span><br><span class="line">    generator.flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catchs ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HttpMessageConverter消息转换器接口介绍如下：<br><img src="HttpMessageConverter%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="HttpMessageConverter消息转换器接口示意图"><br>canRead()和canWrite()方法分别表示是否支持把某个类型以指定媒体类型读入或写出；而read()和write()分别表示具体的读入和写出逻辑；getSupportedMediaTypes()方法则返回支持的媒体类型<br>其中SpringBoot Web环境下默认装载以下消息转换器：<br><img src="%E9%BB%98%E8%AE%A4%E8%A3%85%E8%BD%BD%E7%9A%84MessageConverters%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="默认装载的MessageConverters示意图"><br>接下来以MappingJackson2HttpMessageConverter为例<br>首先调用遍历消息转换器，查看是否支持写出，对于例子来说，依次调用了AbstractGenericHttpMessageConverter类的canWrite()方法、AbstractJackson2HttpMessageConverter类的canWrite()方法以及AbstractHttpMessageConverter类的canWrite()方法<br>在AbstractHttpMessageConverter的canWrite()方法中，由于mediaType为协商后的json格式而且getSupportedMediaTypes()方法返回json格式，因此返回true，最终调用栈返回AbstractJackson2HttpMessageConverter类的canWrite()方法，最终使用jackson的objectMapper查看是否支持序列化(返回true)<br>最终调用AbstractGenericHttpMessageConverter类的write()方法写出数据，首先为响应设置响应头(在本例中为contentType=json)。再查看是否为流响应，发现不是，最终调用AbstractJackson2HttpMessageConverter类的writeInternal()方法进行实际的写操作<br>在writeInternal()方法中基本都是jackson的操作，将返回数据附加在response的流上并返回。结果如下图所示：<br><img src="%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9CServletResponse%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="响应结果ServletResponse示意图"></p></blockquote></li></ul></li></ul></li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p>yaml</p><ul><li><p>简介：YAML是”YAML Ain’t Markup Language”(YAML不是一种标记语言)的递归缩写。在开发这种语言时，YAML的意思其实是————“Yet Another Markup Language”(仍是一种标记语言)。为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名</p></li><li><p>基本语法：</p><ol><li>key: value(kv之间有空格)</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li><li>字符串无需加引号；如果加，’’/“”表示字符串内容会/不会被转义</li></ol></li><li><p>数据类型：</p><ol><li><p>字面量(单个的、不可再分的值,如date、boolean、string、number、null)：<code>k: v</code></p></li><li><p>对象(键值对集合,如map、hash、set、object)：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2,</span> <span class="attr">k3:</span> <span class="string">v3&#125;</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">   <span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">   <span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line">   <span class="attr">k3:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li><li><p>数组(一组按次序排列的值,如array、list、queue)：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">k:</span> <span class="string">[v1,</span> <span class="string">v2,</span> <span class="string">v3]</span></span><br><span class="line"><span class="attr">k:</span> </span><br><span class="line">   <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">v2</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2020/12/12/Middleware/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/12/12/Middleware/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#Redis介绍">Redis介绍</a></li><li><a href="#Redis持久化">Redis持久化</a></li><li><a href="#Redis事务">Redis事务</a></li><li><a href="#Redis消息发布订阅">Redis消息发布订阅</a></li><li><a href="#Redis主从复制">Redis主从复制</a></li><li><a href="#Redis常用配置">Redis常用配置</a></li></ul><a id="more"></a><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><ul><li>NoSQL简介：NoSQL(Not Only SQL)泛指non-relational(非关系型数据库)。NoSQL数据库是为了解决大规模数据集合多重数据种类带来的挑战，特别是超大规模数据的存储。NoSQL数据库的一个显著特点就是去掉了关系数据库的关系型特性，数据之间一旦没有关系，使得扩展性、读写性能都大大提高</li><li>Redis简介：Redis(Remote Dictionary Server：远程字典服务器)是一个用C语言编写的、开源的、基于内存运行并支持持久化的、高性能的NoSQL数据库。也是当前热门的NoSQL数据库之一</li><li>Redis特性：<ol><li>支持数据持久化：Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启时可以再次加载进行使用</li><li>支持多种数据结构：Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li><li>支持数据备份：Redis支持数据的备份(即master-slave模式的数据备份)</li></ol></li><li>Redis安装(6.0.9版本)：<a href="https://blog.csdn.net/qq_26030541/article/details/109448545" target="_blank" rel="noopener">https://blog.csdn.net/qq_26030541/article/details/109448545</a></li><li>Redis应用：<ol><li>为热点数据加速查询(主要场景)：热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询：各类排行榜、各类网站访问统计、公交到站信息、在线人数信息(聊天室、网站)、设备信号等</li><li>时效性信息控制：验证码控制、投票控制等</li><li>分布式数据共享：分布式集群架构中的session分离等</li><li>消息队列</li><li>分布式锁</li></ol></li><li>Redis客户端(Redis-cli)命令简介：<ol><li>连接redis(本机可省去-h参数)：<code>redis-cli -p 6379 -h 127.0.0.1</code></li><li>退出客户端：<code>exit</code>、<code>quit</code></li><li>查看redis服务器统计信息：<code>info [section]</code><blockquote><p>以一种易于解释且易于阅读的格式返回关于Redis服务器的各种信息和统计数值。section用来指定统计信息的部分，值为server、clients、memory等。不加section则返回全部统计信息</p></blockquote></li><li>切换库命令：select [index]<blockquote><p>index默认从0~15，redis默认有16个库</p></blockquote></li><li>查看当前数据库中key的数目：dbsize</li><li>查看当前数据库中有哪些key：keys *</li><li>清空当前库：flushdb</li><li>清空所有库：flushall</li><li>获取redis的配置信息：config get [parameter/*]<blockquote><p>获取运行中Redis服务器的配置参数，获取全部配置可以使用*。参数信息来自redis.conf文件的内容</p></blockquote></li><li>认证：<code>auth &#39;password&#39;</code></li></ol></li><li>Redis的数据结构：<ol><li>string(字符串类型)：字符串类型是Redis中最基本的数据结构，它能存储任何类型的数据，包括二进制数据、序列化后的数据、JSON化的对象甚至是一张图片。最大512M</li><li>list(列表类型)：Redis列表是简单的字符串列表，按照插入顺序排序，元素可以重复。可以添加一个元素到列表的头部(左边)或者尾部(右边)，底层为链表结构</li><li>set(集合类型)：Redis的set是string类型的无序无重复集合</li><li>hash(哈希类型)：Redis的hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</li><li>zset(sorted set,有序集合类型)：Redis有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员。不同的是zset的每个元素都会关联一个分数(分数可以重复)，redis通过分数来为集合中的成员进行从小到大的排序</li></ol></li><li>Redis常用的操作命令：<a href="http://redisdoc.com/" target="_blank" rel="noopener">http://redisdoc.com/</a></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><ul><li>介绍：redis是内存数据库，它把数据存储在内存中。在加快读取速度的同时也对数据安全性产生了新的问题————当redis所在服务器宕机后，数据库里的所有数据将会全部丢失。为了解决这个问题，redis提供了持久化功能————RDB和AOF(Append Only File)</li><li>RDB：<ul><li>介绍：RDB(Redis DataBase)是Redis的默认持久化方案。在指定的时间间隔内执行指定次数的写操作，则会将内存中的数据写入到磁盘中(即在指定目录下生成一个dump.rdb文件,每次同步)。Redis重启时会通过加载dump.rdb文件来恢复数据。适合大规模的数据恢复，但它的数据一致性和完整性较差</li><li>原理：<br>Redis会复制一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序计数器等)数值都和原进程一致，但是一个全新的进程，并作为原进程的子进程来进行持久化<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能<br>如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失</li><li>保存文件介绍：RDB保存的文件是默认为dump.rdb，位置位于Redis的启动目录。Redis每次同步数据到磁盘都会生成一个dump.rdb文件，新的dump.rdb会覆盖旧的dump.rdb文件</li><li>手动保存rdb快照：save命令可用于执行一个同步保存操作————将当前Redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。由于save指令会阻塞所有客户端，因此保存数据库的任务通常由BGSAVE命令异步地执行，而save作为保存数据的最后手段来使用(当负责保存数据的后台子进程不幸出现问题时使用)</li></ul></li><li>AOF：<ul><li>介绍：AOF(Append Only File)，Redis默认不开启。它的出现是为了弥补RDB的不足(数据的不一致性)，它采用日志的形式来记录每个写操作并追加到文件中。Redis重启后会根据日志文件的内容将写指令从前往后执行一次以完成数据的恢复工作</li><li>原理：Redis以日志的形式来记录每个写操作，将执行过的所有写指令记录下来(读操作不记录)，只许追加文件(不可以改写文件)，redis启动之初会读取该文件重新构建数据(根据日志文件的内容将写指令从前往后执行一次以完成数据的恢复工作)</li><li>保存文件介绍：AOF默认保存的文件是appendonly.aof文件，位置位于Redis的启动目录。如果开启了AOF，Redis每次记录写操作都会往appendonly.aof文件追加新的日志内容</li><li>重写机制：<br>AOF采用文件追加方式，那么文件会越来越大。为避免出现该情况，新增了重写机制————当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(先写临时文件最后再rename)————遍历新进程内存中的数据，每条记录有一条Set语句。重写aof文件的操作并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。也可在配置文件中进行配置</li></ul></li><li>总结：<br>Redis需要手动开启AOF持久化方式，AOF的数据完整性比RDB高，但记录内容多了会影响数据恢复的效率<br>关于Redis持久化的使用：若只打算用Redis做缓存可以关闭持久化。若打算使用Redis的持久化，建议RDB和AOF都开启<br>AOF与RDB模式可同时启用，并不冲突。如果AOF是可用的，那Redis启动时将自动加载AOF，这个文件能够提供更好的持久性保障。同时启用时，RDB作为AOF出问题的后备方案</li></ul><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><ul><li><p>介绍：Redis的事务允许在一次单独的步骤中执行一组命令，并且能够保证将一个事务中的所有命令序列化，然后按顺序执行；在一个Redis事务中，要么执行其中的所有命令，要么什么都不执行。即Redis的事务要能够保证序列化和原子性</p></li><li><p>事务的常用命令：</p><ol><li>mutli：<ul><li>功能：用于标记事务块的开始————Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列</li><li>返回值：开启成功返回OK</li></ul></li><li>exec：<ul><li>功能：在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态<blockquote><p>如果在把命令压入队列的过程中报错，则整个队列中的命令都不会执行，执行结果报错<br>如果在压入队列的过程中正常且在执行队列中某一个命令报错，则只会影响该条命令的执行结果，其它命令正常运行<br>当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令；一旦执行了exec命令，之前加的所有watch监控全部取消</p></blockquote></li><li>返回值：一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值<blockquote><p>当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值</p></blockquote></li></ul></li><li>discard<ul><li>功能：清除所有先前在一个事务中放入队列的命令，并且结束事务<blockquote><p>如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控</p></blockquote></li><li>返回值：清除成功返回OK</li></ul></li><li>watch<ul><li>语法：watch key1 [key2、key3、…]</li><li>功能：当某个事务需要按条件执行时，可使用该命令将给定的键设置为受监控的。如果被监控的key值在本事务外被修改时，则本事务所有指令都不会被执行。Watch命令相当于关系型数据库中的乐观锁</li><li>返回值：监控成功返回OK</li></ul></li><li>unwatch<ul><li>功能：清除所有先前为一个事务监控的键<blockquote><p>如果在watch命令之后调用了EXEC或DISCARD命令，那么就无须手动调用UNWATCH命令</p></blockquote></li><li>返回值：清除成功返回OK</li></ul></li></ol></li><li><p>总结：</p><ol><li>单独的隔离操作：事务中的所有命令都会序列化、顺序地执行。事务在执行过程中不会被其它客户端发来的命令请求打断(除非使用watch命令监控某些键)</li><li>不保证事务的原子性：<strong>redis同一个事务中如果一条命令执行失败，其后的命令仍然可能会被执行，redis的事务没有回滚</strong>。Redis已经在系统内部进行功能简化，如此可确保更快的运行速度，因为Redis不需要事务回滚的能力</li></ol></li></ul><h2 id="Redis消息发布订阅"><a href="#Redis消息发布订阅" class="headerlink" title="Redis消息发布订阅"></a>Redis消息发布订阅</h2><ul><li>介绍：Redis发布订阅(pub/sub)是一种消息通信模式————发送者(pub)发送消息，订阅者(sub)接收消息。Redis客户端可以订阅任意数量的频道</li><li>示意图：<br><img src="%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="订阅频道示意图"><br><img src="%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="消息发布示意图"></li><li>订阅相关的常用命令：<ul><li>subscribe：<ul><li>语法：subscribe channel [channel…]</li><li>功能：订阅一个或多个频道的消息</li><li>返回值：订阅的消息</li></ul></li><li>publish：<ul><li>语法：publish channel message</li><li>功能：将信息发送到指定的频道</li><li>返回值：数字————接收到消息订阅者的数量</li></ul></li><li>psubsribe<ul><li>语法：psubscribe pattern [pattern]</li><li>功能：订阅一个或多个符合给定模式的频道，模式可以’*‘作为通配符。例如：news.*匹配所有以news.开头的频道</li><li>返回值：订阅的信息</li></ul></li></ul></li></ul><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><ul><li>介绍：主机数据更新后根据配置和策略，自动同步到从机的master/slave机制。Master以写为主，Slave以读为主</li><li>一主二从：<ul><li>原理：<ol><li>配从(库)不配主(库)</li><li>配从(库)：slaveof masterIP masterPort</li><li>主写从读、读写分离</li><li>主断从待命、从断重新连</li></ol></li><li>搭建：<ol><li>将redis.conf拷贝三份，修改其中的port、pid日志文件和rdb文件名(启动三个redis-server进程)</li><li>分别使用命令启动redis三个服务：<code>./redis-server redis6381.conf &amp;</code></li><li>查看主从信息：<code>info replication</code></li><li>设置主从关系：<code>slaveof 127.0.0.1 6379</code><blockquote><p>另一种方式是修改从库的配置文件，在最后加入<code>slaveof masterIp masterPort</code>；如果主redis设置了密码，从库配置还需设置<code>masteruath masterPassword</code></p></blockquote></li></ol></li><li>特点：<ol><li>全量/增量复制：全量指主redis之前累计的数据在从库上线时会同步过来，增量是主redis新添加的数据</li><li>主写从读、读写分离：从机执行写操作报错</li><li>主机宕机：主机shutdown后，从机保持不变原地待命</li><li>主机宕机后恢复：执行写命令，从机会收到</li><li>从机宕机：主机连接数减少</li><li>从机宕机后恢复：宕机的从机与主机无关，无法获取增量数据，其他从机不受影响<blockquote><p>通过配置文件方式配置会重新与主机建立关系</p></blockquote></li></ol></li></ul></li><li>复制原理：<ul><li>全量复制：<br>slave启动成功连接到master后会发送一个sync命令，master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。在后台进程执行完毕之后，master将传送整个数据文件到slave以完成一次完全同步。slave服务在接收到数据库文件数据后将其存盘并加载到内存中<br>只要是重新连接master，一次完全同步(全量复制)将被自动执行</li><li>增量复制：master将新的所有收集到的修改命令依次传给slave，完成同步</li></ul></li><li>哨兵模式：<ul><li>介绍：从机上位的自动版。Redis提供了哨兵的命令————哨兵命令是一个独立的进程，通过发送命令来监控主从服务器的运行状态，如果检测到master故障了则根据投票数自动将某个slave替换为master。然后通过消息订阅模式通知其它slave，让它们切换主机。然而一个哨兵进程对Redis服务器进行监控可能会出现问题，因此可使用多哨兵进行监控</li></ul></li></ul><h2 id="Redis常用配置"><a href="#Redis常用配置" class="headerlink" title="Redis常用配置"></a>Redis常用配置</h2><ul><li>网络相关：<ol><li>bind：绑定IP地址，其它机器可以通过此IP访问Redis，默认绑定127.0.0.1，也可以修改为本机的IP地址</li><li>port：配置Redis占用的端口，默认是6379</li><li>tcp-keepalive：TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。如果设置为0，则不会进行保活检测</li></ol></li><li>常规配置：<ol><li>loglevel：日志级别，开发阶段可以设置成debug，生产阶段通常设置为notice或者warning</li><li>logfile：指定日志文件名，如果不指定，Redis只进行标准输出。要保证日志文件所在的目录必须存在，文件可以不存在。还要在redis启动时指定所使用的配置文件，否则配置不起作用</li><li>databases：配置Redis数据库的个数，默认是16个</li></ol></li><li>安全配置：<br>requirepass：配置Redis的访问密码。默认不配置密码，即访问不需要密码验证。此配置项需要在protected-mode=yes时起作用。使用密码登录客户端：redis-cli -h ip -p 6379 -a pwd</li><li>RDB配置：<ol><li>save &lt;seconds&gt; &lt;changes&gt;：配置复合的快照触发的条件，即Redis在seconds秒内key改变changes次，Redis把快照内的数据保存到磁盘中一次<blockquote><p>默认的策略是：<br> 1分钟内改变了1万次<br> 或者5分钟内改变了10次<br> 或者15分钟内改变了1次<br> 如果要禁用Redis的持久化功能，则需要把所有的save配置都注释掉</p></blockquote></li><li>stop-writes-on-bgsave-error：当bgsave快照操作出错时停止写数据到磁盘，这样能保证内存数据和磁盘数据的一致性。但如果不在乎这种一致性，要在bgsave快照操作出错时继续写操作，可以配置为no</li><li>rdbcompression：设置存储在磁盘中的快照是否进行压缩————设置为yes时，Redis会采用LZF算法进行压缩；如果不想消耗CPU进行压缩的话，可设置为no来关闭此功能</li><li>rdbchecksum：在存储快照以后，还可使用CRC64算法来进行数据校验，但这样会消耗一定的性能。如果系统比较在意性能的提升，可设置为no来关闭此功能</li><li>dbfilename：Redis持久化数据生成的文件名，默认是dump.rdb，也可以自己配置</li><li>dir：Redis持久化数据生成文件保存的目录，默认是./(即redis的启动目录)，也可以自己配置</li></ol></li><li>AOF配置：<ol><li>appendonly：配置是否开启AOF(yes/no)。默认是no</li><li>appendfilename：AOF保存文件名</li><li>appendfsync：AOF异步持久化策略<blockquote><p>always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但数据完整性比较好(慢但安全)<br> everysec：出厂默认推荐，每秒异步记录一次(默认值)<br> no：不即时同步，由操作系统决定何时同步</p></blockquote></li><li>no-appendfsync-on-rewrite：重写时是否可以运用appendsync(默认no)，可以保证数据的安全性</li><li>auto-aof-rewrite-percentage：设置重写的基准百分比</li><li>auto-aof-rewrite-min-size：设置重写的基准值</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Middleware </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录</title>
      <link href="/2020/12/11/BasicSkill/Algorithm/ProblemRecord/"/>
      <url>/2020/12/11/BasicSkill/Algorithm/ProblemRecord/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#10正则表达式匹配">10正则表达式匹配</a></li><li><a href="#218天际线问题">218天际线问题</a></li><li><a href="#220存在重复元素III">220存在重复元素III</a></li><li><a href="#239滑动窗口最大值">239滑动窗口最大值</a></li><li><a href="#241为运算表达式设计优先级">241为运算表达式设计优先级</a></li><li><a href="#264丑数II">264丑数II</a></li><li><a href="#279完全平方数">279完全平方数</a></li><li><a href="#282给表达式添加运算符">282给表达式添加运算符</a></li><li><a href="#316去除重复字母">316去除重复字母</a></li><li><a href="#321拼接最大数">321拼接最大数</a></li><li><a href="#338比特位计数">338比特位计数</a></li><li><a href="#354俄罗斯套娃信封问题">354俄罗斯套娃信封问题</a></li><li><a href="#395至少有K个重复字符的最长子串">395至少有K个重复字符的最长子串</a></li><li><a href="#493翻转对">493翻转对</a></li><li><a href="#514自由之路">514自由之路</a></li><li><a href="#621任务调度器">621任务调度器</a></li><li><a href="#659分割数组为连续子序列">659分割数组为连续子序列</a></li><li><a href="#803打砖块">803打砖块</a></li><li><a href="#947移除最多的同行或同列石头">947移除最多的同行或同列石头</a></li><li><a href="#959由斜杠划分区域">959由斜杠划分区域</a></li><li><a href="#995K连续位的最小翻转次数">995K连续位的最小翻转次数</a></li><li><a href="#1178猜字谜">1178猜字谜</a></li><li><a href="#1438绝对差不超过限制的最长连续子数组">1438绝对差不超过限制的最长连续子数组</a></li><li><a href="#1489找到最小生成树里的关键边和伪关键边">1489找到最小生成树里的关键边和伪关键边</a></li><li><a href="#1631最小体力消耗路径">1631最小体力消耗路径</a></li><li><a href="#1776车队II">1776车队II</a></li><li><a href="#剑指Offer36二叉搜索树与双向链表">剑指Offer36二叉搜索树与双向链表</a></li><li><a href="#剑指Offer37序列化二叉树">剑指Offer37序列化二叉树</a></li><li><a href="#剑指Offer39数组中出现次数超过一半的数字">剑指Offer39数组中出现次数超过一半的数字</a></li><li><a href="#剑指Offer48最长不含重复字符的子字符串">剑指Offer48最长不含重复字符的子字符串</a></li><li><a href="#剑指Offer51数组中的逆序对">剑指Offer51数组中的逆序对</a></li><li><a href="#剑指Offer56数组中数字出现的次数I">剑指Offer56数组中数字出现的次数I</a></li><li><a href="#剑指Offer56数组中数字出现的次数II">剑指Offer56数组中数字出现的次数II</a></li><li><a href="#剑指Offer60n个骰子的点数">剑指Offer60n个骰子的点数</a></li><li><a href="#剑指Offer62圆圈中最后剩下的数字">剑指Offer62圆圈中最后剩下的数字</a></li></ul><a id="more"></a><h2 id="10正则表达式匹配"><a href="#10正则表达式匹配" class="headerlink" title="10正则表达式匹配"></a>10正则表达式匹配</h2><ul><li><p>问题描述：<br><img src="Question10_p1.png" alt="10正则表达式匹配(1)"><br><img src="Question10_p2.png" alt="10正则表达式匹配(2)"></p></li><li><p>解法：动态规划</p><blockquote><p>首先找出动态转移方程，设dp[i][j]表示串s的前i个字符和串p的前j个字符能否匹配<br>那么很容易想到p[j - 1]除了’<em>‘的情况<br>dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’) ———— 都是字母和’.’匹配任意一个字符的情况<br>如果是’</em>‘，情况有些复杂，但只有两种情况：</p><ol><li>匹配s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配：dp[i][j] = dp[i - 1][j] &amp;&amp; matches(s[i - 1], p[j - 2]) ———— 还有”.*”的组合</li><li>不匹配字符，将该组合扔掉，不再进行匹配：dp[i][j] = dp[i][j - 2]</li></ol></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len_s = s.<span class="built_in">size</span>(), len_p = p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(len_s + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len_p + <span class="number">1</span>))</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> matches = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len_s; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len_p; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配0个</span></span><br><span class="line">        dp[i][j] = dp[i][j] || dp[i][j - <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 匹配一个或多个</span></span><br><span class="line">        <span class="keyword">if</span> (matches(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">          dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches(i, j)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[len_s][len_p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="218天际线问题"><a href="#218天际线问题" class="headerlink" title="218天际线问题"></a>218天际线问题</h2><ul><li><p>问题描述：<br><img src="Question218.png" alt="218天际线问题"></p></li><li><p>解法1：分治法(归并的思想)<br>每次将问题划分成更小的子问题，当问题分解到单个建筑时进行解决。如果单个建筑的输入信息为[x1, x2, h]，那么返回[[x1, h], [x2, 0]]。分解完后，进入归并Merge阶段。归并的关键是从轮廓看去只能看到不同的高度，归并模拟过程如下：</p><blockquote><p>假如有以下划分好的结果：<br>skyline1 = {(1, 11),  (3, 13),  (9, 0),  (12, 7),  (16, 0)}<br>skyline2 = {(14, 3),  (19, 18), (22, 3), (23, 13),  (29, 0)}<br>假设i、j分别表示skyline1、skyline2的当前遍历下标，h1、h2分别代表skyline1、skyline2当前的高度<br>首先比较(1, 11)和(14, 3)，由于1 &lt; 14，选取(1, 11)，h1置为当前大小11，hmax = max(h1, h2) = 11，ans结果集加入(1, 11)，i++<br>之后比较(3, 13)和(14, 3)，h1置为当前大小13，hmax = max(h1, h2) = 13，同理ans结果集加入(3, 13)，i++<br>…<br>直到(16, 0)，此时比较(16, 0)和(14, 3)，14 &lt; 3，选取(14, 3)，h2 = 3。而此时h1 = 7，h2 = 3，hmax = max(h1, h2) = 7，因此结果集加入(14, 7)，由于之前的结果集存在(12, 7)，所以(14, 7)不应该加入结果集，j++<br>比较(16, 0)和(19, 18)，此时16 &lt; 19，选取(16, 0)，h1 = 0。此时h1 = 0，h2 = 3，hmax = max(h1, h2) = 3。因此ans结果集加入(16, 3)，至此skyline1全部遍历完，只需将skyline2的剩余部分加入结果集</p></blockquote><p>代码实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">divideAndConquer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="comment">// 如果left、right一致,相当于只处理单个建筑</span></span><br><span class="line">  <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">    ans.push_back(&#123;buildings[left][<span class="number">0</span>], buildings[left][<span class="number">2</span>]&#125;);</span><br><span class="line">    ans.push_back(&#123;buildings[left][<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到中间下标</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归分治</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; leftAns = divideAndConquer(buildings, left, mid),</span><br><span class="line">        rightAns = divideAndConquer(buildings, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 定义下标和各自的高度变量</span></span><br><span class="line">    <span class="comment">// 每次都需要更新高度信息</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftAns.<span class="built_in">size</span>() &amp;&amp; j &lt; rightAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="comment">// 记录结果</span></span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 如果起始相同,做了简化</span></span><br><span class="line">      <span class="keyword">if</span> (leftAns[i][<span class="number">0</span>] == rightAns[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        h1 = leftAns[i][<span class="number">1</span>], h2 = rightAns[j][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = leftAns[i][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        i++, j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftAns[i][<span class="number">0</span>] &lt; rightAns[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 起始不同,取起始小的作为当前结果开头,取当前的最大高度为当前结果高度</span></span><br><span class="line">        h1 = leftAns[i][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = leftAns[i][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 起始不同,取起始小的作为当前结果开头,取当前的最大高度为当前结果高度</span></span><br><span class="line">        h2 = rightAns[j][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = rightAns[j][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前结果集为空或当前结果与上次高度不同,加入结果集</span></span><br><span class="line">      <span class="keyword">if</span> (ans.empty() || ans.back()[<span class="number">1</span>] != cur[<span class="number">1</span>]) &#123;</span><br><span class="line">        ans.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次加入剩余的结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; leftAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; leftAns.<span class="built_in">size</span>(); ++k) ans.push_back(leftAns[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; rightAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; rightAns.<span class="built_in">size</span>(); ++k) ans.push_back(rightAns[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = buildings.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    ans.push_back(&#123;buildings[<span class="number">0</span>][<span class="number">0</span>], buildings[<span class="number">0</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">    ans.push_back(&#123;buildings[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> divideAndConquer(buildings, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：<br>使用从左向右的扫描，如果遇到左端点，将高度入堆，如果遇到右端点，将高度从堆中删除。还需使用last记录上一个转折点的信息，以示例1为例：</p><blockquote><p>端点排序如下(小技巧：使用正负区别左右端点)：<br>[2, -10], [3, -15], [5, -12], [7, 15], [9, 10], [12, 12], [15, -10], [19, -8], [20, 10], [24, 8]<br>设堆为q(用于存储当前能看到的最大高度,先加入0,用于启动)，结果集为ans，last[0]和last[1]分别保存上一个转折点的下标和高度<br>依次扫描，有：</p><ol><li>q中加入10{0, 10}，从q中取出最大高度为10 != last[1] = 0，last更新(last={2, 10})，ans中加入[2, 10]，此时and为{[2, 10]}</li><li>q中加入15{0, 10, 15}，从q中取出最大高度为15 != last[1] = 10，last更新(last={3, 15})，ans中加入[3, 15]，此时and为{[2, 10], [3, 15]}</li><li>q中加入12{0, 10, 12, 15}，从q中取出最大高度为15 = last[1] = 15，last无需更新，此时前面建筑高度挡住了后面建筑的高度且前面建筑未遇到右端点，ans不改动</li><li>q中减少15{0, 10, 12}，从q中取出最大高度为12 != last[1] = 15，last更新(last={7, 12})，ans中加入[7, 12]，此时and为{[2, 10], [3, 15], [7, 12]}</li><li>q中减少10{0, 12}，从q中取出最大高度为12 = last[1] = 12，last无需更新，ans不改动</li><li>q中减少12{0}，从q中取出最大高度为0 != last[1] = 12，last更新(last={12, 0})，ans中加入[12, 0]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0]}</li><li>q中加入10{0, 10}，从q中取出最大高度为10 != last[1] = 0，last更新(last={15, 10})，ans中加入[15, 10]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10]}</li><li>q中加入8{0, 8, 10}，从q中取出最大高度为10 = last[1] = 10，last无需更新，ans不改动</li><li>q中减少10{0, 8}，从q中取出最大高度为8 != last[1] = 10，last更新(last={20, 8})，ans中加入[20, 8]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8]}</li><li>q中减少8{0}，从q中中取出最大高度为0 != last[1] = 8，last更新(last={24, 0})，ans中加入[24, 0]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]}</li></ol></blockquote><p>代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; all;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;building : buildings) &#123;</span><br><span class="line">    all.insert(&#123;building[<span class="number">0</span>], -building[<span class="number">2</span>]&#125;);</span><br><span class="line">    all.insert(&#123;building[<span class="number">1</span>], building[<span class="number">2</span>]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">height</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;data : all) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.second &lt; <span class="number">0</span>) <span class="built_in">height</span>.insert(-data.second);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">height</span>.erase(<span class="built_in">height</span>.<span class="built_in">find</span>(data.second));</span><br><span class="line">    <span class="keyword">int</span> maxHeight = *<span class="built_in">height</span>.rbegin();</span><br><span class="line">    <span class="keyword">if</span> (last[<span class="number">1</span>] != maxHeight) &#123;</span><br><span class="line">      last[<span class="number">0</span>] = data.first;</span><br><span class="line">      last[<span class="number">1</span>] = maxHeight;</span><br><span class="line">      ans.emplace_back(last);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="220存在重复元素III"><a href="#220存在重复元素III" class="headerlink" title="220存在重复元素III"></a>220存在重复元素III</h2><ul><li><p>题目描述：<br><img src="Question220.png" alt="220存在重复元素III"></p></li><li><p>解法1：搜索树</p><blockquote><p>该题暴力解法会超时，考虑一个长度为k的滑动窗口，每次只需要在插入元素前查看是否在当前滑动窗口中是否存在大于等于nums[i] - t并且小于等于nums[i] + t的元素即可，如果存在则返回true<br>否则，插入元素，并维持滑动窗口的大小<br>在c++中set以及multiset都有一个upper_bound()函数用于找到首个大于某值的数，因此可以使用该方式来加快查找速度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">set</span>.upper_bound((<span class="keyword">long</span>)nums[i] - t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">set</span>.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + t) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>) <span class="built_in">set</span>.erase(<span class="built_in">set</span>.<span class="built_in">find</span>(nums[i - k]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：桶</p><blockquote><p>借鉴桶排序的思想，可以把元素根据t+1分割(此时最大相差t)<br>如果同在一个桶内，就相当于满足条件<br>如果不再同一个桶内，那就需要找前一个桶和后一个桶，检验是否绝对值相差t<br>比如t为3，由于除的特性，-1 / 3 = 0，但是应该划分到-1，因此需要特殊求值，类似于getId函数<br>当桶里的所有元素总数等于k+1，那么就需要把最前添加的元素从桶中删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num &lt; <span class="number">0</span> ? (num + <span class="number">1</span>) / w - <span class="number">1</span> : num / w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> curId = getId(nums[i], w);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>.count(curId)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">map</span>.<span class="built_in">find</span>(curId - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; nums[i] - iter-&gt;second &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    iter = <span class="built_in">map</span>.<span class="built_in">find</span>(curId + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; iter-&gt;second - nums[i] &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">map</span>.emplace(curId, nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>) <span class="built_in">map</span>.erase(<span class="built_in">map</span>.<span class="built_in">find</span>(getId(nums[i - k], w)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="239滑动窗口最大值"><a href="#239滑动窗口最大值" class="headerlink" title="239滑动窗口最大值"></a>239滑动窗口最大值</h2><ul><li><p>题目描述：<br><img src="Question239.png" alt="239滑动窗口最大值"></p></li><li><p>解法1：优先队列</p><blockquote><p>很容易就想到使用大顶堆来实现，但每次都需要删除滑出的数，加入新的数，但大顶堆不支持随机删除，只支持删除顶部元素。因此转而想到使用multiset(多重set)完成，但由于需要较多的删除、添加操作，会导致较低的效率<br>有一种更简单的做法，保留使用堆(priority_queue)的方式，但是延迟删除————即如果当前滑出的数如果是最大数才删除，因为如果滑出的数过小，就是一个耗时的操作，没有必要</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">if</span> (k == len) <span class="keyword">return</span> &#123;*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())&#125;;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; window;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    window.emplace(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  ans.reserve(len - k + <span class="number">1</span>);</span><br><span class="line">  ans.push_back(window.top().first);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">    window.emplace(nums[i], i);</span><br><span class="line">    <span class="keyword">while</span> (window.top().second &lt;= i - k) window.pop();</span><br><span class="line">    ans.push_back(window.top().first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：单调队列</p><blockquote><p>优先队列方式其实也多增加了无用的数据，因为如果后面的数比前面的数大，其实一个区间内的最大只是由后面的数决定的<br>因此可以采用单调队列的方式，由于可能会有重复值的原因，因此采取记录下标值的方式。总体规律是单调队列中index小的值大，每次如果数值小于等于队尾的值，可以添加到队尾————因为可能会把前面的都熬死；如果大于队尾的值，那么就可以消灭任何小于等于其的数值————因为它寿命大而且可以替代区间内的最大值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">if</span> (k == len) <span class="keyword">return</span> &#123;*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())&#125;;</span><br><span class="line">  <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dQueue;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dQueue.empty() || nums[dQueue.back()] &gt; nums[i]) dQueue.push_back(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!dQueue.empty() &amp;&amp; nums[dQueue.back()] &lt;= nums[i]) dQueue.pop_back();</span><br><span class="line">      dQueue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(len - k + <span class="number">1</span>);</span><br><span class="line">  ans.push_back(nums[dQueue.front()]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dQueue.front() &lt;= i - k) dQueue.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (dQueue.empty() || nums[dQueue.back()] &gt; nums[i]) dQueue.push_back(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!dQueue.empty() &amp;&amp; nums[dQueue.back()] &lt;= nums[i]) dQueue.pop_back();</span><br><span class="line">      dQueue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(nums[dQueue.front()]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="241为运算表达式设计优先级"><a href="#241为运算表达式设计优先级" class="headerlink" title="241为运算表达式设计优先级"></a>241为运算表达式设计优先级</h2><ul><li><p>题目描述：<br><img src="Question241.png" alt="241为运算表达式设计优先级"></p></li><li><p>解法1：递归 + 记忆化</p><blockquote><p>每次都把字符串根据中间的运算符拆分成两半，再递归计算左右部分的数值，再在外部根据左右计算出的数值进行组合得到可能的结果<br>例如：2*3-4*5<br>依次拆分成2以及3-4*5、2*3以及4*5、2*3-4以及5<br>以第一个拆分为例，首先2直接得出<br>接着拆分3-4*5，有3以及4*5、3-4以及5<br>最终3-4*5就有两种结果，-17以及-5<br>最终与2结合，得到-34和-10</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;left, <span class="keyword">const</span> <span class="keyword">int</span> &amp;right, <span class="keyword">const</span> <span class="keyword">char</span> &amp;op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideAndConcur</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;input, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;memo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (memo.<span class="built_in">find</span>(input) != memo.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> len = input.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">bool</span> hasOp = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOperator(input[i])) &#123;</span><br><span class="line">      hasOp = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">string</span> left = input.substr(<span class="number">0</span>, i), right = input.substr(i + <span class="number">1</span>, len - i - <span class="number">1</span>);</span><br><span class="line">      divideAndConcur(left, memo);</span><br><span class="line">      divideAndConcur(right, memo);</span><br><span class="line">      <span class="keyword">auto</span> iter = memo.<span class="built_in">find</span>(input);</span><br><span class="line">      <span class="keyword">if</span> (iter == memo.<span class="built_in">end</span>()) memo.emplace(input, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;l : memo[left]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;r : memo[right]) &#123;</span><br><span class="line">          memo[input].push_back(calculate(l, r, input[i]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!hasOp) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = atoi(input.c_str());</span><br><span class="line">    memo.insert(&#123;input, &#123;data&#125;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">  divideAndConcur(input, memo);</span><br><span class="line">  <span class="keyword">return</span> memo[input];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：动态规划</p><blockquote><p>动态规划方式十分巧妙，首先把所有的数字和操作符都识别出来并存储<br>例如：2*3-4*5<br>那么数字为2、3、4、5，操作符为*、-、*<br>接着定义dp[i][j]为从第i个到第j个数字所构成的结果<br>按照定义，则初始状态<code>dp[i][i] = nums[i]</code><br>动态转移方程为<code>dp[i][j] = dp[i][s] op[s] dp[s+1][j]</code><br>方程表示dp[i][j]的结果为dp[i][s]集合中元素与dp[s+1][j]集合中元素通过操作符op[s]产生的结果集合</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;left, <span class="keyword">const</span> <span class="keyword">int</span> &amp;right, <span class="keyword">const</span> <span class="keyword">char</span> &amp;op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ops;</span><br><span class="line">  <span class="keyword">int</span> lastOpIndex = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOperator(input[i])) &#123;</span><br><span class="line">      ops.push_back(input[i]);</span><br><span class="line">      <span class="built_in">string</span> num = input.substr(lastOpIndex + <span class="number">1</span>, i - lastOpIndex);</span><br><span class="line">      nums.push_back(atoi(num.c_str()));</span><br><span class="line">      lastOpIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一个数字的获取</span></span><br><span class="line">  <span class="built_in">string</span> num = input.substr(lastOpIndex + <span class="number">1</span>, input.<span class="built_in">size</span>() - lastOpIndex);</span><br><span class="line">  nums.push_back(atoi(num.c_str()));</span><br><span class="line">  <span class="comment">// 没有操作符</span></span><br><span class="line">  <span class="keyword">if</span> (lastOpIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">size</span>))</span></span>;</span><br><span class="line">  <span class="comment">// 设置dp[i][i]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">    dp[i][i].push_back(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数字数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> N = <span class="number">2</span>; N &lt;= <span class="built_in">size</span>; ++N) &#123;</span><br><span class="line">    <span class="comment">// 起始下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">// 结束下标</span></span><br><span class="line">      <span class="keyword">int</span> j = i + N - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= <span class="built_in">size</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 迭代的下标</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = i; s &lt; j; ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;lNum : dp[i][s]) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;rNum : dp[s + <span class="number">1</span>][j]) &#123;</span><br><span class="line">            dp[i][j].push_back(calculate(lNum, rNum, ops[s]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="264丑数II"><a href="#264丑数II" class="headerlink" title="264丑数II"></a>264丑数II</h2><ul><li><p>题目描述：<br><img src="Question264.png" alt="264丑数II"></p></li><li><p>解法：动态规划</p><blockquote><p>实际上更容易想到的方法是使用堆排序，把每次得到的数进行排序后，再得到最后的结果，但这种方法有一个巨大的问题————乘数的差距越来越大，后面有很大的数据空隙，很难匹配上，需要求得更多的数来弥合，或者对更多数先求2的乘数<br>还有一种更简单的方式————三指针法，记录当前指向因子分别为2、3和5的指针，之后每次求出这三个指针指向的丑数乘各自因子，取最小值，再更新等于最小值的指针为更大的丑数。这样每次不需要进行额外的计算，而且不用担心排序的问题</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNum</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> index_2 = <span class="number">0</span>, index_3 = <span class="number">0</span>, index_5 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num_2 = uglyNum[index_2] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = uglyNum[index_3] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> num_5 = uglyNum[index_5] * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> min_num = <span class="built_in">min</span>(num_2, <span class="built_in">min</span>(num_3, num_5));</span><br><span class="line">    uglyNum[++index] = min_num;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_2) index_2++;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_3) index_3++;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_5) index_5++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uglyNum[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="279完全平方数"><a href="#279完全平方数" class="headerlink" title="279完全平方数"></a>279完全平方数</h2><ul><li><p>题目描述：<br><img src="Question279.png" alt="279完全平方数"></p></li><li><p>解法：动态规划</p><blockquote><p>如果采用贪心法，每次减去最大的平方数，会导致一部分的错误结果————如12=9+1+1+1，而答案为12=4+4+4；采用动态规划时，可以利用上一次的结果进行迭代求解<br>dp[i] = min{dp[i-k] + 1} (k是平方数且i-k &gt;= 0)</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="282给表达式添加运算符"><a href="#282给表达式添加运算符" class="headerlink" title="282给表达式添加运算符"></a>282给表达式添加运算符</h2><ul><li><p>题目描述：<br><img src="Question282.png" alt="282给表达式添加运算符"></p></li><li><p>解法：回溯法</p><blockquote><p>由于没有直接的关联，只能使用回溯法遍历整个有效的搜索空间<br>由于’*‘的优先级与’+’与’-‘的优先级不同，最主要是解决该问题<br>比如235，2+3*5，当前的值(5,2+3)和上一次的操作数3<br>恢复结果为(5-3+3*5=17)，因此需要保留当前的结果和上一次的操作数<br>再考虑连乘的情况，5+2*3*5；计算第一个’*‘时，当前值(7)，上次操作数(2)，此时恢复为(7-2+2*3=11)；但在计算第二个’*‘时，当前值(11)，上次操作数(2)，此时的结果无法恢复，所以乘法需要单独计算上一次的操作数————将整个连乘的结果当前上一次的操作数，此时第二次的情况变为当前值(11)，上次操作数(6)，恢复结果(11-6+6*5=35)<br>其次，由于如果每次传递string的值，复制的开销过大，因此可以使用引用传递，每次改变后在恢复回原样以加速(resize()恢复长度)</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;num, <span class="keyword">const</span> <span class="keyword">int</span> &amp;target, <span class="keyword">int</span> curIndex, <span class="keyword">long</span> curNum, <span class="keyword">long</span> lastNum, <span class="built_in">string</span> &amp;curStr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 递归出口,遍历完所有数字字符</span></span><br><span class="line">  <span class="keyword">if</span> (curIndex == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curNum == target) ans.push_back(curStr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历可能的截取数字</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = curIndex; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 截取数字</span></span><br><span class="line">    <span class="built_in">string</span> tempStr = num.substr(curIndex, i - curIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> tempNum = stol(tempStr);</span><br><span class="line">    <span class="comment">// 获取当前串长,用于恢复</span></span><br><span class="line">    <span class="keyword">int</span> len = curStr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (curIndex == <span class="number">0</span>) &#123; <span class="comment">// 刚开始</span></span><br><span class="line">      curStr += tempStr;</span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, tempNum, tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 考虑符号</span></span><br><span class="line">      <span class="comment">// +</span></span><br><span class="line">      curStr += <span class="string">'+'</span> + tempStr;</span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum + tempNum, tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -</span></span><br><span class="line">      curStr += <span class="string">'-'</span> + tempStr;</span><br><span class="line">      <span class="comment">// 将'-'转变为'+',形式统一</span></span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum - tempNum, -tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// *</span></span><br><span class="line">      curStr += <span class="string">'*'</span> + tempStr;</span><br><span class="line">      <span class="comment">// 如果是'*'需要将乘的结果作为更大的当前值(而不是当前值),这用于后面可能接着的'*'</span></span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum - lastNum + lastNum * tempNum, lastNum * tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不允许以0开头的多位数</span></span><br><span class="line">    <span class="keyword">if</span> (!tempNum) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">addOperators</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">string</span> curStr;</span><br><span class="line">  backTrack(num, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, curStr);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="316去除重复字母"><a href="#316去除重复字母" class="headerlink" title="316去除重复字母"></a>316去除重复字母</h2><ul><li><p>题目描述：<br><img src="Question316.png" alt="316去除重复字母"></p></li><li><p>解法：贪心 + 单调栈</p><blockquote><p>先统计字母最后出现的下标，这用于确定是否还会碰到<br>接着利用贪心法，遍历字符，如果已有这个字符则跳过<br>否则判断当前栈是否非空，如果非空再判断当前字符是否字典序小于栈顶<br>如果小于栈顶，并且目前处于栈顶的字符后面还能遇到，那么就可以弹出栈顶<br>最终将字符压栈，最终结果就是栈中的顺序<br>可采用二进制移位技巧和利用string代替stack进行优化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lastIndex</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>(), bitmask = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span> ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    lastIndex[s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="comment">// 如果存在一样的字符,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (bitmask &amp; (<span class="number">1</span> &lt;&lt; (s[i] - <span class="string">'a'</span>))) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 非空 栈顶字典序大 以后还能遇到栈顶字符</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.empty() &amp;&amp; ans.back() &gt; s[i] &amp;&amp; lastIndex[ans.back() - <span class="string">'a'</span>] &gt; i) &#123;</span><br><span class="line">      <span class="comment">// 删除字符标记</span></span><br><span class="line">      <span class="keyword">int</span> mask = INT_MAX - (<span class="number">1</span> &lt;&lt; (ans.back() - <span class="string">'a'</span>));</span><br><span class="line">      bitmask &amp;= mask;</span><br><span class="line">      ans.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(s[i]);</span><br><span class="line">    <span class="comment">// 添加字符标记</span></span><br><span class="line">    bitmask |= <span class="number">1</span> &lt;&lt; (s[i] - <span class="string">'a'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="321拼接最大数"><a href="#321拼接最大数" class="headerlink" title="321拼接最大数"></a>321拼接最大数</h2><ul><li><p>题目描述：<br><img src="Question321.png" alt="321拼接最大数"></p></li><li><p>解法：单调栈</p><blockquote><p>由于结果由两个序列给出，因此将k个数分隔，一部分由m给出，另一部分由n给出<br>这样就可以分别对m和n利用单调栈求出指定长度的最优解<br>接着按照能使结果最优的方式合并得到的两个序列即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">makeSubSequence</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> targetLen)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 特殊情况处理</span></span><br><span class="line">  <span class="keyword">if</span> (!targetLen) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (targetLen == <span class="number">1</span>) <span class="keyword">return</span> &#123; *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) &#125;;</span><br><span class="line">  <span class="keyword">if</span> (targetLen == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(targetLen);</span><br><span class="line">  <span class="comment">// 单调栈</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 如果非空,并且遍历值大于最后值,并且删除后长度符合targetLen</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.empty() &amp;&amp; ans.back() &lt; nums[i] &amp;&amp; ans.<span class="built_in">size</span>() + nums.<span class="built_in">size</span>() - i &gt; targetLen) ans.pop_back();</span><br><span class="line">    <span class="comment">// 未满则添加</span></span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; targetLen) ans.push_back(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence1, <span class="keyword">int</span> index1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence2, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = subsequence1.<span class="built_in">size</span>(), y = subsequence2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (index1 &lt; x &amp;&amp; index2 &lt; y) &#123;</span><br><span class="line">    <span class="keyword">int</span> difference = subsequence1[index1] - subsequence2[index2];</span><br><span class="line">    <span class="keyword">if</span> (difference != <span class="number">0</span>) <span class="keyword">return</span> difference;</span><br><span class="line">    index1++;</span><br><span class="line">    index2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果都相同,返回长的</span></span><br><span class="line">  <span class="keyword">return</span> (x - index1) - (y - index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = subsequence1.<span class="built_in">size</span>(), y = subsequence2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span> subsequence2;</span><br><span class="line">  <span class="keyword">if</span> (!y) <span class="keyword">return</span> subsequence1;</span><br><span class="line">  <span class="keyword">int</span> mergeLength = x + y;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(mergeLength)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mergeLength; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compare(subsequence1, index1, subsequence2, index2) &gt; <span class="number">0</span>) merged[i] = subsequence1[index1++];</span><br><span class="line">    <span class="keyword">else</span> merged[i] = subsequence2[index2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">int</span> len1 = nums1.<span class="built_in">size</span>(), len2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    <span class="comment">// 不满足长度,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; i || len2 &lt; k - i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l = makeSubSequence(nums1, i);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r = makeSubSequence(nums2, k - i);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merged = merge(l, r);</span><br><span class="line">    <span class="keyword">if</span> (compare(merged, <span class="number">0</span>, ans, <span class="number">0</span>) &gt; <span class="number">0</span>) ans = merged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="338比特位计数"><a href="#338比特位计数" class="headerlink" title="338比特位计数"></a>338比特位计数</h2><ul><li><p>题目描述：<br><img src="Question338.png" alt="338比特位计数"></p></li><li><p>解法：动态规划</p><blockquote><p>考虑最高位的情况，如果一个数A有n个1的bit位，那么在A的bitSet最高位置1(第一个不是1的置)，那么B就有n+1个1的bit位<br>dp[0] = 0<br>dp[1] = 1(2^0)<br>dp[2] = 1(2^1)<br>dp[3] = dp[1] + 1 = 2<br>dp[4] = 1(2^2)<br>dp[5] = dp[1] + 1 = 2<br>因此找到规律有，2^n数bit位为1的共有一位，而如果满足该条件，则A&amp;(A - 1)为0，每次记录最高位的值，用于找到差<br><code>dp[i] = dp[i - highBitNum] + 1(dp[0] = 0)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="comment">// 为2^n</span></span><br><span class="line">    <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      highBit = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="354俄罗斯套娃信封问题"><a href="#354俄罗斯套娃信封问题" class="headerlink" title="354俄罗斯套娃信封问题"></a>354俄罗斯套娃信封问题</h2><ul><li><p>题目描述：<br><img src="Question354.png" alt="354俄罗斯套娃信封问题"></p></li><li><p>解法1：朴素动态规划</p><blockquote><p>由于需要在二维数组上组成一个递增的序列(严格每维大于)，因此需要固定一维(先按第一维升序)<br>如果固定了一个维，那么再看第二维，由于如果第二维降序，那么原题就转化成了求第二维数组的最长递增子序列(如果是升序,那么会因为第一维相同而导致不能确定)<br>接着就可以列出动态转移方程：<br><code>dp[0] = 1</code><br><code>dp[i] = dp[j] + 1 (如果nums[i] &gt; nums[j],0 &lt;= j &lt; i)</code><br>接着返回dp中的最大值即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;envelopes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = envelopes.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">  sort(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[<span class="number">0</span>] != v2[<span class="number">0</span>]) <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>] &gt; v2[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *max_element(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：二分法的动态规划</p><blockquote><p>设dp表示序列前i个元素组成的最长严格递增子序列，假设dp长度为j，那么dp[j - 1]表示末尾元素的最小值<br>进行遍历时，考虑当前元素num<br>如果num大于dp的末尾元素，那么num可以接在dp之后形成更长的严格递增子序列<br>否则找出dp中比num严格小的最大元素dp[j0]，则dp[j0] &lt; num &lt;= dp[j0 + 1]，那么dp[j0 + 1]可以替换为num————如果不在末尾，可以任意替换，因为不起决定作用；如果在末尾，那么可以减少末尾的值，可能导致后面的dp增长</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = envelopes.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  sort(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[<span class="number">0</span>] != v2[<span class="number">0</span>]) <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>] &gt; v2[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = &#123;envelopes[<span class="number">0</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (num &gt; dp.back()) dp.push_back(num);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = lower_bound(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), num);</span><br><span class="line">      *it = num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="395至少有K个重复字符的最长子串"><a href="#395至少有K个重复字符的最长子串" class="headerlink" title="395至少有K个重复字符的最长子串"></a>395至少有K个重复字符的最长子串</h2><ul><li><p>题目描述：<br><img src="Question395.png" alt="395至少有K个重复字符的最长子串"></p></li><li><p>解法1：分治</p><blockquote><p>一个思想是找到数目小于K个的字符，然后通过该字符将原字符串进行分割<br>分割后的子字符串再如此，符合条件的递归出口为字符串中每个字符的数目都大于K</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果字符串长度小于k,没有必要继续搜索</span></span><br><span class="line">  <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 统计每个字符的个数</span></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cNums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">    cNums[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找第一个不符合个数的字符</span></span><br><span class="line">  <span class="keyword">char</span> targetLessChar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cNums[i] &amp;&amp; cNums[i] &lt; k) targetLessChar = i + <span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果找不到,说明每个字母都大于等于K个,直接返回当前字符串长度</span></span><br><span class="line">  <span class="keyword">if</span> (!targetLessChar) <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 记录原始left</span></span><br><span class="line">    <span class="keyword">int</span> beforeLeft = left;</span><br><span class="line">    <span class="comment">// 查找不符合字符的出现位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == targetLessChar) &#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        ans = <span class="built_in">max</span>(dfs(s, left, i - <span class="number">1</span>, k), ans);</span><br><span class="line">        <span class="comment">// left移动</span></span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原始left没有改动,说明这一段没有出现不符合字符,应该直接递归,并退出</span></span><br><span class="line">    <span class="keyword">if</span> (left == beforeLeft) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(dfs(s, left, right, k), ans);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="keyword">return</span> dfs(s, <span class="number">0</span>, len - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：滑动窗口</p><blockquote><p>可以列举最长子串的字符种类数目，最小为1，最大为26<br>对于给定的字符种类数目，维护滑动窗口的左右边界l/r、滑动窗口内部每个字符出现的次数cNums，当前窗口内小于k数值的字符种类计数器less、窗口内的字符种类数目total<br>每次窗口向右滑动一步，如果当前字符在cNums中为0，那么total自增————表明新出现一种字符，且less自增————表明又有一种字符数目小于k；如果当前字符在cNums中为k-1，那么less自减————表明少了一种数目小于k的字符<br>接着，查看当前total是否大于指定的字符种类数目，如果大于，左边界向右移动，并与向右移动一样对数据做出改变<br>最终如果less为0，说明当前符合，计算当前子符串长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 罗列字符种类数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 统计窗口内字符数目</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cNums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 总共种类、少于k的种类、左边界、有边界</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, less = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">      <span class="keyword">int</span> rIndex = s[r] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="comment">// 如果新出现一种字符</span></span><br><span class="line">      <span class="keyword">if</span> (!cNums[rIndex]) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        less++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 字符数目达到k</span></span><br><span class="line">      <span class="keyword">if</span> (cNums[rIndex] == k - <span class="number">1</span>) &#123;</span><br><span class="line">        less--;</span><br><span class="line">      &#125;</span><br><span class="line">      cNums[rIndex]++;</span><br><span class="line">      <span class="comment">// 种类超过规定</span></span><br><span class="line">      <span class="keyword">while</span> (total &gt; i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lIndex = s[l] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">// 少一种字符</span></span><br><span class="line">        <span class="keyword">if</span> (cNums[lIndex] == <span class="number">1</span>) &#123;</span><br><span class="line">          less--;</span><br><span class="line">          total--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一种字符数目少于k</span></span><br><span class="line">        <span class="keyword">if</span> (cNums[lIndex] == k) &#123;</span><br><span class="line">          less++;</span><br><span class="line">        &#125;</span><br><span class="line">        cNums[lIndex]--;</span><br><span class="line">        l++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 符合条件,更新结果</span></span><br><span class="line">      <span class="keyword">if</span> (!less) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="493翻转对"><a href="#493翻转对" class="headerlink" title="493翻转对"></a>493翻转对</h2><ul><li><p>题目描述：<br><img src="Question493.png" alt="493翻转对"></p></li><li><p>解法：</p><blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h2 id="514自由之路"><a href="#514自由之路" class="headerlink" title="514自由之路"></a>514自由之路</h2><ul><li><p>题目描述：<br><img src="Question514.png" alt="514自由之路"></p></li><li><p>解题思路：</p><ol><li>每次转到指定位置后还需要按一次按钮，那么结果还需要加上key的长度</li><li>转动到指定位置有两种方向，单考虑转到指定位置的话(不考虑再按一次的触发)；假设curRingIndex表示当前转动前的位置下标，curKeyIndex表示转动到的指定位置的下标：<br> <img src="Question514_p1.png" alt="转动示意图"><ol><li><code>l1 = abs(curRingIndex - curKeyIndex)</code></li><li><code>l2 = ring.length() - l1</code></li></ol></li><li>每次转动后curKeyIndex变为下一次curRingIndex，即从新指定位置开始转动</li><li>截止条件是<code>curKeyIndex = key.length()</code>，即当前所有key的字符都被转到12点方向过</li></ol></li><li><p>解法1：动态规划方式<br>记录每次从当前位置转动到顺序读取到的key字符的位置所花费的转动次数，最终返回到达最后key字符的转动次数的最小值<br><img src="Question514_p2.png" alt="示例的手工动态规划示意图"></p><p>动态转移方程如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认dp中元素为INT_MAX</span></span><br><span class="line"><span class="comment">// 得到第一步的转动次数</span></span><br><span class="line">dp[<span class="number">0</span>][i] = (ring[i] == key[<span class="number">0</span>]) ? <span class="built_in">min</span>(i, m - i);</span><br><span class="line"><span class="comment">// 如果dp[i - 1][k]不为INT_MAX,即上一步(第i步)能转动到ring的第k个字符,且为到第k个字符的最小值</span></span><br><span class="line"><span class="comment">// 当前为第i+1步,将要走到第j个字符</span></span><br><span class="line"><span class="comment">// 最小距离为已知的最小值与当前走法的较小值</span></span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][k] + <span class="built_in">min</span>(<span class="built_in">abs</span>(j - k), m - <span class="built_in">abs</span>(j - k)));</span><br></pre></td></tr></table></figure><p>最终代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, INT_MAX))</span></span>;</span><br><span class="line">  <span class="comment">// 遍历首字符匹配的下标集合</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[<span class="number">0</span>] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">    <span class="comment">// 走第一步</span></span><br><span class="line">    dp[<span class="number">0</span>][index] = <span class="built_in">min</span>(index, m - index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 遍历下一步字符的下标集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果第i步不可达j,跳过</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 当前走第i+1步的最小步数</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="built_in">min</span>(<span class="built_in">abs</span>(index - j), m - <span class="built_in">abs</span>(index - j));</span><br><span class="line">        <span class="comment">// 记录走i+1步的最小步数</span></span><br><span class="line">        dp[i][index] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + steps, dp[i][index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> *min_element(dp[n - <span class="number">1</span>].<span class="built_in">begin</span>(), dp[n - <span class="number">1</span>].<span class="built_in">end</span>()) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：动态规划方式，使用滚动数组的方式，节省空间</p><blockquote><p>根据方式一，发现第i+1步只与第i步的位置有关，因此只需保留两个数组用于保存上一步的最小步数和当前步的最小步数即可</p></blockquote><p>最终代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;int&gt; last(m), current(m, INT_MAX);</span><br><span class="line">  <span class="comment">// 遍历首字符匹配的下标集合</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[<span class="number">0</span>] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">    <span class="comment">// 走第一步</span></span><br><span class="line">    current[index] = <span class="built_in">min</span>(index, m - index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    last = current;</span><br><span class="line">    <span class="built_in">fill</span>(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>(), INT_MAX);</span><br><span class="line">    <span class="comment">// 遍历下一步字符的下标集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果第i步不可达j,跳过</span></span><br><span class="line">        <span class="keyword">if</span> (last[j] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 当前走第i+1步的最小步数</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="built_in">min</span>(<span class="built_in">abs</span>(index - j), m - <span class="built_in">abs</span>(index - j));</span><br><span class="line">        <span class="comment">// 记录走i+1步的最小步数</span></span><br><span class="line">        current[index] = <span class="built_in">min</span>(last[j] + steps, current[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> *min_element(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>()) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法3：dfs + 记忆化方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录从ring的第i个字符转动到key的第j个字符的最小转动次数</span></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  curRingIndex：当前处于ring转盘的第几个字符</span></span><br><span class="line"><span class="comment">  curKeyIndex：当前需匹配的key的第几个字符</span></span><br><span class="line"><span class="comment">  memo：记录表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;)&gt; dfs = [&amp;, m, pos, key](<span class="keyword">int</span> curRingIndex, <span class="keyword">int</span> curKeyIndex, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;memo) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (curKeyIndex == key.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已记录过,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (memo[curRingIndex][curKeyIndex] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[curRingIndex][curKeyIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录此次转动的最小次数</span></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="comment">// 遍历ring中当前key对应字符的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[curKeyIndex] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">int</span> d1 = <span class="built_in">abs</span>(curRingIndex - index);</span><br><span class="line">      <span class="keyword">int</span> d2 = m - d1;</span><br><span class="line">      <span class="comment">// 此次转动的最小次数</span></span><br><span class="line">      <span class="comment">// 当前转动成功后,curRingIndex自动变为index,curKeyIndex移动到下一个</span></span><br><span class="line">      res = <span class="built_in">min</span>(res, <span class="built_in">min</span>(d1, d2) + dfs(index, curKeyIndex + <span class="number">1</span>, memo));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新记录表</span></span><br><span class="line">    memo[curRingIndex][curKeyIndex] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> n + dfs(<span class="number">0</span>, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="621任务调度器"><a href="#621任务调度器" class="headerlink" title="621任务调度器"></a>621任务调度器</h2><ul><li><p>题目描述：<br><img src="Question621_p1.png" alt="621任务调度器(1)"><br><img src="Question621_p2.png" alt="621任务调度器(2)"></p></li><li><p>解法1：模拟</p><blockquote><p>首先就容易想到的就是采用模拟的方式，首先应该每次优先考虑做次数多的工作(因为冷却的存在,替换着做比不替换更好)<br>因此首先要统计每种工作的次数；接着每次要找到未在冷却期间的剩余次数最多的那个工作，此时时间自增1<br>如果找不到未在冷却期间的工作，那么需要跳跃到最小的下一个可继续工作时间，因此需要记录每种工作下一次可以立马执行的时间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = tasks.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 两种特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; taskNums;</span><br><span class="line">  <span class="comment">// 记录次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;task : tasks) &#123;</span><br><span class="line">    taskNums[task]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> taskTypes = taskNums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;pair&lt;int, int&gt;&gt; taskInfo(taskTypes);</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化下一次可以执行的时间以及次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;taskNum : taskNums) &#123;</span><br><span class="line">    taskInfo[index].first = <span class="number">1</span>;</span><br><span class="line">    taskInfo[index++].second = taskNum.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> curTime = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (len) &#123;</span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    <span class="keyword">int</span> minTime = INT_MAX, maxTaskNum = <span class="number">0</span>, targetIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskTypes; ++i) &#123;</span><br><span class="line">      <span class="comment">// 记录还能继续执行的最小下一次执行时间</span></span><br><span class="line">      <span class="keyword">if</span> (taskInfo[i].second) minTime = <span class="built_in">min</span>(minTime, taskInfo[i].first);</span><br><span class="line">      <span class="comment">// 找到能够执行的且剩余次数最多的工作</span></span><br><span class="line">      <span class="keyword">if</span> (taskInfo[i].first &lt;= curTime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxTaskNum &lt; taskInfo[i].second) &#123;</span><br><span class="line">          maxTaskNum = taskInfo[i].second;</span><br><span class="line">          targetIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    <span class="keyword">if</span> (maxTaskNum) &#123;</span><br><span class="line">      taskInfo[targetIndex].second--;</span><br><span class="line">      taskInfo[targetIndex].first = curTime + n + <span class="number">1</span>;</span><br><span class="line">      curTime++;</span><br><span class="line">      len--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跳跃</span></span><br><span class="line">      curTime = minTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curTime - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：桶思想</p><blockquote><p>考虑桶的思想，考虑数目最多的任务，他们之间至少需要设置冷却时间+1个时间(桶大小)，因此如果在任务较少的情况下，其实影响最大的部分在于数目最多的任务<br>举例如下：</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td></tr><tr><td>A</td><td>B</td><td>/</td></tr></tbody></table><p>此时结果为(最多任务数目 - 1) * 桶大小 + 最多任务数目种类</p><p>再考虑到任务多的情况下，举例如下：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>E</td></tr><tr><td>A</td><td>B</td><td>D</td><td>/</td></tr></tbody></table><p>如果任务数目较多，则可通过扩展桶大小实现。那么其实最多时间也就是任务的数目(taskNums)，而与任务性质与否无关<br>因此结论是结果为两个例子结果取最大值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单个桶内的承载的数目</span></span><br><span class="line">  <span class="keyword">int</span> bucketNum = n + <span class="number">1</span>, len = tasks.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">taskNums</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 统计同种任务数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;task : tasks) &#123;</span><br><span class="line">    taskNums[task - <span class="string">'A'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(taskNums.<span class="built_in">begin</span>(), taskNums.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 统计数目最多的任务数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;taskNum : taskNums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (taskNum == taskNums[<span class="number">0</span>]) maxCount++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(len, maxCount + (taskNums[<span class="number">0</span>] - <span class="number">1</span>) * bucketNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="659分割数组为连续子序列"><a href="#659分割数组为连续子序列" class="headerlink" title="659分割数组为连续子序列"></a>659分割数组为连续子序列</h2><ul><li><p>题目描述：<br><img src="Question659.png" alt="659分割数组为连续子序列"></p></li><li><p>解法1：堆</p><blockquote><p>由于有最小长度为3的限制，因此每次需要将数字增加到长度最短的那个子序列中<br>考虑最小堆，堆中每个元素代表子序列长度，而与之关联的是一个子序列最后一个元素，因为原序列是递增的，如果连续只会比子序列的最后一个元素大，因此无需考虑更大的元素。因此只需要遍历一次原序列，并更新映射关系(可以连续/不可以连续情况)即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 建立&lt;子序列最后一个元素, 子序列大小堆&gt;的映射</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; um;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="comment">// 如果没有找到映射</span></span><br><span class="line">    <span class="keyword">if</span> (um.<span class="built_in">find</span>(num) == um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      um[num] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到之前的元素,可以连续</span></span><br><span class="line">    <span class="keyword">if</span> (um.<span class="built_in">find</span>(num - <span class="number">1</span>) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 获取之前的长度</span></span><br><span class="line">      <span class="keyword">int</span> preMinLen = um[num - <span class="number">1</span>].top();</span><br><span class="line">      <span class="comment">// 删除之前的元素</span></span><br><span class="line">      um[num - <span class="number">1</span>].pop();</span><br><span class="line">      <span class="keyword">if</span> (um[num - <span class="number">1</span>].empty()) &#123;</span><br><span class="line">        um.erase(num - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新当前长度</span></span><br><span class="line">      um[num].push(preMinLen + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新增</span></span><br><span class="line">      um[num].push(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;kv : um) &#123;</span><br><span class="line">    <span class="comment">// 检验子序列长度</span></span><br><span class="line">    <span class="keyword">if</span> (kv.second.top() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：贪心法</p><blockquote><p>将x加入已有的以x-1结尾的子序列更优，因为前者可以将已有子序列的长度增加1；而新建一个长度为1的子序列不满足题目要求分割的子序列长度不小于3，因此应尽量避免新建短的子序列<br>而在解法1中，每次只做了一次操作，其实可以根据上面的思路，每次如果找到以x-1结尾的子序列则合并，否则尝试建立一个长度为3的子序列，如果不能做到，那么说明输入不满足</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x出现次数map、x为结尾的子序列map数目</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numOccur, numEnd;</span><br><span class="line">  <span class="comment">// 记录各元素出现次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    numOccur[num]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="comment">// 如果元素用完,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!numOccur[num]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 优先考虑能够合并</span></span><br><span class="line">    <span class="keyword">if</span> (numOccur[num] &amp;&amp; numEnd[num - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 更新map</span></span><br><span class="line">      numOccur[num]--;</span><br><span class="line">      numEnd[num - <span class="number">1</span>]--;</span><br><span class="line">      numEnd[num]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOccur[num] &amp;&amp; numOccur[num + <span class="number">1</span>] &amp;&amp; numOccur[num + <span class="number">2</span>]) &#123; <span class="comment">// 一次性建立3个元素的子序列</span></span><br><span class="line">      <span class="comment">// 更新map</span></span><br><span class="line">      numOccur[num]--;</span><br><span class="line">      numOccur[num + <span class="number">1</span>]--;</span><br><span class="line">      numOccur[num + <span class="number">2</span>]--;</span><br><span class="line">      numEnd[num + <span class="number">2</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="803打砖块"><a href="#803打砖块" class="headerlink" title="803打砖块"></a>803打砖块</h2><ul><li><p>题目描述：<br><img src="Question803_p1.png" alt="803打砖块"></p></li><li><p>举例说明：<br><img src="Question803_p2.png" alt="示例图示"></p><blockquote><p>假设敲打前如上图所示，那么所有都不会掉落，因为都系在[0, 0]这个砖块上。如果此时打掉[1, 2]这个砖块，砖块[2, 2]和[3, 2]都与[0, 0]失去间接连接，因此会一起掉落<br>很容易想到这是一道连通性的问题，但又因为只需要需求连通的个数，可以快速地想到使用并查集进行求解。但如果初始阶段进行一次并查集的初始化，再一个一个打掉砖块，那么每次读需要完全重新初始化并查集，打掉的那块并不会对起到任何提示作用。这里可以使用并查集的删除重整算法(没有较好的资料)，但另一种考虑是逆向思维，从最后一步开始倒推重建整个网格<br>比如当前的示例图，右图只有3块稳定，加上[1, 2]砖块后变成左图，共有6块稳定。因此增加(反之这一步打掉砖块附带掉落了)6 - 3 - 1 = 2块</p></blockquote></li><li><p>小技巧(trick)：由于当前为二维表格，可能并查集内容很稀疏，可采用map代替传统的定长数组，再者可通过转化二维为一维简化记录内容(t = i * m + j————m行n列)</p></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, int&gt; find_root(int x, unordered_map&lt;int, pair&lt;int, int&gt;&gt; &amp;union_set) &#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = union_set.<span class="built_in">find</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (iter == union_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    union_set.insert(&#123;x, &#123;x, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;x, <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x != iter-&gt;second.first) &#123;</span><br><span class="line">    <span class="keyword">auto</span> root = find_root(iter-&gt;second.first, union_set);</span><br><span class="line">    iter-&gt;second.first = root.first;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_element</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;union_set)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> x_root = find_root(x, union_set), y_root = find_root(y, union_set);</span><br><span class="line">  <span class="keyword">if</span> (x_root.first == y_root.first) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (x_root.first == <span class="number">-1</span>) &#123;</span><br><span class="line">    union_set[y_root.first].first = x_root.first;</span><br><span class="line">    union_set[x_root.first].second += y_root.second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    union_set[x_root.first].first = y_root.first;</span><br><span class="line">    union_set[y_root.first].second += x_root.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> direction[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hitBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;hits)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; union_set;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; new_grid = grid;</span><br><span class="line">  union_set.insert(&#123;<span class="number">-1</span>, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">  <span class="keyword">int</span> m = new_grid.<span class="built_in">size</span>(), n = new_grid[<span class="number">0</span>].<span class="built_in">size</span>(), hit_size = hits.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(hit_size)</span></span>;</span><br><span class="line">  <span class="comment">// 重置砖块</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;hit : hits) &#123;</span><br><span class="line">    new_grid[hit[<span class="number">0</span>]][hit[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化并查集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = i * n + j;</span><br><span class="line">      <span class="keyword">if</span> (new_grid[i][j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i) union_element(index, <span class="number">-1</span>, union_set);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (new_grid[i - <span class="number">1</span>][j]) union_element(index, (i - <span class="number">1</span>) * n + j, union_set);</span><br><span class="line">          <span class="keyword">if</span> (j &amp;&amp; new_grid[i][j - <span class="number">1</span>]) union_element(index, i * n + j - <span class="number">1</span>, union_set);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倒序添加砖块</span></span><br><span class="line">  <span class="keyword">int</span> hang_num;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hit_size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    hang_num = union_set[<span class="number">-1</span>].second;</span><br><span class="line">    <span class="keyword">int</span> x = hits[i][<span class="number">0</span>], y = hits[i][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 可能打下的原本没有的砖块,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!grid[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> index = x * n + y;</span><br><span class="line">    <span class="keyword">if</span> (!x) union_element(index, <span class="number">-1</span>, union_set);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> next_x = x + direction[j], next_y = y + direction[j + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= m || next_y &lt; <span class="number">0</span> || next_y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_grid[next_x][next_y]) &#123;</span><br><span class="line">        union_element(index, next_x * n + next_y, union_set);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_grid[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可能连不上,最小为0</span></span><br><span class="line">    ans[i] = <span class="built_in">max</span>(union_set[<span class="number">-1</span>].second - hang_num - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="947移除最多的同行或同列石头"><a href="#947移除最多的同行或同列石头" class="headerlink" title="947移除最多的同行或同列石头"></a>947移除最多的同行或同列石头</h2><ul><li><p>题目描述：<br><img src="Question947_p1.png" alt="947移除最多的同行或同列石头"></p></li><li><p>举例：<br><img src="Question947_p2.png" alt="示例图示"><br>说明：由于同行或同列是可以移除的，可以把同行同列的石头连起来，就形成了一个无向图。根据观察，可得到只要是一个无向连通图，那么可以移除到只剩一个石头，那么原题目就变成了求连通子图的个数。如果只需求连通子图的个数而无需求是怎样连通的，可以采用并查集————将连通的石头挂载到一个节点上</p></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;union_set, <span class="keyword">int</span> &amp;connection_component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = union_set.<span class="built_in">find</span>(x);</span><br><span class="line">  <span class="comment">// 没有找到当前节点,相当于初始化</span></span><br><span class="line">  <span class="keyword">if</span> (iter == union_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 连通子图+1</span></span><br><span class="line">    connection_component++;</span><br><span class="line">    <span class="comment">// 默认父节点为自身</span></span><br><span class="line">    union_set.emplace(x, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;second == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 路径压缩,找到根节点</span></span><br><span class="line">      union_set[x] = find_root(iter-&gt;second, union_set, connection_component);</span><br><span class="line">      <span class="keyword">return</span> union_set[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_element</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;union_set, <span class="keyword">int</span> &amp;connection_component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> xRoot = find_root(x, union_set, connection_component), yRoot = find_root(y, union_set, connection_component);</span><br><span class="line">  <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span>;</span><br><span class="line">  union_set[xRoot] = yRoot;</span><br><span class="line">  connection_component--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;stones)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; union_set;</span><br><span class="line">  <span class="keyword">int</span> connection_component = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stone : stones) &#123;</span><br><span class="line">    union_element(stone[<span class="number">0</span>] + <span class="number">1001</span>, stone[<span class="number">1</span>], union_set, connection_component);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stones.<span class="built_in">size</span>() - connection_component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于同行同列都算连通,因此可以把连通的行列都链接到一起,只需要挂载到单个x或y上即可。由于题目要求0 &lt;= xi,yi &lt;= 10000,因此x+10001即可与y完全隔开</p></blockquote></li></ul><h2 id="959由斜杠划分区域"><a href="#959由斜杠划分区域" class="headerlink" title="959由斜杠划分区域"></a>959由斜杠划分区域</h2><ul><li><p>题目描述：<br><img src="Question959_p1.png" alt="959由斜杠划分区域(1)"><br><img src="Question959_p2.png" alt="959由斜杠划分区域(2)"></p></li><li><p>解法：并查集</p><blockquote><p>这是一个连通性的问题，只需要求得不连通区域的个数即可，可以使用并查集来解决<br>但使用’/‘和’&#39;分割区域中，单元格并不是最小的单位，而需要把单元格划分成个小的单位<br><img src="Question959_p3.png" alt="单元格划分示意"><br>如此，每个单元格被划分成4个更小的块，原题就变成了求块的连通区域的个数<br>其次，合并相邻单元格时，只需要考虑两个方向(向右和向下,这样顺序遍历时是全覆盖的)；然而并不是所有块都需要合并，只有块2需要与向下方向的其他块合并，块1需要和向右方向的其他块合并</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> setNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet, weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum = num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;unionSet.resize(num), <span class="keyword">this</span>-&gt;weight.resize(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;unionSet[i] = i;</span><br><span class="line">      <span class="keyword">this</span>-&gt;weight[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unionSet[x] == x ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 按秩合并</span></span><br><span class="line">    <span class="keyword">if</span> (weight[xRoot] &gt; weight[yRoot]) swap(xRoot, yRoot);</span><br><span class="line">    unionSet[xRoot] = yRoot;</span><br><span class="line">    weight[yRoot] += weight[xRoot];</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = grid.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">' '</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> chunk_size = len * len &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(chunk_size)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = (i * len + j) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// '/'的情况</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">3</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, index + <span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">'\\'</span>) &#123; <span class="comment">// '\'的情况</span></span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">1</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, index + <span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// ' '的情况</span></span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">1</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, index + <span class="number">2</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, index + <span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向下合并</span></span><br><span class="line">      <span class="keyword">if</span> (i != len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = ((i + <span class="number">1</span>) * len + j) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, nextIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向右合并</span></span><br><span class="line">      <span class="keyword">if</span> (j != len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = (i * len + j + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, nextIndex + <span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unionSet.setNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="995K连续位的最小翻转次数"><a href="#995K连续位的最小翻转次数" class="headerlink" title="995K连续位的最小翻转次数"></a>995K连续位的最小翻转次数</h2><ul><li><p>题目描述：<br><img src="Question995.png" alt="995K连续位的最小翻转次数"></p></li><li><p>前提条件：对若干个K位翻转操作，改变先后顺序不影响最终翻转效果。因此可以通过自左向右执行翻转，由于翻转是唯一的，如果最终数组元素均为1即是最少的翻转次数。如果自左向右每次遇到一个0就把接下来的K位翻转，会导致超时，因此做了许多不必要的操作</p></li><li><p>解法1：差分数组</p><blockquote><p>维护一个差分数组diff，其中diff[i]表示两个相邻元素A[i-1]和A[i]的翻转次数差<br>通过累加差分数组可以得到当前位置需要翻转的次数，用revCnt表示<br>遍历到A[i]时，若A[i] + revCnt为偶数，则实际值为0，翻转区间[i, i + K - 1]，可直接将revCnt增加1，diff[i + K]减少1<br>若i + K &gt; n则无法执行翻转操作，返回-1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    revCnt += diff[i];</span><br><span class="line">    <span class="keyword">if</span> ((A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++ans;</span><br><span class="line">      ++revCnt;</span><br><span class="line">      --diff[i + K];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：滑动窗口</p><blockquote><p>位置i的状态与前面K-1个元素翻转的次数(奇偶)有关<br>可使用队列模拟滑动窗口，此处滑动窗口含义是前面K-1个元素中以哪些位置起始的子区间进行了翻转<br>从左至右滑动，若位置i需要翻转，则将该位置存储到队尾。遍历到新位置j(j &lt; i + K)时，队列中元素个数代表i被之前K-1个是元素翻转的次数</p><ul><li>若size为偶，A[i] = 0，则需要翻转</li><li>若size为奇，A[i] = 1，则需要翻转<br>因此queue.size() % 2 == A[i]时，元素需要翻转<br>当i + K &gt; N时，说明元素剩余不足，返回-1</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;a : A) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!a) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() + K == i) q.pop();</span><br><span class="line">      <span class="keyword">if</span> (q.<span class="built_in">size</span>() % <span class="number">2</span> == A[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + K &gt; <span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans++;</span><br><span class="line">        q.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1178猜字谜"><a href="#1178猜字谜" class="headerlink" title="1178猜字谜"></a>1178猜字谜</h2><ul><li><p>题目描述：<br><img src="Question1178.png" alt="1178猜字谜"></p></li><li><p>解法1：hash表 + 移位</p><blockquote><p>由于只需要求单词中的字母是否都在谜面中，因此不需要细致的统计，应该统计具有相同字母的单词个数并进行归类计算<br>因此，首先需要将具有相同字母的单词个数统计出来，由于题目提示谜底为7位不同的字符，因此如果单词个数大于7可快速省略；而且由于都为小写字母，因此可以采用一个26位的bit位表示(int足以)<br>接着，如果接着遍历单词的数组与谜面进行一一匹配还是效率太低，应该遍历谜面，从hash表中找出是否存在，再累加；因此，需要罗列出谜底要求的bitSet子集</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算bitSet中1的个数(低26位)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oneNumsInBits</span><span class="params">(<span class="keyword">int</span> <span class="built_in">bitSet</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bitSet</span> &amp; (<span class="number">1</span> &lt;&lt; i)) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;puzzles)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">bitSet</span>;</span><br><span class="line">  <span class="comment">// 记录拥有相同字符单词个数</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bitSetNums;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span> : words) &#123;</span><br><span class="line">    <span class="built_in">bitSet</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c : <span class="keyword">word</span>) &#123;</span><br><span class="line">      <span class="built_in">bitSet</span> |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">      <span class="comment">// 大于puzzle7个字符</span></span><br><span class="line">      <span class="keyword">if</span> (oneNumsInBits(<span class="built_in">bitSet</span>) &gt; <span class="number">7</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitSetNums[<span class="built_in">bitSet</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(puzzles.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;puzzle : puzzles) &#123;</span><br><span class="line">    <span class="keyword">int</span> mask, curAns = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历可能余下6位可能的取值,罗列子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); ++i) &#123;</span><br><span class="line">      mask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">          mask |= <span class="number">1</span> &lt;&lt; (puzzle[j + <span class="number">1</span>] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 加上第一位</span></span><br><span class="line">      mask |= <span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">if</span> (bitSetNums.<span class="built_in">find</span>(mask) != bitSetNums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        curAns += bitSetNums[mask];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(curAns);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：字典树<br>#TODO</p></li></ul><h2 id="1438绝对差不超过限制的最长连续子数组"><a href="#1438绝对差不超过限制的最长连续子数组" class="headerlink" title="1438绝对差不超过限制的最长连续子数组"></a>1438绝对差不超过限制的最长连续子数组</h2><ul><li><p>题目描述：<br><img src="Question1438.png" alt="1438绝对差不超过限制的最长连续子数组"></p></li><li><p>解法：滑动窗口 + 单调队列</p><blockquote><p>滑动窗口 + multiset方式很容易想到，每次新插入数据rIndex，如果头尾相差在limit内则更新结果，否则删除lIndex<br>这样多做了许多工作，因为很多中间值多余了，只需要抓住最大值和最小值<br>因此可以采用两个单调队列，一个记录最小值(单调增)，一个记录最大值(单调减)，因为后续可能会浮出水面<br>而后每次查找最大值和最小值只需要查看队头元素即可，如果队头元素之差在limit之外，那么就需要遍历lIndex把可能的最大值或最小值去除复原之差在limit之内</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 单调递减</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>&gt; maxQueue;</span><br><span class="line">  <span class="comment">// 单调递增</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minQueue;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; maxQueue.top() &lt; nums[r]) maxQueue.pop();</span><br><span class="line">    <span class="keyword">while</span> (!minQueue.empty() &amp;&amp; minQueue.top() &gt; nums[r]) minQueue.pop();</span><br><span class="line">    maxQueue.push(nums[r]);</span><br><span class="line">    minQueue.push(nums[r++]);</span><br><span class="line">    <span class="keyword">if</span> (maxQueue.top() - minQueue.top() &lt;= limit) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; !minQueue.empty() &amp;&amp; maxQueue.top() - minQueue.top() &gt; limit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == maxQueue.top()) maxQueue.pop();</span><br><span class="line">        <span class="keyword">if</span> (nums[l++] == minQueue.top()) minQueue.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1489找到最小生成树里的关键边和伪关键边"><a href="#1489找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489找到最小生成树里的关键边和伪关键边"></a>1489找到最小生成树里的关键边和伪关键边</h2><ul><li><p>题目描述：<br><img src="Question1489_p1.png" alt="1489找到最小生成树里的关键边和伪关键边(1)"><br><img src="Question1489_p2.png" alt="1489找到最小生成树里的关键边和伪关键边(2)"></p></li><li><p>解法：并查集</p><blockquote><p>首先通过归并具有最小距离的最小生成树生成算法(Kruskal算法)，这样就能得到最小生成树的总权值，在归并过程中可使用并查集进行处理连通性问题<br>接着遍历测试除去一条指定边后的情况：如果一条边是关键边，那么加上这条边后，不能连通(连通数目大于1)或者当前的总权值大于先前的最小权值(连通并且严格大于)<br>最后遍历测试使用一条指定边后的情况：如果一条边是伪关键边，那么使用这条边后，能够连通(此处无需判断,如果不能连通就是关键边)而且与最小权值一样</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 连通数目</span></span><br><span class="line">  <span class="keyword">int</span> setNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum = num;</span><br><span class="line">    unionSet.reserve(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      unionSet.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == unionSet[x] ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 联合节点,返回是否需要联合</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">unionElement</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    unionSet[xRoot] = yRoot;</span><br><span class="line">    setNum--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findCriticalAndPseudoCriticalEdges</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = edges.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 设置编号,用于最后的返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    edges[i].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据距离从小到大排序</span></span><br><span class="line">  sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">2</span>] &lt; v2[<span class="number">2</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> min_value = <span class="number">0</span>;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="comment">// 依次加入并查集,得到最小权值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unionSet.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">      min_value += edge[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="function">UnionSet <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> temp_value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键边判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;edge = edges[j];</span><br><span class="line">      <span class="keyword">if</span> (temp.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">        temp_value += edge[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.setNum &gt; <span class="number">1</span> || (temp.setNum == <span class="number">1</span> &amp;&amp; min_value &lt; temp_value)) &#123;</span><br><span class="line">      ans[<span class="number">0</span>].push_back(edges[i][<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪关键边判断</span></span><br><span class="line">    temp = UnionSet(n);</span><br><span class="line">    temp.unionElement(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">    temp_value = edges[i][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;edge = edges[j];</span><br><span class="line">      <span class="keyword">if</span> (temp.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">        temp_value += edge[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp_value == min_value) ans[<span class="number">1</span>].push_back(edges[i][<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1631最小体力消耗路径"><a href="#1631最小体力消耗路径" class="headerlink" title="1631最小体力消耗路径"></a>1631最小体力消耗路径</h2><ul><li><p>题目描述：<br><img src="Question1631_p1.png" alt="1631最小体力消耗路径(1)"><br><img src="Question1631_p2.png" alt="1631最小体力消耗路径(2)"><br><img src="Question1631_p3.png" alt="1631最小体力消耗路径(3)"></p></li><li><p>解法：并查集</p><blockquote><p>原题可以转换成一个连通性问题————如果从左上角到右上角<br>首先通过构造格子间的过渡连接(from, to, cost)可以得到连接对，再通过对这些连接对的排序，把cost较大的移动到最后，那么每次必定从连接对中合并较小代价的连接。在每次连接后都判断当前操作是否能使左上角和右下角连通，而最后的一次成功的操作必定是cost最大的连接，因为是按升序排列的<br>本题中cost为数值的高度差的绝对值，还可通过对行列进行映射到唯一的id(i * row + j)方便编码</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> cellNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet, parent;</span><br><span class="line"></span><br><span class="line">  UnionSet(<span class="keyword">int</span> cellNum) : cellNum(cellNum) &#123;</span><br><span class="line">    unionSet.resize(cellNum);</span><br><span class="line">    parent.resize(cellNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cellNum; ++i) &#123;</span><br><span class="line">      unionSet[i] = i;</span><br><span class="line">      parent[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == unionSet[x] ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(x) == findRoot(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 按秩合并</span></span><br><span class="line">    <span class="keyword">if</span> (parent[xRoot] &gt; parent[yRoot]) swap(xRoot, yRoot);</span><br><span class="line">    unionSet[xRoot] = unionSet[yRoot];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;heights)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row = heights.<span class="built_in">size</span>(), col = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (row == col &amp;&amp; row == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cellDis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">      <span class="comment">// 加入下连接</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; row - <span class="number">1</span>) cellDis.emplace_back(i * col + j, (i + <span class="number">1</span>) * col + j, <span class="built_in">abs</span>(heights[i][j] - heights[i + <span class="number">1</span>][j]));</span><br><span class="line">      <span class="comment">// 加入右连接</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>) cellDis.emplace_back(i * col + j, i * col + j + <span class="number">1</span>, <span class="built_in">abs</span>(heights[i][j] - heights[i][j + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(cellDis.<span class="built_in">begin</span>(), cellDis.<span class="built_in">end</span>(), [](<span class="keyword">const</span> tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t1, <span class="keyword">const</span> tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t1) &lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, <span class="built_in">size</span> = row * col;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : cellDis) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unionSet.unionElements(<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(c), <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(c))) &#123;</span><br><span class="line">      ans = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(c);</span><br><span class="line">      <span class="keyword">if</span> (unionSet.isConnected(<span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1776车队II"><a href="#1776车队II" class="headerlink" title="1776车队II"></a>1776车队II</h2><ul><li><p>题目描述：<br><img src="Question1776.png" alt="1776车队II"></p></li><li><p>解法：单调栈</p><blockquote><p>由于题目隐含一些条件：如果可以合并，左边的都将以右边的车的速度移动，因为如果左边的车能够追上右边的车，那么一定会同化成右边的车速；不管已经行动了多少，能追上的时间都是相对的距离 / 相对的时间<br>可从右向左遍历并维护一个单调栈，单调栈的规律是序号递减，速度递增，这样才可以追上；而且合并之后不再计算与前车相遇时间，必须在前车合并前前车前追上<br>首先入栈right元素(初值为len-1)，而后查看后面元素是否能够追上栈顶元素：如果已经合并那么需要计算在合并前是否能追上；否则查看速度是否大于栈顶元素(如果大于,一定能追上)；然后依次递减right值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">getCollisionTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cars)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = cars.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">-1.0</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">      <span class="comment">// 追不上栈顶</span></span><br><span class="line">      <span class="keyword">if</span> (cars[s.top()][<span class="number">1</span>] &gt;= cars[i][<span class="number">1</span>]) s.pop();</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 能追上栈顶</span></span><br><span class="line">        <span class="comment">// 没有消失</span></span><br><span class="line">        <span class="keyword">if</span> (ans[s.top()] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 查看能否在合并前碰到,计算能跟上的距离</span></span><br><span class="line">        <span class="keyword">double</span> relativeDis = ans[s.top()] * (cars[i][<span class="number">1</span>] - cars[s.top()][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 碰得到</span></span><br><span class="line">        <span class="keyword">if</span> (relativeDis &gt; cars[s.top()][<span class="number">0</span>] - cars[i][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 碰不到</span></span><br><span class="line">        <span class="keyword">else</span> s.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> t = (cars[s.top()][<span class="number">0</span>] - cars[i][<span class="number">0</span>]) * <span class="number">1.0</span> / (cars[i][<span class="number">1</span>] - cars[s.top()][<span class="number">1</span>]);</span><br><span class="line">      ans[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer36二叉搜索树与双向链表"><a href="#剑指Offer36二叉搜索树与双向链表" class="headerlink" title="剑指Offer36二叉搜索树与双向链表"></a>剑指Offer36二叉搜索树与双向链表</h2><ul><li><p>题目描述：<br><img src="Question_offer36_p1.png" alt="剑指Offer36二叉搜索树与双向链表(1)"><br><img src="Question_offer36_p2.png" alt="剑指Offer36二叉搜索树与双向链表(2)"></p></li><li><p>解法：递归</p><blockquote><p>由于是二叉搜索树，因此中序遍历就是一个递增序列，又要求原地算法，因此使用递归的中序遍历<br>由图示的例子，中序遍历后的序列为12345，如果每次得到之前遍历的节点pre，那么每次就能够设置两个指针(当前遍历节点cur)————<code>pre-&gt;right = cur;cur-&gt;left = pre;</code>，那么只需要一次遍历即可得到除首位链接好的双向链表<br>又由于头节点head在遍历过程中pre一定为空，因此可以在递归算法中记录head值，还需要一个全局的pre指针<br><strong>不能使用Node*在函数中传递————在函数中传的是值，指针不能改变，只能改变指针指向的数据，可使用指针的指针或者全局变量</strong></p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node *pre = <span class="literal">nullptr</span>, *head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left) preOrderTraverse(node-&gt;left);</span><br><span class="line">  <span class="keyword">if</span> (pre) &#123;</span><br><span class="line">    pre-&gt;right = node;</span><br><span class="line">    node-&gt;left = pre;</span><br><span class="line">  &#125; <span class="keyword">else</span> head = node;</span><br><span class="line">  pre = node;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;right) preOrderTraverse(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">treeToDoublyList</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  preOrderTraverse(root);</span><br><span class="line">  head-&gt;left = pre;</span><br><span class="line">  pre-&gt;right = head;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer37序列化二叉树"><a href="#剑指Offer37序列化二叉树" class="headerlink" title="剑指Offer37序列化二叉树"></a>剑指Offer37序列化二叉树</h2><ul><li><p>题目描述：<br><img src="Question_offer37_p1.png" alt="剑指Offer37序列化二叉树"></p></li><li><p>解法：层次遍历</p><blockquote><p>由于先序、中序、后序遍历中的任何一种都无法确定一颗二叉树，因此可以通过采用层次遍历的方式，根据隐形的个数条件确定唯一的二叉树<br>首先是serialize()序列化方法，很容易通过队列得到结果，最后通过消除末尾多余的”null,”和’,’最后添加上结束符’]’<br>最重要的是deserialize()反序列化方法，首先通过字符串切割的方式得到所有的数据并存放入集合，接着由于不是满二叉树的情况，因此不能直接通过父元素与子元素的映射得到(有空隙,如下图所示)。需要设置两个指针来确定具体的映射关系<br><img src="Question_offer37_p2.png" alt="空隙的例子"></p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">"[null]"</span>;</span><br><span class="line">  <span class="built_in">string</span> ans = <span class="string">"["</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    TreeNode *front = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">if</span> (front) &#123;</span><br><span class="line">      ans.append(to_string(front-&gt;val)).push_back(<span class="string">','</span>);</span><br><span class="line">      q.push(front-&gt;left);</span><br><span class="line">      q.push(front-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> ans.append(<span class="string">"null,"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除末尾的"null,"</span></span><br><span class="line">  <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">5</span> &amp;&amp; ans.substr(ans.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">"null,"</span>) &#123;</span><br><span class="line">    ans.erase(ans.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除末尾的','</span></span><br><span class="line">  ans.pop_back();</span><br><span class="line">  ans.push_back(<span class="string">']'</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data == <span class="string">"[null]"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;TreeNode *&gt; ans;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果是"null,"或"null]"</span></span><br><span class="line">    <span class="keyword">if</span> (data[start] == <span class="string">'n'</span>) &#123;</span><br><span class="line">      ans.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">      start += <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 找后一个','的位置</span></span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">end</span> = data.<span class="built_in">find</span>(<span class="string">","</span>, start);</span><br><span class="line">      <span class="comment">// 遍历到最后</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">end</span> == <span class="built_in">string</span>::npos) <span class="built_in">end</span> = data.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">int</span> value = stoi(data.substr(start, <span class="built_in">end</span> - start));</span><br><span class="line">      ans.push_back(<span class="keyword">new</span> TreeNode(value));</span><br><span class="line">      start = <span class="built_in">end</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父元素和子元素的指针,从0开始</span></span><br><span class="line">  <span class="keyword">int</span> parent = <span class="number">0</span>, child = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (child &lt; ans.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans[parent]) &#123;</span><br><span class="line">      ans[parent]-&gt;left = ans[child++];</span><br><span class="line">      <span class="comment">// 右为null,且不计入的情况</span></span><br><span class="line">      <span class="keyword">if</span> (child &lt; ans.<span class="built_in">size</span>()) ans[parent]-&gt;right = ans[child++];</span><br><span class="line">    &#125;</span><br><span class="line">    parent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer39数组中出现次数超过一半的数字"><a href="#剑指Offer39数组中出现次数超过一半的数字" class="headerlink" title="剑指Offer39数组中出现次数超过一半的数字"></a>剑指Offer39数组中出现次数超过一半的数字</h2><ul><li><p>题目描述：<br><img src="Question_offer39.png" alt="剑指Offer39数组中出现次数超过一半的数字"></p></li><li><p>解法：摩尔投票法</p><blockquote><p>若记众数(超过一半的数)的票数为+1，非众数的票数为-1，则必有所有数字的票数和大于0<br>摩尔投票法在众数存在情况下一定指示众数，否则需要验证</p></blockquote></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> majority = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!count) majority = num;</span><br><span class="line">    count += (num == majority) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer48最长不含重复字符的子字符串"><a href="#剑指Offer48最长不含重复字符的子字符串" class="headerlink" title="剑指Offer48最长不含重复字符的子字符串"></a>剑指Offer48最长不含重复字符的子字符串</h2><ul><li><p>题目描述：<br><img src="Question_offer48.png" alt="剑指Offer48最长不含重复字符的子字符串"></p></li><li><p>解法：滑动窗口</p><blockquote><p>采用滑动窗口的方式，比如”dvdf”的例子，设置滑动窗口的当前边界left和right(初始全为0)以及一个存储字符最近遇到下标的集合(由于可见字符只有0～127共128个,因此可以设置为长度为128的向量,并赋初值-1)<br>首先扫描当前right下标的字符’d’，由于’d’未扫描过，因此right++，记录’d’最近下标为0，ans更新为1<br>接着扫描’v’，由于’v’未扫描过，因此right++，记录’v’最近下标为1，ans更新为2<br>接着扫描’d’，由于’d’扫描过且最近下标为0，因此需要将left移动到最近下标+1处————即下标为1，此时left=1，right++，记录’d’最近下标为2，ans不更新<br>再接着扫描’f’，由于’f’未扫描过，因此right++，记录’f’最近下标为3，ans更新为3<br>最后right越界，返回ans</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chars[s[right]] &gt;= left) &#123;</span><br><span class="line">      left = chars[s[right]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chars[s[right]] = right;</span><br><span class="line">    right++;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, right - left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer51数组中的逆序对"><a href="#剑指Offer51数组中的逆序对" class="headerlink" title="剑指Offer51数组中的逆序对"></a>剑指Offer51数组中的逆序对</h2><ul><li><p>题目描述：<br><img src="Question_offer51.png" alt="剑指Offer51数组中的逆序对"></p></li><li><p>解法1：分治法(归并排序)</p><blockquote><p>假设有两个已排序的序列等待归并计算逆序对个数，分别为L = {8, 12, 16, 22, 100}和R = {9, 26, 55, 64, 91}，使用两个指针lPtr、rPtr分别指向当前待L和R的头部<br>首先8 &lt;= 9，不存在逆序，将8放入答案数组中，lPtr++<br>…<br>这样最终得到逆序对个数即为归并L和R的逆序对的个数加上L和R别分的逆序对个数，就可以把原问题拆分成规模较小的子问题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (right == left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">      swap(nums[left], nums[right]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftN = reversePairs(nums, left, mid, temp), rightN = reversePairs(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">    <span class="comment">// 如果前后总体已有序,提前退出,没有逆序对</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> leftN + rightN;</span><br><span class="line">    <span class="keyword">int</span> curN = <span class="number">0</span>, lPtr = left, rPtr = mid + <span class="number">1</span>, index = left;</span><br><span class="line">    <span class="keyword">while</span> (lPtr &lt;= mid &amp;&amp; rPtr &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[lPtr] &lt;= nums[rPtr]) &#123;</span><br><span class="line">        curN += rPtr - mid - <span class="number">1</span>;</span><br><span class="line">        temp[index++] = nums[lPtr++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[index++] = nums[rPtr++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lPtr &lt;= mid) &#123;</span><br><span class="line">      curN += right - mid;</span><br><span class="line">      temp[index++] = nums[lPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rPtr &lt;= right) &#123;</span><br><span class="line">      temp[index++] = nums[rPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">      nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftN + curN + rightN;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> reversePairs(nums, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：树状数组<br>#TODO</p></li></ul><h2 id="剑指Offer56数组中数字出现的次数I"><a href="#剑指Offer56数组中数字出现的次数I" class="headerlink" title="剑指Offer56数组中数字出现的次数I"></a>剑指Offer56数组中数字出现的次数I</h2><ul><li><p>问题描述：<br><img src="Question_offer56I.png" alt="剑指Offer56数组中数字出现的次数I"></p></li><li><p>解法：异或分组</p><blockquote><p>由于异或运算有一种性质：A异或A为0，因此通过对所有数字进行异或，能得到两个单数S1、S2的异或结果res<br>接着通过得到res的最高位div(其后全0)，由于最高位div只能由一个数提供(S1或S2)，因此可通过div与S1、S2的和，查看是否满足最高位为div，由此可将S1、S2分成两个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    res ^= num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取得最高的不同位</span></span><br><span class="line">  <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((div &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">    div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过是否满足最高位区分单数</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (div &amp; num) &#123;</span><br><span class="line">      a ^= num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer56数组中数字出现的次数II"><a href="#剑指Offer56数组中数字出现的次数II" class="headerlink" title="剑指Offer56数组中数字出现的次数II"></a>剑指Offer56数组中数字出现的次数II</h2><ul><li><p>问题描述：<br><img src="Question_offer56II.png" alt="剑指Offer56数组中数字出现的次数II"></p></li><li><p>解决思路：</p><blockquote><p>由于其他数字都出现了三次，如果采用map的话，效率太低<br>考虑比特位集合，由于int可以转化为32个bit位，如果每个数都出现三次，那么各个位同样也出现了三次，那么只需要统计出各个位的数目，在取余就可以得到0或1，就可以复原出唯一的数</p></blockquote></li><li><p>解法1：遍历统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计比特位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">bitSet</span>, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) <span class="built_in">bitSet</span>[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bitSet</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 遍历统计</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    calculateBit(<span class="built_in">bitSet</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 还原唯一数的比特位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bitSet</span>[i] % <span class="number">3</span>) ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2：状态转换图</p><blockquote><p>由于次数由0变为1，再变为2，最终回到0，可以联想到状态转换(数字逻辑电路)<br>由于0 -&gt; 1 -&gt; 2 -&gt; 0需要两个bit位才能承载，因此扩展为00 -&gt; 01 -&gt; 10 -&gt; 00<br>有转换图</p><table><thead><tr><th>n</th><th>two(before)</th><th>one(before)</th><th>two(after)</th><th>one(after)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>如果n输入位0，那么bit位无需变化；若为1，则需要相应的变化<br>当two为0，n为0时，one = one；n为1时，one = ~one，因此此时<code>one = one ^ n</code><br>当two为1，n为0时，one = 0；n为1时，one = 0，因此此时<code>one = 0</code><br>综合得到<code>one = (~two &amp; (one ^ n)) | 0</code>即<code>one = one ^ n &amp; ~two</code><br>同理，当one为0，n为0时，two = two；n为1时，two = ~two，因此此时<code>two = two ^ n</code><br>当one为1，n为0时，two = 0；n为1时，two = 0，因此此时<code>two = 0</code><br>因此，one与two一样的表达式<code>two = two ^ n &amp; (~one)</code><br>由于每个位都具有独立性，因为int与一个bit一样同样遵循上述规律<br>结果时one为1，因此最后的结果由00 -&gt; 01，而one就是最终的结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    one = one ^ num &amp; (~two);</span><br><span class="line">    two = two ^ num &amp; (~one);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer60n个骰子的点数"><a href="#剑指Offer60n个骰子的点数" class="headerlink" title="剑指Offer60n个骰子的点数"></a>剑指Offer60n个骰子的点数</h2><ul><li><p>题目描述：<br><img src="Question_offer60.png" alt="剑指Offer60n个骰子的点数"></p></li><li><p>解法：动态规划</p><blockquote><p>考虑骰子的变动，从n-1个骰子到n个骰子肯定存在联系，因此可能会有动态转移方程<br>假设前一次的骰子的各个点数出现的次数为dp[n - 1][j] (j点)<br>那么dp[n][j] = sum{dp[n - 1][j - t]} (1 &lt;= t &lt;= 6)<br>也即是此次n个骰子要想产生j点，那么可以从n-1个骰子不超过j点的次数(t)加当前确定的次数(j - t)的总和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算概率</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">getProbability</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = v.<span class="built_in">size</span>(), sum = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    ans[i] = v[i] * <span class="number">1.0</span> / sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>].resize(<span class="number">6</span>);</span><br><span class="line">  <span class="comment">// 初始化为1个骰子的情况</span></span><br><span class="line">  <span class="built_in">fill</span>(dp[<span class="number">0</span>].<span class="built_in">begin</span>(), dp[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 从n个1到n个6</span></span><br><span class="line">    dp[i].resize(<span class="number">5</span> * (i + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dp[i - <span class="number">1</span>].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="comment">// 化简(不考虑真实点数,考虑偏移)</span></span><br><span class="line">        dp[i][j + k] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getProbability(dp[n - <span class="number">1</span>], n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="剑指Offer62圆圈中最后剩下的数字"><a href="#剑指Offer62圆圈中最后剩下的数字" class="headerlink" title="剑指Offer62圆圈中最后剩下的数字"></a>剑指Offer62圆圈中最后剩下的数字</h2><ul><li><p>题目描述：<br><img src="Question_offer62.png" alt="剑指Offer62圆圈中最后剩下的数字"></p></li><li><p>解法1：数学 + 递归</p><blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>解法2：数学 + 动态规划</p><blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
            <tag> LeetCode题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2020/12/08/Middleware/MySQL/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/12/08/Middleware/MySQL/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#SQL语句">SQL语句</a></li><li><a href="#表约束和范式">表约束和范式</a></li><li><a href="#多表查询和子查询">多表查询和子查询</a></li><li><a href="#事务">事务</a></li><li><a href="#存储引擎">存储引擎</a></li><li><a href="#其他">其他</a></li></ul><a id="more"></a><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ul><li><p>SQL概述</p><ul><li>什么是SQL：SQL(Structured Query Language)是”结构化查询语言”，它是对关系型数据库的操作语言，可以应用到所有关系型数据库中。很多数据库还都有标准以外的一些语法，称之为”方言”。例如MySQL中的LIMIT语句就是MySQL独有的方言，其它数据库都不支持</li><li>SQL语法要求：<ol><li>SQL语句可单行或多行书写，以分号结尾</li><li>可用空格和缩进来增强语句的可读性</li><li>关键字不区别大小写，建议使用大写</li></ol></li><li>SQL分类：<ol><li>DDL(Data Definition Language)：数据定义语言，用来定义数据库对象：库、表、列等</li><li>DML(Data Manipulation Language)：数据操作语言，用来定义数据库记录(数据)</li><li>DCL(Data Control Language)：数据控制语言，用来定义访问权限和安全级别</li><li>DQL(Data Query Language)：数据查询语言，用来查询记录(数据)</li></ol></li></ul></li><li><p>DDL介绍：</p><ul><li>操作数据库：<ul><li>创建数据库：<ol><li>基础创建：<code>CREATE DATABSE dbName</code></li><li>不存在则创建：<code>CREATE DATABASE IF NOT EXISTS dbName</code></li><li>指定字符集：<code>CREATE DATABSE dbName CHARACTER SET charsetName</code></li></ol></li><li>查看数据库：<ol><li>查看所有数据库：<code>SHOW DATABASES</code></li><li>查看某个数据库的定义信息：<code>SHOW CREATE DATABASE dbName</code></li></ol></li><li>修改数据库(默认)字符集：<code>ALTER DATABASE dbName (DEFAULT) CHARACTER SET charsetName</code></li><li>删除数据库：<code>DROP DATABSE dbName</code></li><li>使用数据库：<ol><li>查看正在使用的数据库：<code>SELECT DATABASE()</code></li><li>使用/切换数据库：<code>USE dbName</code></li></ol></li></ul></li><li>操作表结构：<ul><li>创建表：<code>CREATE TABLE tableName(field1 fieldType1, field2 fieldType2)</code><blockquote><p>MySQL表名是以文件的形式保存在磁盘上的，因此表名的字符可以使用任何文件允许的字符</p></blockquote></li><li>查看某个数据库的所有表：<code>SHOW TABLES</code><ul><li>查看表结构：<code>DESC tableName</code></li><li>查看建表语句：<code>SHOW CREATE TABLE tableName</code></li></ul></li><li>快速创建表结构相同的表：<code>CREATE TABLE newTableName LIKE oldTableName</code></li><li>删除表<ol><li>直接删除：<code>DROP TABLE tableName</code></li><li>存在则删除：<code>DROP TABLE IF EXISTS tableName</code></li></ol></li><li>修改表结构：<ol><li>添加列：<code>ALTER TABLE tableName ADD fieldName fieldType</code></li><li>修改列：<code>ALTER TABLE tableName MODIFY fieldName fieldType</code></li><li>修改列名(同时可修改字段类型)：<code>ALTER TABLE tableName CHANGE oldFieldName newFieldName fieldType</code><blockquote><p>change和modify都可以修改表的定义，change后面需要写两次列名，change可以修改列名称但modify不能</p></blockquote></li><li>删除列：<code>ALTER TABLE tableName DROP fieldName</code></li><li>修改表名：<code>RENAME TABLE oldTableName TO newTableName</code></li><li>修改表字符集：<code>ALTER TABLE tableName CHARACTER SET charsetName</code></li><li>修改字段位置(ADD/CHANGE/MODIFY后)：<code>[first | after columnName]</code><blockquote><p>CHANGE和修改字段位置关键字属于扩展</p></blockquote></li></ol></li></ul></li></ul></li><li><p>DML介绍：</p><ul><li><p>插入记录：</p><ol><li>插入全部字段：<code>INSERT INTO tableName VALUES(v1, v2, v3, ...)</code></li><li>插入部分字段：<code>INSERT INTO tableName(field1, field2, ...) VALUES(v1, v2, ...)</code></li></ol><blockquote><ol><li>插入的数据应与字段的数据类型相同，且在范围内</li><li>在VALUES中列出的数据位置必须与被加入的列的排列位置相对应</li><li>字符和日期型数据应包含在单引号中。MySQL中也可以使用双引号做为分隔符</li><li>不指定列或使用NULL，表示插入空值</li><li>可以插入多条记录，之间用’,’隔开</li></ol></blockquote></li><li><p>蠕虫复制：将一张已存在表中数据复制到另一张表中</p><ol><li>复制所有列：<code>INSERT INTO tableName1 SELECT * FROM tableName2</code></li><li>复制部分列：<code>INSERT INTO tableName1(field1, field2, ...) SELECT field1, field2, ... FROM tableName2</code></li></ol></li><li><p>更新记录：</p><ol><li>不带条件修改(修改所有行)：<code>UPDATE tableName SET field1=v1, field2=v2, ...</code></li><li>带条件修改：<code>UPDATE tableName SET field1=v1,field2=v2, ... WHERE ...</code><blockquote><p>更新记录也可更新多张表的字段</p></blockquote></li></ol></li><li><p>删除记录：</p><ol><li>不带条件删除(删除所有行)：<code>DELETE FROM tableName</code></li><li>带条件删除：<code>DELETE FROM tableName WHERE ...</code><blockquote><p>删除记录也可删除多张表的字段</p></blockquote></li><li>使用truncate删除：<code>TRUNCATE TABLE tableName</code></li></ol><blockquote><p>truncate相当于删除表的结构，再创建一张表；而delete仅删除数据</p></blockquote></li></ul></li><li><p>DCL介绍：</p><ul><li>创建用户：<ul><li>语法：<code>CREATE USER &#39;username&#39; @&#39;hostname&#39;  IDENTIFIED BY &#39;password&#39;</code><blockquote><p>单引号’’不可少</p></blockquote></li><li>说明：<ol><li>username：将创建的用户名</li><li>hostname：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost；如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ol></li></ul></li><li>授予用户权限<ul><li>语法：<code>GRANT authority1, authority2, ... ON database.tableName TO &#39;username&#39;@&#39;hostname&#39;</code><blockquote><p>单引号’’不可少</p></blockquote></li><li>说明：<ol><li>GRANT … ON … TO：授权关键字</li><li>authority：授予用户的权限，如CREATE、ALTER、SELECT、INSERT和UPDATE等。如果要授予所有的权限可使用ALL</li><li>database.tableName：该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*</li><li>‘username’@’hostname’：给哪个用户授权</li></ol></li></ul></li><li>撤销用户权限：<code>REVOKE authority1, authority2, ... ON database.tableName FROM &#39;username&#39;@&#39;hostname&#39;</code><blockquote><p>说明参见授予权限</p></blockquote></li><li>查看权限：<code>SHOW GRANTS FOR &#39;username&#39;@&#39;hostname&#39;</code><blockquote><p>usage是指连接(登陆)权限，建立一个用户就会自动授予其usage权限(默认授予)</p></blockquote></li><li>删除用户：<code>DROP USER &#39;username&#39;@&#39;hostname&#39;</code></li><li>修改管理员密码：<code>mysqldadmin -u root -p password newPassword</code><blockquote><p>需要在未登陆MySQL的情况下操作，新密码不需要加上引号；password是关键字，newPassword是新密码串</p></blockquote></li><li>修改普通用户密码：<code>SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39;=password(&#39;newPassword&#39;)</code><blockquote><p>需要在登陆MySQL的情况下操作</p></blockquote></li></ul></li><li><p>DQL介绍：</p><ul><li><p>总体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  selection_list <span class="comment">/*要查询的列名称*/</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  table_list <span class="comment">/*要查询的表名称*/</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  condition <span class="comment">/*行条件*/</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">  grouping_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line">  condition <span class="comment">/*分组后的行条件*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  sorting_columns <span class="comment">/*对结果分组*/</span></span><br><span class="line"><span class="keyword">LIMIT</span> </span><br><span class="line">  offset_start, <span class="keyword">row_count</span> <span class="comment">/*结果限定*/</span></span><br></pre></td></tr></table></figure></li><li><p>简单查询：</p><ol><li><p>查询所有列：<code>SELECT * FROM tableName</code></p></li><li><p>查询指定列：<code>SELECT field1, field2, ... FROM tableName</code></p></li><li><p>指定别名查询：</p><ol><li><p>指定列别名：<code>SELECT field1 AS newField1, field2 AS newField2, ... FROM tableName</code></p></li><li><p>指定列和表别名：<code>SELECT field1 AS newField1, field2 AS newField2, ... FROM tableName AS newTableName</code></p><blockquote><p>指定表别名主要用于多表查询，其中别名的AS可以省略；别名可用双引号””括起</p></blockquote></li></ol></li><li><p>清除指定列的重复值：<code>SELECT DISTINCT field FROM tableName</code></p></li><li><p>查询结果参与运算(参与运算的必须是数值类型)：</p></li></ol></li><li><p>条件查询：</p><ul><li><p>语法：<code>SELECT field FROM tableName WHERE condition</code></p></li><li><p>比较运算符：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;、&lt;、&lt;=、&gt;=</td><td></td></tr><tr><td>=、&lt;&gt; / !=、&lt;=&gt;</td><td>&lt;=&gt;为NULL安全的等于,其余不能用于NULL比较</td></tr><tr><td>BETWEEN</td><td>存在于指定范围</td></tr><tr><td>IN</td><td>存在于指定集合</td></tr><tr><td>IS [NOT] NULL</td><td></td></tr><tr><td>LIKE</td><td>通配符匹配</td></tr><tr><td>REGEXP / RLIKE</td><td>正则表达式匹配</td></tr></tbody></table></li><li><p>逻辑运算符：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND / &amp;&amp;</td><td>与,AND更通用；操作数任一为NULL返回NULL</td></tr><tr><td>OR / ||</td><td>或；一操作数为NULL另一操作为0(非零)时返回NULL(1),两操作数均为NULL时返回NULL</td></tr><tr><td>NOT / !</td><td>非,NOT NULL返回指为NULL</td></tr><tr><td>XOR</td><td>异或；操作数任一为NULL返回NULL</td></tr></tbody></table></li><li><p>位运算符：&amp;、|、^、~、&gt;&gt;、&lt;&lt;</p></li><li><p>LIKE关键字：模糊查询</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>%</td><td>匹配任意多个字符(包含0个字符)</td></tr><tr><td>_</td><td>匹配一个字符</td></tr><tr><td>ESCAPE</td><td>转义指定字符</td></tr></tbody></table><blockquote><p><code>SELECT username FROM user WHERE username LIKE &#39;%pbo/_%&#39; ESCAPE &#39;/&#39;</code></p></blockquote></li></ul></li><li><p>排序查询：<code>SELECT field FROM tabelName WHERE field = value ORDER BY field1 [ASC|DESC], field2[ASC|DESC], ...</code></p><blockquote><p>同时对多个字段进行排序时，如果第一个字段相同则按第二个字段排序，依此类推</p></blockquote></li><li><p>聚合函数：</p><ul><li><p>介绍：聚合函数查询是纵向查询，它对一列的值进行计算，然后返回一个结果值。聚合函数会忽略空值NULL</p></li><li><p>主要的聚合函数：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>max(列)</td><td>求列的最大值</td></tr><tr><td>min(列)</td><td>求列的最小值</td></tr><tr><td>avg(列)</td><td>求列的平均值</td></tr><tr><td>count(列)</td><td>统计列的数据条数</td></tr><tr><td>sum(列)</td><td>求列数据的总和</td></tr></tbody></table></li><li><p>语法：<code>SELECT fcuntion(field) FROM tableName</code></p><blockquote><p>对于NULL的记录不会统计，如果要统计需要借助IFNULL函数<br>IFNULL(fieldName, defaultValue)：如果列不为空返回这列的值。如果为NULL则返回默认值<br>修改后的SQL语句：<code>SELECT function(IFNULL(fieldName, defaultValue)) FROM tableName</code></p></blockquote></li></ul></li><li><p>分组查询:</p><ul><li><p>介绍：GROUP BY语句会将分组字段结果中相同内容作为一组，并且返回每组的第一条数据。因此单独分组没什么用处。分组的目的是为了统计，一般分组查询会跟聚合函数一起使用</p></li><li><p>语法：<code>SELECT field1, field2, ... FROM tableName GROUP BY field [HAVING condition]</code></p></li><li><p>HAVING和WHERE子句的区别：</p><table><thead><tr><th>语句</th><th>作用</th></tr></thead><tbody><tr><td>WHERE子句</td><td>1. 对查询结果进行分组前，将不符合WHERE条件的行去掉，即在分组之前过滤数据，即先过滤再分组 2. WHERE子句后不可以使用聚合函数</td></tr><tr><td>HAVING子句</td><td>1. HAVING子句的作用是筛选满足条件的组，即在分组之后过滤数据，即先分组再过滤 2. HAVING子句后可以使用聚合函数</td></tr></tbody></table></li></ul></li><li><p>LIMIT语句：</p><ul><li>介绍：限制查询记录的条数，用于语句的末尾</li><li>语法：<code>LIMIT offset, length</code><blockquote><p>offset：起始行数，从0开始计数。省略默认就是0<br>length：返回的行数</p></blockquote></li></ul></li><li><p>记录联合：</p><ul><li>介绍：用于将结果合并显示</li><li>语法：<code>select1 UNION | UNION ALL select2 ...</code><blockquote><p>UNION ALL是把结果集直接合并，UNION在UNION ALL结果的基础上进行了一此DISTINCT，去除了重复记录</p></blockquote></li></ul></li></ul></li></ul><h2 id="表约束和范式"><a href="#表约束和范式" class="headerlink" title="表约束和范式"></a>表约束和范式</h2><ul><li><p>表约束</p><ul><li><p>约束作用：可以一定程度保证数据的正确性、有效性和完整性</p></li><li><p>约束种类：</p><table><thead><tr><th>约束名</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>非空</td><td>NOT NULL</td></tr><tr><td>外键</td><td>FOREIGN KEY(主表中主键列,从表中外键列)</td></tr><tr><td>检查约束</td><td>CHECK(MySQL不支持)</td></tr></tbody></table></li><li><p>主键：</p><ul><li><p>特点：</p><ol><li>非空，NOT NULL</li><li>唯一，UNIQUE</li></ol></li><li><p>设置语句：</p><ol><li>创建表时添加</li><li>在已有表中添加主键：<code>ALTER TABLE tableName ADD PRIMARY KEY(fieldName)</code></li><li>删除主键：<code>ALTER TABLE tableName DROP PRIMARY KEY</code></li></ol></li><li><p>主键自增：</p><ul><li><p>介绍：建表时使用AUTO_INCREMENT关键字可以指定主键自增，默认开始值为1，且主键必须是整型类型的一个字段</p></li><li><p>创建表时指定起始值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableName(</span><br><span class="line">  field1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  field2 ...,</span><br><span class="line">  ...</span><br><span class="line">)AUTO_INCREMENT=v;</span><br></pre></td></tr></table></figure></li><li><p>修改主键起始值：<code>ALTER TABLE tableName AUTO_INCREMENT=value</code></p></li><li><p>DELETE和TRUNCATE对自增长的影响：前者删除记录后自增长无影响；后者删除后自增长从头开始</p></li></ul></li></ul></li><li><p>唯一约束：</p><ul><li>特点：某列不能出现重复的值，NULL不存在重复问题</li><li>语法：<code>field fieldType UNIQUE</code></li></ul></li><li><p>非空约束：</p><ul><li>特点：某列不能为NULL</li><li>语法：<code>field fieldType NOT NULL</code></li></ul></li><li><p>默认值：<code>field fieldType DEFAULT value</code></p></li><li><p>外键约束：</p><ul><li><p>语法：</p><ol><li>新建表：<code>[CONSTRAINT] [foreignKeyName] FOREIGN KEY(fieldName) REFERENCES tableName(fieldName) [ON UPDATE CASCADE|ON DELETE CASCADE]</code></li><li>已有表新增：<code>ALTER TABLE table1 ADD [CONSTRAINT] [foreignKeyName] FOREIGN KEY(fieldName) REFERENCES table2(fieldName) [ON UPDATE CASCADE|ON DELETE CASCADE]</code></li><li>删除：<code>ALTER TABLE tableName DROP FOREIGN KEY foreignKeyName</code></li></ol></li><li><p>级联操作：在修改和删除主表的主键时，同时更新或删除副表的外键值(可同时设置级联更新和删除)</p><table><thead><tr><th>级联操作语法</th><th>描述</th></tr></thead><tbody><tr><td>ON UPDATE CASCADE</td><td>级联更新,只能是创建表的时候创建级联关系。更新主表中的主键,从表中的外键列也自动同步更新</td></tr><tr><td>ON DELETE CASCADE</td><td>级联删除</td></tr></tbody></table></li></ul></li></ul></li><li><p>范式</p><ul><li>第一范式(1NF)：数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。<strong>简而言之，第一范式每一列不可再拆分，称为原子性</strong></li><li>第二范式(2NF)<ul><li>介绍：<br>在满足第一范式的前提下，表中的每一个字段都完全依赖于主键<br>所谓完全依赖是指不能存在仅依赖主键一部分的列。<strong>简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列</strong></li><li>特点：<ol><li>一张表只描述一件事情</li><li>表中的每一列都完全依赖于主键</li></ol></li></ul></li><li>第三范式(3NF)：在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键。简而言之，第三范式就是所有列不依赖于其它非主键列，也就是在满足2NF的基础上，<strong>任何非主列不得传递依赖于主键</strong></li></ul></li></ul><h2 id="多表查询和子查询"><a href="#多表查询和子查询" class="headerlink" title="多表查询和子查询"></a>多表查询和子查询</h2><ul><li>多表查询<ul><li>内连接：用左边表的记录去匹配右边表的记录，如果符合条件的则显示<ul><li>隐式内连接：看不到JOIN关键字，条件由WHERE指定<blockquote><p><code>SELECT field FROM table1, table2 WHERE condition</code></p></blockquote></li><li>显式内连接：使用INNER JOIN … ON格式，可以省略INNER<blockquote><p><code>SELECT field FROM table1 [INNER] JOIN table2 ON condition</code></p></blockquote></li></ul></li><li>外连接：<ul><li>左外连接：用左表记录去匹配右表记录，如果符合条件的则显示原数据；否则显示NULL。可理解为在内连接基础上保证左表数据全部显示。使用LEFT OUTER JOIN … ON格式，可以省略OUTER<blockquote><p><code>SELECT field FROM table1 LEFT [OUTER] JOIN table2 ON condition</code></p></blockquote></li><li>右外连接：用右表记录去匹配左表记录，如果符合条件的则显示原数据；否则显示NULL。可理解为在内连接基础上保证右表数据全部显示。使用RIGHT OUTER JOIN … ON格式，可以省略OUTER<blockquote><p><code>SELECT field FROM table1 RIGHT [OUTER] JOIN table2 ON condition</code></p></blockquote></li></ul></li></ul></li><li>子查询<ul><li>介绍：<ol><li>一个查询的结果做为另一个查询的条件</li><li>有查询的嵌套，内部的查询称为子查询</li><li>子查询要使用括号</li></ol></li><li>子查询的情况：<ul><li>结果是一个数据(单行单列)：可以供父查询使用比较运算符<blockquote><p><code>SELECT field FROM tableName WHERE field = (child selection)</code></p></blockquote></li><li>结果是一个数组(多行单列)：可以供父查询使用IN运算符<blockquote><p><code>SELECT field FROM tableName WHERE field IN (child selection)</code></p></blockquote></li><li>结果是一张表(多行多列)：可作为查询的表或连接表，还需取表别名<blockquote><p><code>SELECT field FROM (child seletion) aliasName WHERE condition</code><br><code>SELECT field FROM table1 [LEFT|RIGHT] JOIN (child selection) aliasName ON condition</code></p></blockquote></li></ul></li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>介绍：事务执行是一个整体，所有的SQL语句都必须执行成功。如果其中有1条SQL语句出现异常，则所有的SQL语句都要回滚，整个业务执行失败</p></li><li><p>MySQL执行事务的方式：</p><ul><li>手动提交事务<ul><li>执行语句：<ol><li>开启事务：<code>start transaction</code></li><li>提交事务：<code>commit</code></li><li>回滚事务：<code>rollback</code></li></ol></li><li>使用过程：<ol><li>执行成功：开始事务 -&gt; 执行多条SQL语句 -&gt; 成功完成,提交事务</li><li>执行失败：开启事务 -&gt; 执行多条SQL语句 -&gt; 出现异常,事务回滚</li></ol></li></ul></li><li>自动提交事务：MySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务<ul><li>查看MySQL是否开启自动提交事务：<code>SELECT @@autocommit</code><blockquote><p>@@表示全局变量，1表示开启，0表示关闭</p></blockquote></li><li>取消自动提交事务：<code>SET @@autocommit = 0</code></li></ul></li></ul></li><li><p>事务原理：事务开启之后，所有的操作都会临时保存到事务日志中。事务日志只有在收到commit命令才会同步到数据表中，其他任何情况都会清空事务日志(rollback,断开连接)</p><ul><li><p>事务步骤：</p><ol><li>客户端连接数据库服务器，创建连接时创建此用户临时日志文件</li><li>开启事务以后，所有的操作都会先写入到临时日志文件中</li><li>所有的查询操作从表中查询，但会经过日志文件加工后才返回</li><li>如果事务提交则将日志文件中的数据写到表中，否则清空日志文件</li></ol></li><li><p>回滚点：在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功。可以在当前成功的位置设置一个回滚点，以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点</p><blockquote><table><thead><tr><th>回滚点操作</th><th>语句</th></tr></thead><tbody><tr><td>设置回滚点</td><td>savepoint name</td></tr><tr><td>回到回滚点</td><td>rollback to name</td></tr></tbody></table></blockquote></li><li><p>事务的隔离级别</p><ul><li><p>事务四大特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)</p></li><li><p>事务的隔离级别：</p><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读取到了另一个事务中尚未提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务中两次读取的数据内容不一致</td></tr><tr><td>幻读</td><td>一个事务中两次读取的数据的数量不一致</td></tr></tbody></table></li><li><p>数据库的隔离级别：</p><table><thead><tr><th>级别</th><th>名字</th><th>隔离级别</th><th>脏读</th><th>不可重读</th><th>幻读</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td>\</td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle和SQL Server默认的隔离级别</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>MySQL默认的隔离级别</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td>\</td></tr></tbody></table><blockquote><p>隔离级别越高，安全级越高，性能越差</p></blockquote></li><li><p>MySQL事务隔离级别相关命令：</p><ol><li>查询全局事务隔离级别：<code>SELECT @@tx_isolation</code></li><li>设置隔离级别(需要退出后重新登录才生效)：<code>SET GLOBAL TRANSACTION ISOLATION LEVEL 隔离级别字符串</code></li></ol></li></ul></li></ul></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li><p>介绍：插件式存储引擎是MySQL数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等</p></li><li><p>支持的存储引擎(MySQL5.7)：InnoDB、MyISAM、MEMORY、CSV、BLACKHOLE、ARCHIVE、MERGE(MRG_MyISAM)、FEDERATED、EXAMPLE、NDB等。其中InnoDB和NDB提供事务安全表</p></li><li><p>指定存储引擎：</p><ul><li>建表：创建新表时如果不指定存储引擎，那么就会使用默认存储引擎，MySQL 5.5之前默认为MyISAM，5.5之后默认为InnoDB。如果要修改默认的存储引擎，可在参数文件中设置default_storage_engine属性。可通过增加ENGINE关键字设置新建表的存储引擎：<code>ENGINE=xxx</code><blockquote><p>查看当前的默认存储引擎：<code>SHOW VARIABLES LIKE &#39;default_storage_engine&#39;</code><br>  查询当前数据库支持的存储引擎：<code>SHOW engines \G</code><br>  其中Support不同值的含义分别为：</p><table><thead><tr><th>Support值</th><th>含义</th></tr></thead><tbody><tr><td>DEFAULT</td><td>支持并启用,并且作为默认引擎</td></tr><tr><td>YES</td><td>支持并启用</td></tr><tr><td>NO</td><td>不支持</td></tr><tr><td>DISABLED</td><td>支持,但数据库启动时被禁用</td></tr></tbody></table></blockquote></li><li>修改表：使用ALTER TABLE语句将一个已经存在的表修改存储引擎：<code>ALTER TABLE t engine = xxx</code><blockquote><p>修改表的存储引擎需要锁表并复制数据，对于线上环境的表进行这个操作非常危险</p></blockquote></li></ul></li><li><p>常用存储引擎介绍</p><ul><li><p>特点对比：</p><table><thead><tr><th>特点</th><th>MyISAM</th><th>Memory</th><th>InnoDB</th><th>Archive</th><th>NDB</th></tr></thead><tbody><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>/</td><td>/</td></tr><tr><td>备份/时间点恢复</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持集群</td><td>/</td><td>/</td><td>/</td><td>/</td><td>支持</td></tr><tr><td>聚簇索引</td><td>/</td><td>/</td><td>支持</td><td>/</td><td>/</td></tr><tr><td>数据压缩</td><td>支持</td><td>/</td><td>支持</td><td>支持</td><td>/</td></tr><tr><td>数据缓存</td><td>/</td><td>N/A</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>数据加密</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持外键</td><td>/</td><td>/</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>/</td><td>支持</td><td>/</td><td>/</td></tr><tr><td>地理坐标数据类型</td><td>支持</td><td>/</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>地理坐标索引</td><td>支持</td><td>/</td><td>支持</td><td>/</td><td>/</td></tr><tr><td>哈希索引</td><td>/</td><td>支持</td><td>/</td><td>/</td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>N/A</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>锁粒度</td><td>表级</td><td>表级</td><td>行级</td><td>行级</td><td>行级</td></tr><tr><td>MVCC多版本控制</td><td>/</td><td>/</td><td>支持</td><td>/</td><td>/</td></tr><tr><td>支持复制</td><td>支持</td><td>有限支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td><td>384EB</td></tr><tr><td>T树索引</td><td>/</td><td>/</td><td>/</td><td>/</td><td>支持</td></tr><tr><td>支持事务</td><td>/</td><td>/</td><td>支持</td><td>/</td><td>支持</td></tr><tr><td>统计信息</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table></li><li><p>MyISAM</p></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>mysqld是MySQL的主程序(服务器端)；mysql是MySQL的命令行工具(客户端)</p></li><li><p>查看MySQL内部设置的编码：<code>SHOW VARIABLES LIKE &#39;character%&#39;</code></p></li><li><p>备份语句：<code>mysqldump -u username -p password database &gt; filePath</code></p><blockquote><p>mysqldump在bin文件目录下是一个可执行文件，用于执行文件备份<br>上述语句用于将数据库备份到本地文件(.sql)</p></blockquote></li><li><p>还原语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> <span class="keyword">database</span>;</span><br><span class="line">SOURCE filePath;</span><br></pre></td></tr></table></figure></li><li><p>查看帮助(MySQL CLI中)：</p><ol><li>显示所有可供查看的命令：? contents</li><li>显示具体信息：? xx</li></ol></li><li><p>查询元数据信息：information_schema系统数据库，是一个虚拟数据库，物理上并不存在相关的目录和文件；存储的全部是视图</p><blockquote><p>SCHEMA：提供当前MySQL实例中所有数据库的信息；show databaes的结果来源于该视图<br>  TABLES：提供了关于数据库中表的信息(包括视图)，详细表述了某个表属于哪个SCHEMA、表类型、表引擎、创建时间等信息；show tables from schemaName的结果来源于该视图<br>  COLUMNS：提供了表中的列信息，详细表述了某张表的所有列以及每个列的信息。show columns from schemaName.tableName的结果来源于该视图<br>  STATISTIC：提供了关于表索引的信息。show index from schemaName.tableName的结果来源于该视图</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Middleware </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC基础</title>
      <link href="/2020/12/08/SpringSeries/SpringMVC/SpringMVC%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/12/08/SpringSeries/SpringMVC/SpringMVC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#SpringMVC概述">SpringMVC概述</a></li><li><a href="#常用注解介绍">常用注解介绍</a></li><li><a href="#RestFul介绍">RestFul介绍</a></li><li><a href="#其他细节介绍">其他细节介绍</a></li><li><a href="#SpringMVC核心技术">SpringMVC核心技术</a></li></ul><a id="more"></a><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><ul><li><p>什么是MVC：</p><ul><li>MVC是模型(Model)、视图(View)和控制器(Controller)的简写，是一种软件设计规范。使用将业务逻辑、数据、显示分离的方式来组织代码，降低了视图与业务逻辑间的双向耦合。MVC是一种架构模式，不同的MVC也存在差异。最典型的MVC就是JSP + servlet + javaBean</li><li>MVC各自的解释：<ol><li>Model(模型)：数据模型，提供要展示的数据，包含数据和行为</li><li>View(视图)：负责进行模型的展示，一般指用户界面</li><li>Controller(控制器)：接收用户请求，委托给模型进行处理(状态改变)，处理完毕后把返回的模型数据返回给视图，由视图负责展示。控制器做了调度员的工作</li></ol></li></ul></li><li><p>MVC框架需要做的工作：</p><ol><li>将url映射到java类或java类的方法</li><li>封装用户提交的数据</li><li>处理请求：调用相关的业务处理、封装响应数据</li><li>将响应的数据进行渲染(jsp/html等表示层数据)</li></ol></li><li><p>简介：SpringMVC是Spring框架的一部分，是基于Java实现MVC的轻量级Web框架。围绕<strong>DispatcherServlet</strong>(调度Servlet)设计</p></li><li><p>优点：</p><ol><li>轻量级，简单易学</li><li>简洁、灵活、高效，基于请求响应的MVC框架</li><li>与Spring兼容性好，无缝结合</li><li>约定优于配置</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li></ol></li><li><p>SpringMVC的HelloWorld搭建：</p><ol><li><p>新建maven web项目</p></li><li><p>引入servlet、SpringMVC依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中注册中央处理器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册中央处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定SpringMVC配置文件路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 装载顺序 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 处理器拦截映射 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- /会匹配所有请求,/*才会匹配.jsp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>&lt;load-on-startup&gt;</p><blockquote><p>标记是否在Web服务器(Tomcat)启动时会创建这个Servlet实例，即是否在Web服务器启动时调用执行该Servlet的init()方法，而不是在真正访问时才创建。值必须是一个整数：</p><ol><li>当值大于等于0时，表示容器在启动时就加载并初始化这个Servlet；数值越小，该Servlet的优先级就越高，被创建的也就越早</li><li>当值小于0或者没有指定时，则表示该Servlet在真正被使用时才会去创建</li><li>当值相同时，容器会自己选择创建顺序</li></ol></blockquote></li><li><p>&lt;url-pattern/&gt;</p></li><li><p>&lt;init-param&gt;自定义SpringMVC配置文件地址</p><blockquote><p>默认要从项目根下的WEB-INF目录下找名称为Servlet名称-servlet.xml的配置文件(即springmvc-servlet.xml)，而一般情况下配置文件是放在类路径下(即resources目录下)。因此在注册中央调度器时还需要为中央调度器设置查找SpringMVC配置文件的路径<br>DispatcherServlet继承自FrameworkServlet，该类中有一个属性contextConfigLocation用于设置SpringMVC配置文件的路径及文件名</p></blockquote></li></ul></li><li><p>声明组件扫描器(Spring配置文件中)</p></li><li><p>定义目标页面(show.jsp)</p></li><li><p>创建处理器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/test.do"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Handle /test.do request ~~~"</span>);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    modelAndView.addObject(<span class="string">"msg"</span>, <span class="string">"testMsg"</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">"code"</span>, <span class="number">200</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">"/show.jsp"</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若有多个请求路径均可匹配该处理器方法的执行，则@RequestMapping的value属性可赋值一个数组<br>ModelAndView类中的addObject()方法用于向Model中添加数据。Model的底层为HashMap。<strong>Model中的数据存储在request作用域中，SringMVC默认采用转发的方式跳转到视图。本次请求结束，模型中的数据会被销毁</strong></p></blockquote></li><li><p>修改视图解析器的注册</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册视图解析器：帮助处理视图的路径和扩展名,生成视图对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册内部资源视图解析器InternalResourceViewResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 前缀：表示视图所在的路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/jsp/"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 后缀：表示视图文件的扩展名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了避免对于请求资源路径与扩展名上的冗余，在视图解析器InternalResouceViewResolver中引入请求的前辍与后辍。此时ModelAndView中只需给出要跳转页面的文件名即可。对于具体的文件路径与扩展名，视图解析器会自动完成拼接</p></blockquote></li><li><p>修改对应的处理器跳转地址和页面位置</p></li></ol></li><li><p>中心控制器DispatcherServlet：</p><ul><li>介绍：<br>Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。SpringMVC框架像许多其他MVC框架一样，以请求为驱动，围绕一个中心Servlet分派请求及提供其他功能。DispatcherServlet是一个实际的Servlet(它继承自HttpServlet基类)<br><img src="DispatcherServlet%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="DispatcherServlet类继承结构图"></li><li>SpringMVC的原理：<br>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者<br><img src="SpringMVC%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SpringMVC原理示意图"></li><li>SpringMVC执行逻辑：<br><img src="SpringMVC%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SpringMVC执行逻辑示意图"><ol><li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求<blockquote><p>假设请求的url为：<a href="http://localhost:8080/SpringMVC/hello" target="_blank" rel="noopener">http://localhost:8080/SpringMVC/hello</a><br>url可以拆分成三部分：</p><ol><li><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>：服务器域名</li><li>SpringMVC部署在服务器上的web站点</li><li>hello表示控制器</li></ol><p>如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器</p></blockquote></li><li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler</li><li>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器。示例url被查找控制器为hello</li><li>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等</li><li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</li><li>Handler让具体的Controller执行</li><li>Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView</li><li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet</li><li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名</li><li>视图解析器将解析的逻辑视图名传给DispatcherServlet</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图</li><li>最终视图呈现给用户</li></ol></li></ul></li></ul><h2 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h2><ul><li>@Controller：声明控制器，需要使用包扫描注册进Spring容器</li><li>@RequestMapping：定义请求规则<ul><li>value属性：定义处理器对于请求的映射规则。可以注解在方法上，也可以注解在类上。常以’/‘开始，用于定义所匹配请求的URI<ol><li>注解于类上：配合@Controller进行使用，表示类中所有响应请求方法以该地址作为父路径</li><li>注解于方法上：表示相对于父路径的请求地址</li></ol></li><li>method属性：用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE和TRACE等。支持指定多个method</li><li>produces属性：设置输出结果类型，可用于设置响应体格式和字符集<blockquote><p>例如：application/json;charset=utf-8；text/plain;charset=utf-8</p></blockquote></li></ul></li><li>@GetMapping、PostMapping、PutMapping、DeleteMapping、PatchMapping：组合注解，指定了请求方法的便于使用的@RequestMapping版本</li><li>@ResponseBody：用于将处理器的方法返回值转换为json</li><li>@RestController：相当于@Controller + @ResponseBody，相当于控制器当中每个处理器方法都使用@ResponseBody注解</li><li>@RequestParam：校正请求参数名<blockquote><p>所谓校正请求参数名，是指若请求URL所携带的参数名称与处理方法中指定的参数名不相同时，则需在处理方法参数前添加注解@RequestParam指定请求URL所携带参数的名称。该注解是对处理器方法参数进行修饰的，value属性指定请求参数的名称</p></blockquote></li><li>@PathVariable：使方法参数的值对应绑定到一个URI模版变量上<blockquote><p>路径变量的好处：</p><ol><li>使路径变得更加简洁</li><li>获得参数更加方便，框架会自动进行类型转换</li><li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法</li></ol></blockquote></li></ul><h2 id="RestFul介绍"><a href="#RestFul介绍" class="headerlink" title="RestFul介绍"></a>RestFul介绍</h2><ul><li>概念：Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制</li><li>优点：可以通过不同的请求方式来实现不同的效果。请求地址一样，但是功能可以不同<blockquote><p><a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 查询,GET<br><a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 新增,POST<br><a href="http://127.0.0.1/item" target="_blank" rel="noopener">http://127.0.0.1/item</a> 更新,PUT<br><a href="http://127.0.0.1/item/1" target="_blank" rel="noopener">http://127.0.0.1/item/1</a> 删除,DELETE</p></blockquote></li></ul><h2 id="其他细节介绍"><a href="#其他细节介绍" class="headerlink" title="其他细节介绍"></a>其他细节介绍</h2><ul><li><p>处理器方式参数：<br>处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，可在方法内直接使用</p><ol><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>请求中所携带的请求参数</li></ol></li><li><p>请求参数中文乱码：</p><ul><li><p>问题介绍：对于接收的请求参数，若含有中文，则会出现中文乱码问题。Spring对于请求参数中的中文乱码问题，给出了专门的字符集过滤器：org.springframework.web.filter包下的CharacterEncodingFilter类</p></li><li><p>解决方式：在web.xml中注册字符集过滤器即可解决Spring请求参数的中文乱码问题。不过最好将该过滤器注册在其它过滤器之前，因为过滤器的执行是按照注册顺序进行的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制request使用字符集encoding --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 强制response使用字符集encoding --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>处理器方式的返回值</p><ul><li>处理器方法常用返回值有四种类型：<ol><li>ModelAndView</li><li>String</li><li>void</li><li>自定义类型对象</li></ol></li><li>ModelAndView(适用于前后端不分离)<br>若处理器方法处理完后需要跳转到其它资源，且又要在跳转的资源间传递数据，此时处理器方法返回ModelAndView比较好。若要返回ModelAndView，则处理器方法中需要定义ModelAndView对象<br>若该处理器方法只是进行跳转而不传递数据，或只传递数据而并不向任何资源跳转(如对页面的Ajax异步响应)，此时若返回ModelAndView则将总有一部分多余————要么Model多余，要么View多余。此时返回ModelAndView将不合适</li><li>String(适用于前后端不分离)<br>处理器方法返回的字符串可以指定逻辑视图名，通过视图解析器(InternalResourceViewResolver内部资源视图解析器)解析可以将其转换为物理视图地址<br>也可以直接返回资源的物理视图名，此时就不需要在视图解析器中再配置前辍与后辍</li><li>返回void(了解)<br>若处理器对请求处理后无需跳转到其它任何资源，此时处理器方法可定义为返回void。例如对Ajax异步请求的响应，此时需要使用HttpServletResponse将返回结果通过writer写出</li><li>返回对象(常用,适用于前后端分离)<br>返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。常使用json格式返回，此时需要使用@ResponseBody注解于处理器方法上(将转换后的json数据放入到响应体中)<ol><li>在spring配置文件中配置&lt;mvc:annotation-driven/&gt;：Object数据转为Json数据需要消息转换器HttpMessageConverter完成。转换器的开启需要由&lt;mvc:annotation-driven/&gt;完成</li><li>导入jackson相关的包：spring的转换器底层依赖了jackson将对象转为json数据</li></ol></li></ul></li><li><p>&lt;url-pattern&gt;解读：</p><ul><li>*.xxx：一般情况下SpringMVC的中央调度器DispatcherServlet的&lt;url-pattern&gt;常使用后辍匹配方式，如写为*.do、*.action或*.mvc</li><li>/：此时中央调度器DispatcherServlet会拦截所有url，会将向静态资源(例如css、js、jpg、png等资源)的获取请求当作是一个普通的处理器请求。此时中央调度器会调用处理器映射器为其查找相应的处理器，这当然是找不到的。因此在这种情况下，所有的静态资源获取请求均会报404错误</li></ul></li><li><p>SpringMVC静态资源处理：</p><ol><li><p>&lt;mvc:default-servlet-handler/&gt;：声明了&lt;mvc:default-servlet-handler/&gt;后SpringMVC框架会在容器中创建DefaultServletHttpRequestHandler处理器对象。它像一个检查员，会对进入DispatcherServlet的URL进行筛查。如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理。一般的服务器都有默认的Servlet</p></li><li><p>&lt;mvc:resources/&gt;：在Spring3.0版本后，Spring定义了专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler。并且添加了&lt;mvc:resources/&gt;标签，专门用于解决静态资源无法访问问题</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  location：表示静态资源所在目录;目录不要使用/WEB-INF/及其子目录</span></span><br><span class="line"><span class="comment">  mapping：表示对该资源的映射后的请求地址</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>定义方式实现控制器：</p><ul><li><p>介绍：实现接口Controller定义控制器是较老的办法。且一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦</p></li><li><p>定义步骤：</p><ol><li><p>自定义控制器实现Controller接口，实现handleRequest方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个模型视图对象</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"msg"</span>,<span class="string">"TestController"</span>);</span><br><span class="line">    mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在SpringMVC配置文件中注册bean</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name对应请求路径,class对应处理请求的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/test"</span> <span class="attr">class</span>=<span class="string">"com.xiong.controller.TestController"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>结果跳转方式：</p><ol><li><p>ModelAndView：根据设置的view名称和视图解析器跳到指定的页面。页面：{视图解析器前缀} + viewName + {视图解析器后缀}</p></li><li><p>ServletApi：通过设置ServletAPI，不需要视图解析器</p><ol><li>通过HttpServletResponse进行输出：<code>httpServletResponse.getWriter().println(&quot;Hello~~~&quot;);</code></li><li>通过HttpServletResponse实现重定向：<code>httpServletResponse.sendRedirect(&quot;/index.jsp&quot;);</code></li><li>通过HttpServletResponse实现转发：<code>httpServletRequest.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(httpServletRequest, httpServletResponse);</code></li></ol></li><li><p>SpringMVC</p><ol><li><p>不使用视图解析器：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/test/t1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 转发</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/test/t2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 转发二</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/test/t3"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用视图解析器：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController2</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/test2/t1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//转发</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/test2/t2"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">    <span class="comment">// 重定向到另一个请求</span></span><br><span class="line">    <span class="comment">// return "redirect:hello.do";</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>数据接收：</p><ul><li>提交域名称和处理方法参数不一致：使用@RequestParam</li><li>提交的是一个表单对象：要求提交的表单域和对象属性名一致</li></ul></li><li><p>数据显示</p><ul><li><p>通过ModelAndView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个模型视图对象</span></span><br><span class="line">  ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">  mv.addObject(<span class="string">"msg"</span>,<span class="string">"hello"</span>);</span><br><span class="line">  mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">  <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过ModelMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 封装要显示到视图中的数据</span></span><br><span class="line">  <span class="comment">// 相当于req.setAttribute("name", "sobxiong");</span></span><br><span class="line">  model.addAttribute(<span class="string">"name"</span>, <span class="string">"sobxiong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Model：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 封装要显示到视图中的数据</span></span><br><span class="line">  <span class="comment">// 相当于req.setAttribute("name", "sobxiong");</span></span><br><span class="line">  model.addAttribute(<span class="string">"msg"</span>, <span class="string">"sobxiong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Model：只有寥寥几个方法，只适合用于储存数据，简化了对于Model对象的操作和理解<br>ModelMap：继承了LinkedMap，除了实现了自身的一些方法，同样继承了LinkedMap的方法和特性<br>ModelAndView：可以在储存数据的同时设置返回的逻辑视图，进行控制展示层的跳转</p></blockquote></li><li><p>使用配置实现返回结果转换为json(不常见)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"objectMapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"failOnEmptyBeans"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>jackson默认把时间转成timestamps形式</p></blockquote></li><li><p>表单中enctype属性说明：</p><ol><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的value属性值，采用这种编码方式的表单会将表单域中的值处理成URL编码方式</li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li><li>text/plain：除了把空格转换为’+’外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件</li></ol></li><li><p>文件上传：</p><ul><li><p>介绍：<br>Servlet3.0规范提供方法来处理文件上传，但这种上传需要在Servlet中完成<br>SpringMVC则提供了更简单的封装，为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的<br>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件<br>SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver<br>为了能上传文件，还必须将前端页面的表单method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器</p></li><li><p>使用步骤：</p><ol><li><p>导入commons-fileupload和servlet-api依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置bean：multipartResovler</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 请求的编码格式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上传文件大小上限,单位为字节(10485760=10M) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"10485760"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"40960"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写处理器方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/upload.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> CommonsMultipartFile file) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取文件名</span></span><br><span class="line">  String fileName = file.getOriginalFilename();</span><br><span class="line">  log.info(<span class="string">"File name: &#123;&#125; , size: &#123;&#125;"</span>, fileName, file.getSize());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果文件大小为0或文件名为空,返回失败</span></span><br><span class="line">  <span class="keyword">if</span> (file.getSize() == <span class="number">0</span> || StringUtils.isEmpty(fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建文件上传路径</span></span><br><span class="line">  File uploadDirectory = <span class="keyword">new</span> File(<span class="string">"/Users/sobxiong/Downloads"</span>);</span><br><span class="line">  <span class="comment">// 文件输入流</span></span><br><span class="line">  <span class="keyword">try</span> (InputStream is = file.getInputStream();</span><br><span class="line">    OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(uploadDirectory, fileName))) &#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">      os.flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">"IOException"</span>, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方式2</span></span><br><span class="line">  <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">      file.transferTo(Paths.get("/Users/sobxiong/Downloads/" + fileName));</span></span><br><span class="line"><span class="comment">  &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">      log.error("IOException", e);</span></span><br><span class="line"><span class="comment">      return "error";</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CommonsMultipartFile的常用方法：</p><ol><li>String getOriginalFilename()：获取上传文件的原名</li><li>InputStream getInputStream()：获取文件流</li><li>void transferTo(File dest)：将上传文件保存到一个目录文件中</li></ol></blockquote></li></ol></li></ul></li></ul><h2 id="SpringMVC核心技术"><a href="#SpringMVC核心技术" class="headerlink" title="SpringMVC核心技术"></a>SpringMVC核心技术</h2><ul><li><p>请求转发和重定向：</p><ul><li><p>介绍：<br>当处理器对请求处理完毕后，向其它资源进行跳转时，有两种跳转方式：<strong>请求转发</strong>与<strong>重定向</strong>。根据所要跳转的资源类型，又可分为两类：<strong>跳转到页面</strong>与<strong>跳转到其它处理器</strong></p><blockquote><p>对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，不能为WEB-INF中页面。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问WEB-INF中资源的</p></blockquote><p><img src="%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="请求转发和重定向示意图"></p></li><li><p>原理：SpringMVC框架把原来Servlet中的请求转发和重定向操作进行了封装。现在可以使用简单的方式实现转发和重定向：</p><ol><li>forward：表示转发，示例如下：<br> <code>request.getRequestDispatcher(&quot;xx.jsp&quot;).forward()</code></li><li>redirect：表示重定向，示例如下：<br> <code>response.sendRedirect(&quot;xxx.jsp&quot;)</code></li></ol></li><li><p>请求转发：</p><ol><li>处理器方法返回ModelAndView时，可在setViewName()指定的视图前添加 “forward:”，此时视图不再与视图解析器一同工作，这样可在配置了解析器时指定不同位置的视图。视图页面必须写出相对于项目根的路径。forward操作不需要视图解析器</li><li>处理器方法返回String时，需在视图路径前面加入”forward:视图完整路径”</li></ol></li><li><p>请求重定向(同请求转发,把forward替换为redirect)</p></li></ul></li><li><p>异常处理：</p><ul><li><p>介绍：SpringMVC框架常用@ExceptionHandler和@ControllerAdvice注解处理异常</p></li><li><p>@ExceptionHandler注解：</p><ul><li><p>介绍：<br>使用注解@ExceptionHandler可以将一个方法指定为异常处理方法。该注解只有一个可选属性value(Class&lt;?&gt;数组)，该属性用于指定该注解的方法所要处理的异常类(即需要匹配的异常)<br>被注解的方法返回值可以是ModelAndView、String或void，方法名随意，方法参数可以是Exception及其子类对象、HttpServletRequest、HttpServletResponse等。系统会自动为这些参数赋值</p></li><li><p>使用步骤：</p><ol><li><p>准备(自定义异常,自定义异常响应页面等)</p></li><li><p>在处理器方法上添加注解：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(value = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">doException</span>(<span class="title">Throwable</span> <span class="title">t</span>) </span>&#123;</span><br><span class="line">  ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">  mv.addObject(<span class="string">"exception"</span>, t);</span><br><span class="line">  mv.setViewName(<span class="string">"error"</span>);</span><br><span class="line">  <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过一般不这样使用，而是将异常处理方法专门定义在一个类中，作为全局的异常处理类</p></blockquote></li></ol></li></ul></li><li><p>@ControllerAdvice注解：</p><ul><li><p>介绍：<br>ControllerAdvice字面意思就是”控制器增强”，用于给控制器对象增强功能。使用@ControllerAdvice注解修饰的类中可以使用@ExceptionHandler。当使用@RequestMapping注解修饰的方法抛出异常时，会执行@ControllerAdvice修饰的类中的对应异常处理方法<br>@ControllerAdvice由@Component注解修饰，需要由包扫描组件支持</p></li><li><p>使用步骤：</p><ol><li><p>添加启动包扫描和注册注解驱动的xml配置</p></li><li><p>定义全局异常处理类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">doException</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"exception"</span>,e);</span><br><span class="line">    mv.setViewName(<span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(value = ArithmeticException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">doArithmeticException</span>(<span class="title">ArithmeticException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"arithmeticException"</span>,e);</span><br><span class="line">    mv.setViewName(<span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li><li><p>拦截器</p><ul><li><p>介绍：SpringMVC中的Interceptor拦截器非常重要，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间节点在”处理器映射器根据用户提交的请求映射出了所要执行的处理器类,并且也找到了要执行该处理器类的处理器适配器,在处理器适配器执行处理器之前”。在处理器映射器映射出所要执行的处理器类时，已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器</p></li><li><p>拦截器HandlerInterceptor：</p><ul><li>介绍：自定义拦截器，需要实现HandlerInterceptor接口</li><li>接口方法介绍：<ol><li><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>：该方法在处理器方法执行之前执行。其返回值为 boolean，若为true，则紧接着会执行处理器方法，且会将afterCompletion()方法放入到一个专门的方法栈中等待执行</li><li><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code>：该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。由于该方法是在处理器方法执行完后执行，且该方法参数中包含ModelAndView，因此该方法可以修改处理器方法的处理结果数据，且可以修改跳转地址</li><li><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code>： 当preHandle()方法返回true时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有工作完成之后才执行该方法。即该方法是在中央调度器渲染(数据填充)了响应页面之后执行的，此时对ModelAndView的操作也对响应没有影响。该方法是最后执行的方法，一般用于清除资源</li></ol></li></ul></li><li><p>使用步骤：</p><ol><li><p>定义拦截器对象：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"preHandle() ~~~"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"postHandle() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"afterCompletion() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册拦截器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      &lt;mvc:mapping&gt;：用于指定当前注册的拦截器可以拦截的请求路径,/**表示拦截所有请求,可以设置多个</span></span><br><span class="line"><span class="comment">      /**包括路径及其自路径</span></span><br><span class="line"><span class="comment">      /*只会拦截/xx而不会拦截/xx/xx</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xiong.springmvc.controller.MyInterceptor"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;mvc:interceptor&gt;可以设置多个  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Structure</title>
      <link href="/2020/12/03/BasicSkill/DataStructure/"/>
      <url>/2020/12/03/BasicSkill/DataStructure/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="并查集">并查集</a></li><li><a href="#Trie字典树">Trie字典树</a></li><li><a href="#树状数组">树状数组</a></li><li><a href="#平衡二叉查找树">平衡二叉查找树</a></li></ul><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul><li><p>介绍：并查集是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示</p></li><li><p>核心思想：<strong>用集合的一个元素代表集合</strong></p></li><li><p>主要操作：</p><ul><li>合并(Union)：把两个不相交的集合合并为一个集合</li><li>查询(Find)：查询两个元素是否在同一个集合</li></ul></li><li><p>过程图示：</p><ol><li>假设有六个元素，首先初始化(各自为战)<br> <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA1.jpg" alt="并查集图示1"></li><li>元素3与元素1合并<br> <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA2.jpg" alt="并查集图示2"></li><li>元素2与元素1合并<br> <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA3.jpg" alt="并查集图示3"></li><li>同理元素5、6和元素4合并<br> <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA4.jpg" alt="并查集图示4"></li><li>元素1与元素4合并<br> <img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA5.png" alt="并查集图示5"></li></ol></li><li><p>路径压缩：最原始的并查集效率是很低的，如果以最坏的情况合并，则会变成链表，查找最底部的元素的父元素需要花费O(n)时间<br><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA6.png" alt="并查集图示6"><br>既然只考虑一个元素对应的<strong>根节点</strong>而不是所有的祖先节点(每个元素到根节点的路径尽可能短)，那么最好的情况就是形成仅为两层的树<br><img src="%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9B%BE%E7%A4%BA7.png" alt="并查集图示7"></p></li><li><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="keyword">int</span> unionSet[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化,将元素的根元素设置为自身</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    unionSet[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询元素n的根元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面逻辑的简化写法</span></span><br><span class="line">  <span class="keyword">return</span> n == unionSet[n] ? n : (unionSet[n] = find_root(unionSet[n]));</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  // 如果当前元素就是根元素,返回自身</span></span><br><span class="line"><span class="comment">  if (unionSet[n] == n) return n;</span></span><br><span class="line"><span class="comment">  // 得到当前元素的根元素</span></span><br><span class="line"><span class="comment">  int root = find_root(n);</span></span><br><span class="line"><span class="comment">  // 压缩路径(延迟压缩,只有在合并后的首次查询才进行),将当前查询链上的元素的根元素设置为root</span></span><br><span class="line"><span class="comment">  unionSet[n] = root;</span></span><br><span class="line"><span class="comment">  return root;</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并元素n1、n2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_elements</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将n1元素的root值设置为n2元素的root值</span></span><br><span class="line">  unionSet[find_root(n1)] = find_root(n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><ul><li><p>介绍：又称单词查找树、Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计、排序和保存大量的字符串(但不仅限于字符串)，所以经常被搜索引擎系统用于文本词频统计。优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</p></li><li><p>核心思想：空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</p></li><li><p>三个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ol></li><li><p>基本操作：查找、插入和删除(删除较为少见)</p></li><li><p>举例：<br>单词组：banana、band、bank、apple、apply、applet<br>图示：<br><img src="Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%9B%BE%E7%A4%BA.png" alt="Trie字典树图示"></p></li><li><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装字典树节点数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 是否为单词结尾字符的标记</span></span><br><span class="line">    <span class="keyword">bool</span> wordTag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计数标记,用于删除</span></span><br><span class="line">    <span class="keyword">int</span> countTag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下层节点,26个指针的数组(a-z),并显式赋值为nullptr</span></span><br><span class="line">    TrieNode *next[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从头节点开始</span></span><br><span class="line">      TrieNode *cur = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c : <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果查找的字符节点为空则创建</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;next[c - <span class="string">'a'</span>]) cur-&gt;next[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="comment">// 前往下一层节点,表示当前字符已满足</span></span><br><span class="line">        cur = cur-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">        <span class="comment">// 技术标记增加</span></span><br><span class="line">        cur-&gt;countTag++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录当前是单词结尾字符</span></span><br><span class="line">      cur-&gt;wordTag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从头节点开始</span></span><br><span class="line">      TrieNode *cur = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c : <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果查找的字符节点为空则返回false,查询不到</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;next[c - <span class="string">'a'</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cur = cur-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回当前节点是否为单词结尾</span></span><br><span class="line">      <span class="keyword">return</span> cur-&gt;wordTag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchPrefix</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">      TrieNode *cur = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c : <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;next[c - <span class="string">'a'</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cur = cur-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回true,前缀无需关注是否为单词节点</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体测试</span></span><br><span class="line">TrieNode root;</span><br><span class="line">root.insert(<span class="string">"banana"</span>);</span><br><span class="line">root.insert(<span class="string">"band"</span>);</span><br><span class="line">root.insert(<span class="string">"bank"</span>);</span><br><span class="line">root.insert(<span class="string">"apple"</span>);</span><br><span class="line">root.insert(<span class="string">"apply"</span>);</span><br><span class="line">root.insert(<span class="string">"applet"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.search(<span class="string">"banana"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.search(<span class="string">"banan"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.searchPrefix(<span class="string">"apply"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.search(<span class="string">"apply"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.searchPrefix(<span class="string">"appl"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root.search(<span class="string">"appl"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><ul><li><p>介绍：树状数组是一个查询和修改复杂度都为logn的数据结构。主要用于数组的单点修改以及区间求和</p></li><li><p>背景问题：有一个数组a，下标从1到n。现在需要进行w次修改、q次查询，修改指修改数组中某一个元素的值；查询指查询数组中任意一个区间的和</p></li><li><p>问题分析：首先分析下朴素做法的时间复杂度，修改是O(1)的时间复杂度，而查询的话是O(n)的复杂度，总体时间复杂度为O(qn)；可能会想到使用前缀和来优化这个查询，此时查询的复杂度为O(1)，而修改时需要修改修改点之后的所有前缀和，因此修改的时间复杂度是O(n)，总体时间复杂度还是O(qn)。而树状数组的做法综合了这两种朴素方式，降低了整体时间复杂度</p></li><li><p>树状数组</p><ul><li><p>lowbit函数</p><ul><li>作用：求某个数的二进制表示中最低的一位1</li><li>代码表示：<code>int lowbit(int x) return x &amp; -x;</code></li><li>原理：<br><img src="lowbit%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86.png" alt="lowbit函数原理"></li></ul></li><li><p>核心思想：设原数组为a，节点值为A1～An，新开辟的数组为c，节点值为C1～Cn。每个节点不知管辖当前节点的值，而是管辖一个区域的数据。设节点编号为x，那么这个节点管辖的区间为2^k(其中k为x的二进制末尾0的个数)个元素。且区间最后一个元素必为Ax</p><blockquote><p><img src="%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%AE%A1%E8%BE%96%E5%8C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="树状数组管辖区示意图"><br>C1 = A1<br>C2 = A1 + A2<br>C3 = A3<br>C4 = A1 + A2 +A3 + A4<br>C5 = A5<br>C6 = A5 + A6<br>C7 = A7<br>C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8<br>…</p></blockquote></li><li><p>关键操作</p><ol><li>获取前缀和：通过二进制拆分获取所需下标。比如13的前缀和，13的二进制为1101，根据末尾的1获取数，每次抹去最后一个1。得到三个值1101(13,管辖2^0=1个数)、1100(12,管辖2^2=4个数)和1000(8,管辖2^3=8个数)，因此Sum(0~13) = C8 + C12 + C13。因此单次查询复杂度为O(logn)</li><li>单点修改：必须修改每个包含修改值的C元素，相当于查询的逆过程。以6为例，6的二进制值为0110，在末尾1处加1，得到1000(8)；再在末尾1处加1，得到10000(16)，完成，共需修改6、8、16处节点的值。因此单次修改复杂度也为O(logn)</li></ol></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求某个数的二进制表示中最低的一位1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询1~x的前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    ans += c[x];</span><br><span class="line">    x -= lowbit(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对Ax原值基础上加上一个值v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt; c.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    c[x] += v;</span><br><span class="line">    x += lowbit(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展：区间修改</p><blockquote><p>比如将C区间[3, 6]的每个数都加上5，只需对C3加5，C7减5，因为C[3, 6]被C3影响，而C7~Cn受到C7和C3的共同影响，结果不变</p></blockquote></li></ul></li></ul><h2 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h2><ul><li><p>介绍：AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树</p></li><li><p>背景问题：二叉树最差查找节点的效率近似于单链表</p></li><li><p>核心操作：</p><ol><li><p>插入</p></li><li><p>删除</p><blockquote><p><img src="AVL%E5%9B%BE%E7%A4%BA1.png" alt="AVL初始情况"><br>删除共有4种情况</p><ol><li>既有左孩子又有右孩子</li><li>只有左孩子</li><li>只有右孩子</li><li>叶子节点</li></ol></blockquote></li><li><p>自平衡</p></li></ol></li><li><p>实现代码：</p><ol><li><p>数据结构：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">private</span> V value;</span><br><span class="line">  <span class="keyword">private</span> Node left, right, parent;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nodeNum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入操作：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录原始节点数</span></span><br><span class="line">  <span class="keyword">int</span> nodeNum = root == <span class="keyword">null</span> ? <span class="number">0</span> : root.nodeNum;</span><br><span class="line">  <span class="comment">// 具体插入,统一有无根节点情况</span></span><br><span class="line">  root = put(root, key, value, root);</span><br><span class="line">  <span class="comment">// 如果是修改操作,无需进行自平衡</span></span><br><span class="line">  <span class="keyword">if</span> (nodeNum == root.nodeNum) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 找到插入节点</span></span><br><span class="line">  Node putNode = findNode(root, key);</span><br><span class="line">  <span class="comment">// 平衡整棵树</span></span><br><span class="line">  balance(putNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归插入</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node, K key, V value, Node parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回具体插入的节点</span></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, parent);</span><br><span class="line">  <span class="comment">// 判断查找方向</span></span><br><span class="line">  <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">  <span class="comment">// 更新节点值</span></span><br><span class="line">  <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">    node.value = value;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向右插入</span></span><br><span class="line">  <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) node.right = put(node.right, key, value, node);</span><br><span class="line">  <span class="comment">// 向左插入</span></span><br><span class="line">  <span class="keyword">else</span> node.left = put(node.left, key, value, node);</span><br><span class="line">  <span class="comment">// 更新当前节点挂载的节点数</span></span><br><span class="line">  node.nodeNum = <span class="number">1</span> + size(node.left) + size(node.right);</span><br><span class="line">  <span class="comment">// 返回当前节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">size</span><span class="params">()</span> &gt; 0</span>;</span><br><span class="line">  <span class="comment">// 查找具体删除节点</span></span><br><span class="line">  Node delNode = findNode(root, key);</span><br><span class="line">  <span class="keyword">if</span> (delNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 删除节点并自平衡</span></span><br><span class="line">  balance(delete(delNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除指定节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 待删除节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 替代节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node parent = node.parent, temp;</span><br><span class="line">  <span class="comment">// 只有左孩子</span></span><br><span class="line">  <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    temp = node;</span><br><span class="line">    <span class="comment">// 指向左孩子</span></span><br><span class="line">    node = node.left;</span><br><span class="line">    node.parent = temp.parent;</span><br><span class="line">    <span class="comment">// 更新当前节点高度信息</span></span><br><span class="line">    updateDepth(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123; <span class="comment">// 只有右孩子</span></span><br><span class="line">    temp = node;</span><br><span class="line">    <span class="comment">// 指向右孩子</span></span><br><span class="line">    node = node.right;</span><br><span class="line">    node.parent = temp.parent;</span><br><span class="line">    <span class="comment">// 更新当前节点高度信息</span></span><br><span class="line">    updateDepth(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123; <span class="comment">// 叶子结点</span></span><br><span class="line">    <span class="comment">// 如果父节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新父节点高度信息</span></span><br><span class="line">      updateDepth(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除根节点</span></span><br><span class="line">      root = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右孩子均存在</span></span><br><span class="line">    <span class="comment">// 找到替代元素</span></span><br><span class="line">    temp = min(node.right);</span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    node.value = temp.value;</span><br><span class="line">    parent = temp.parent;</span><br><span class="line">    updateDepth(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自平衡操作：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LR旋转：先左旋转再右旋转</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 离操作节点最近的失衡节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 新父节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">LRRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  RRRotate(node.left);</span><br><span class="line">  <span class="keyword">return</span> LLRotate(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LL旋转</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 离操作节点最近的失衡节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 新父节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">LLRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取失衡节点的父节点和左孩子</span></span><br><span class="line">  Node parent = node.parent, child = node.left;</span><br><span class="line">  <span class="comment">// 设置child右孩子的父指针</span></span><br><span class="line">  <span class="keyword">if</span> (child.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    child.right.parent = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 失衡节点的做孩子变更为child的右孩子</span></span><br><span class="line">  node.left = child.right;</span><br><span class="line">  <span class="comment">// 更新失衡节点的高度信息</span></span><br><span class="line">  updateDepth(node);</span><br><span class="line">  <span class="comment">// 失衡节点变成child的右孩子</span></span><br><span class="line">  child.right = node;</span><br><span class="line">  <span class="comment">// 设置child的父节点为原失衡节点的父节点</span></span><br><span class="line">  child.parent = parent;</span><br><span class="line">  <span class="comment">// 如果失衡节点不是根,更新父节点</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 指向更新后的新孩子child</span></span><br><span class="line">    <span class="keyword">if</span> (parent.left == node) parent.left = child;</span><br><span class="line">    <span class="keyword">else</span> parent.right = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置失衡节点的父亲</span></span><br><span class="line">  node.parent = child;</span><br><span class="line">  <span class="comment">// 更新child节点的高度信息</span></span><br><span class="line">  updateDepth(child);</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* RL旋转：先右旋转再左旋转</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 离操作节点最近的失衡节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 新父节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RLRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  LLRotate(node.right);</span><br><span class="line">  <span class="keyword">return</span> RRRotate(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* RR旋转</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 离操作结点最近的失衡的结点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 新父节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RRRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取失衡节点的父节点和右孩子</span></span><br><span class="line">  Node parent = node.parent, child = node.right;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置child节点左孩子的父指针</span></span><br><span class="line">  <span class="keyword">if</span> (child.left != <span class="keyword">null</span>) child.left.parent = node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 失衡节点的右孩子变更为child的左孩子</span></span><br><span class="line">  node.right = child.left;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新失衡节点的高度信息</span></span><br><span class="line">  updateDepth(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 失衡节点变成child的左孩子</span></span><br><span class="line">  child.left = node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置child的父结点为原失衡节点的父结点</span></span><br><span class="line">  child.parent = parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果失衡节点不是根结点,更新父节点</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 指向更新后的新孩子child</span></span><br><span class="line">    <span class="keyword">if</span> (parent.left == node) parent.left = child;</span><br><span class="line">    <span class="keyword">else</span> parent.right = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置失衡节点的父节点</span></span><br><span class="line">  node.parent = child;</span><br><span class="line">  <span class="comment">// 更新child结点的高度信息</span></span><br><span class="line">  updateDepth(child);</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* AVL树调整</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node 插入的节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">balance</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 平衡因子</span></span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新当前节点的高度信息</span></span><br><span class="line">    updateDepth(node);</span><br><span class="line">    <span class="comment">// 获取当前节点的平衡因子信息</span></span><br><span class="line">    balance = getBalance(node);</span><br><span class="line">    <span class="comment">// 不平衡</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> || balance &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 左子树高</span></span><br><span class="line">      <span class="keyword">if</span> (balance &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// LL型</span></span><br><span class="line">        <span class="keyword">if</span> (getBalance(node.left) &gt; <span class="number">0</span>) node = LLRotate(node);</span><br><span class="line">        <span class="keyword">else</span> node = LRRotate(node); <span class="comment">// LR型</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右子树高</span></span><br><span class="line">        <span class="comment">// RR型</span></span><br><span class="line">        <span class="keyword">if</span> (getBalance(node.right) &lt; <span class="number">0</span>) node = RRRotate(node);</span><br><span class="line">        <span class="keyword">else</span> node = RLRotate(node); <span class="comment">// RL型</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否到达根节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置新的根节点</span></span><br><span class="line">        root = node;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次设置父节点</span></span><br><span class="line">    node = node.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础</title>
      <link href="/2020/12/03/SpringSeries/Spring/Spring%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/12/03/SpringSeries/Spring/Spring%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#Spring概述">Spring概述</a></li><li><a href="#IOC控制反转">IOC控制反转</a></li><li><a href="#AOP面向切面编程">AOP面向切面编程</a></li><li><a href="#事务操作">事务操作</a></li><li><a href="#Spring5新功能">Spring5新功能</a></li></ul><a id="more"></a><h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><ul><li>Spring是什么：Spring是于2003年兴起的一个轻量级的Java开发框架，是为了解决企业应用开发的复杂性而创建的。核心是<strong>控制反转(IoC)</strong>和<strong>面向切面编程(AOP)</strong></li><li>Spring的优点：<ol><li>轻量：Spring框架使用的jar都比较小，核心功能的所需的jar总共在3M左右。框架运行占用的资源少，运行效率高。不依赖其他jar</li><li>解耦合：提供了Ioc控制反转，由容器管理对象和对象的依赖关系。原来在程序代码中的对象创建方式现在由容器完成。对象之间的依赖解耦合</li><li>AOP编程的支持</li><li>方便集成各种优秀框架</li></ol></li><li>Spring体系结构：<br><img src="Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Spring体系结构示意图"><br>Spring由20多个模块组成，可以分为数据访问/集成(Data Access/Integration)、Web、面向切面编程(AOP, Aspects)、提供JVM的代理(Instrumentation)、消息发送(Messaging)、核心容器(Core Container)和测试(Test)</li></ul><h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><ul><li><p>Ioc介绍：<br>控制反转(IoC, Inversion of Control)是一个概念、一种思想。指<strong>将传统上由程序代码直接操控的对象控制权交给容器，通过容器来实现对象的装配和管理</strong>。控制反转就是将对象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建、属性赋值、依赖的管理<br>IoC的实现方式多种多样，当前比较流行的实现方式是依赖注入(DI)<br><strong>依赖</strong>：A类中含有B的实例，在A实例中调用B实例的方法完成功能，即类A对类B存在依赖<br><strong>依赖注入(DI, Dependency Injection)</strong>：指程序运行过程中若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序<br>Spring使用依赖注入(DI)实现IoC。Spring的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间依赖关系的管理。Spring容器是一个超级工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。Spring容器管理着容器中Bean之间的依赖关系</p></li><li><p>IOC实现基本介绍：</p><ul><li>IOC思想基于IOC容器实现，IOC容器底层就是对象工厂</li><li>Spring提供IOC容器实现的两种方式(两种接口)：<ol><li>BeanFactory：IOC容器的基本实现，是Spring内部的使用接口，不提供开发人员进行使用。加载配置文件时不会创建对象，在获取对象(使用)才去创建对象</li><li>ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。加载配置文件时候就会把在配置文件对象进行创建<br> <img src="BeanFactory%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="BeanFactory继承结构图"></li></ol></li><li>具体ApplicationContext容器创建方式：<ol><li>基于xml：<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;chapter2/bean1.xml&quot;);</code></li><li>基于注解：<code>ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</code></li></ol></li><li>ApplicationContext容器对象的装配时机：在容器对象初始化时，将其中的所有对象一次性全部装配好。以后代码中使用到这些对象只需从内存中直接获取即可。执行效率较高，但内存占用较多</li></ul></li><li><p>IOC管理Bean</p><ul><li><p>什么是Bean管理：</p><ol><li>Spring创建对象</li><li>Spring注入属性</li></ol></li><li><p>Bean管理的两种方式：</p><ul><li><p>基于xml：</p><ul><li><p>基础语法：<code>&lt;bean id=&quot;user&quot; class=&quot;chapter1.User&quot;/&gt;</code></p><ol><li>bean标签用于实现对象的创建</li><li>常用属性有：<ol><li>id：唯一标识</li><li>class：类全路径(包类路径)，只能是类，不能是接口</li></ol></li><li>默认通过反射调用无参构造器创建对象</li></ol></li><li><p>指定多个配置文件：</p><blockquote><p>多个配置文件中有一个总文件，总配置文件将各其它子文件通过&lt;import/&gt;引入。在Java代码中只需要使用总配置文件对容器进行初始化即可<br>也可使用通配符<em>，此时要求父配置文件名不能满足</em>所能匹配的格式，否则将出现循环递归包含</p></blockquote></li><li><p>属性注入方式：</p><ol><li><p>通过setter注入(最常用)：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bean对应类需要有对应的setter方法 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引用类型通过ref指定引用关系,ref值为某bean的id值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bName"</span> <span class="attr">value</span>=<span class="string">"深入理解JVM"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bAuthor"</span> <span class="attr">value</span>=<span class="string">"周志明"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过有参构造函数注入(一般不用)：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bean对应类需要有对应的有参构造器 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- index指明对应构造器的第几个参数,从0开始,一般不用,顺序与构造器声明顺序一致 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"bName"</span> <span class="attr">value</span>=<span class="string">"深入理解JVM"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"bAuthor"</span> <span class="attr">value</span>=<span class="string">"周志明"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过p名称空间注入(也是调用setter方法,方式不同,一般不用)：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加p名称空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span> <span class="attr">p:bName</span>=<span class="string">"深入理解JVM"</span> <span class="attr">p:bAuthor</span>=<span class="string">"周志明"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动装配：根据指定装配规则(属性名称或者属性类型)，Spring自动将匹配的属性值进行注入</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  bean标签属性autowire配置自动装配,常用的两个配置：</span></span><br><span class="line"><span class="comment">  byName：根据属性名称注入,注入属性的bean的id值和属性名称一样</span></span><br><span class="line"><span class="comment">  byType：根据属性类型注入(要么与属性类型相同,要么有继承或实现的关系,但同源的bean只能有一个,多于一个容器就不知道如何匹配)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"employee"</span> <span class="attr">class</span>=<span class="string">"chapter1.Employee"</span> <span class="attr">autowire</span>=<span class="string">"byName/byType"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"SOBXiong"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"23"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dept"</span> <span class="attr">class</span>=<span class="string">"chapter1.Department"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"独栋小别墅"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"90001"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>导入外部属性文件(properties文件)：</p><p> 传统声明方式</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 导入properties文件方式</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="meta">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">prop.password</span>=<span class="string">password</span></span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部属性文件(需要引入context名称空间) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池配置(引入properties文件) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;prop.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;prop.url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;prop.userName&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;prop.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>注入属性类型：</p><ul><li><p>字面量：</p><ol><li><p>null值</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊字符</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用&lt;![CDATA[]]转义 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用&amp;lt;/&amp;gt;代表'&lt;'和'&gt;' --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;value&gt;&amp;lt;&amp;lt;南京&amp;gt;&amp;gt;&lt;/value&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>外部bean：</p><ol><li><p>引用外部bean</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"chapter1.Person"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"SOBXiong"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"book"</span> <span class="attr">ref</span>=<span class="string">"book1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"book1"</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"BName"</span> <span class="attr">value</span>=<span class="string">"并发编程实战"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"BAuthor"</span> <span class="attr">value</span>=<span class="string">"Doug Li"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部bean赋值</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"chapter1.Person"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"SOBXiong"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"book"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"BName"</span> <span class="attr">value</span>=<span class="string">"并发编程实战"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"BAuthor"</span> <span class="attr">value</span>=<span class="string">"Doug Li"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联赋值</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用设置重复属性会覆盖原来外部bean设置的属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"chapter1.Person"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"SOBXiong"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"book"</span> <span class="attr">ref</span>=<span class="string">"book1"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"book.BAuthor"</span> <span class="attr">value</span>=<span class="string">"Doug Li"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"book.BName"</span> <span class="attr">value</span>=<span class="string">"并发编程实战1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"book1"</span> <span class="attr">class</span>=<span class="string">"chapter1.Book"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"BName"</span> <span class="attr">value</span>=<span class="string">"并发编程实战"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>数组/集合类：</p><ol><li><p>使用内置标签：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ref同理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"chapter1.Student"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入数组 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arrayValue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>array01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>array02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>array03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入List --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"listValue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>list01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>list02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>list03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入Map --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapValue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mapKey01"</span> <span class="attr">value</span>=<span class="string">"mapValue01"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mapKey02"</span> <span class="attr">value</span>=<span class="string">"mapValue02"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"mapKey03"</span> <span class="attr">value</span>=<span class="string">"mapValue03"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入Set --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"setValue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>setValue01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>setValue02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>setValue03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用util名称空间</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用util标签注入list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"testList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>utilList01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>utilList02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>utilList03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student1"</span> <span class="attr">class</span>=<span class="string">"chapter1.Student"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"listValue"</span> <span class="attr">ref</span>=<span class="string">"testList"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li><li><p>基于注解：</p><ul><li><p>Spring针对Bean创建对象的注解类型(功能是一样的,名称只是规范和区别作用)：</p><ol><li>@Component</li><li>@Service</li><li>@Controller</li><li>@Repository</li></ol></li><li><p>基于注解方式实现对象创建(引入spring-aop依赖)：</p><ul><li><p>开启组件扫描</p><ol><li><p>xml方式：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1、可以使用多个context:component-scan标签指定不同的包路径</span></span><br><span class="line"><span class="comment">  2、指定base-package的多个值可以使用分隔符(逗号、分号或空格均可,但不建议空格)</span></span><br><span class="line"><span class="comment">  3、base-package代表指定到父包名,容器启动会扫描包及其子包中的注解</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"chapter2"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类注解(替代xml配置文件)方式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 作为配置类,替代xml</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"chapter2"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>组件扫描规则设置：</p><ol><li>use-default-filters：是否使用默认filter(扫描@Component、@Service、@Controller、@Repository,默认true)，为true时不能和exclude-filter配合使用</li><li>include-filter：设置扫描哪些内容</li><li>exclude-filter：设置不扫描哪些内容</li></ol></li><li><p>创建Bean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value属性值表示bean的id,可省略,默认是类名的首字母小写</span></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService method1() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性注入(注解在field字段上,无需setter)：</p><ol><li>@Autowired：根据属性类型进行自动装配(required属性可指定是否忽略注入失败,默认true)</li><li>@Qualifier：根据名称进行注入，需要和@Autowired一起使用</li><li>@Resource：默认根据名称注入，可通过value和name属性指定注入规则(可以加到setter()上)</li><li>@Value：注入普通类型属性，常量/配置文件中的值(可以加到setter()上)</li></ol></li></ul></li></ul></li></ul></li><li><p>Bean的类型：</p><ol><li><p>普通bean：在配置文件中定义的bean类型就是返回类型</p></li><li><p>工厂bean(FactoryBean)：在配置文件定义的bean类型可以和返回类型不一样</p><ul><li><p>工厂bean创建的步骤：</p><ol><li>自定义类实现接口FactoryBean，作为工厂bean</li><li>实现接口里面的方法，在实现的方法中定义返回的bean类型</li><li>在xml中定义</li></ol></li><li><p>具体案例：</p><p><code>自定义工厂bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Course</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Course对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Course <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Course course = <span class="keyword">new</span> Course();</span><br><span class="line">    course.setId(<span class="number">1L</span>);</span><br><span class="line">    course.setName(<span class="string">"分布式系统"</span>);</span><br><span class="line">    <span class="keyword">return</span> course;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123; <span class="keyword">return</span> Course<span class="class">.<span class="keyword">class</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring的xml配置文件</code><br><code>&lt;bean id=&quot;testBeanFactory&quot; class=&quot;chapter1.TestBeanFactory&quot;/&gt;</code></p></li></ul></li></ol></li><li><p>Bean的作用域</p><ol><li>Singleton：单实例，Spring默认的Bean作用域；加载Spring配置文件时就会创建单实例对象</li><li>Prototype：多实例，在调用getBean()方法时创建多实例对象</li></ol></li><li><p>Bean的生命周期</p><ul><li><p>生命周期介绍：从对象创建到销毁的过程</p></li><li><p>具体生命周期过程：</p><ol><li>通过构造器创建bean实例(无参数构造)</li><li>为bean的属性设置值或对其他bean的引用(调用setter方法)</li><li>调用bean的初始化方法(需要配置初始化方法)</li><li>bean使用(对象获取到并使用)</li><li>当容器关闭时候，调用bean的销毁的方法(需要配置销毁方法)</li></ol></li><li><p>代码演示：</p><p>xml配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"order"</span> <span class="attr">class</span>=<span class="string">"chapter1.Order"</span> <span class="attr">init-method</span>=<span class="string">"initMethod"</span> <span class="attr">destroy-method</span>=<span class="string">"destroyMethod"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"testOrder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Order() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="string">"setName"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"initMethod() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"destroyMethod() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter1/bean3.xml"</span>);</span><br><span class="line">  Order order = context.getBean(<span class="string">"order"</span>, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  System.out.println(<span class="string">"Get order bean ~~~"</span>);</span><br><span class="line">  System.out.println(<span class="string">"order = "</span> + order);</span><br><span class="line">  <span class="comment">// 显式关闭容器对象,让bean实例销毁,否则不会触发destroyMethod</span></span><br><span class="line">  ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Order() ~~~</span><br><span class="line">setName</span><br><span class="line">initMethod() ~~~</span><br><span class="line">Get order bean ~~~</span><br><span class="line">order = chapter1.Order@dd0c991</span><br><span class="line">destroyMethod() ~~~</span><br></pre></td></tr></table></figure></li><li><p>Bean的后置处理器对Bean生命周期的影响：</p><ol><li>通过构造器创建bean实例(无参数构造)</li><li>为bean的属性设置值或对其他bean的引用(调用setter方法)</li><li><strong>将bean实例传递给bean的后置处理器，执行postProcessBeforeInitialization()方法</strong></li><li>调用bean的初始化方法(需要配置初始化方法)</li><li><strong>将bean实例传递给bean的后置处理器，执行postProcessAfterInitialization()方法</strong></li><li>bean使用(对象获取到并使用)</li><li>当容器关闭时候，调用bean的销毁的方法(需要配置销毁方法)</li></ol></li><li><p>代码演示(基于上个例子)：<br>增加的xml配置如下<br><code>&lt;bean id=&quot;testBeanPostProcessor&quot; class=&quot;chapter1.TestBeanPostProcessor&quot;/&gt;</code><br>增加的java代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"postProcessBeforeInitialization() ~~~ "</span> + beanName + <span class="string">" , "</span> + bean);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"postProcessAfterInitialization() ~~~ "</span> + beanName + <span class="string">" , "</span> + bean);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Order() ~~~</span><br><span class="line">setName</span><br><span class="line">postProcessBeforeInitialization() ~~~ order , chapter1.Order@5609159b</span><br><span class="line">initMethod() ~~~</span><br><span class="line">postProcessAfterInitialization() ~~~ order , chapter1.Order@5609159b</span><br><span class="line">Get order bean ~~~</span><br><span class="line">order = chapter1.Order@5609159b</span><br><span class="line">destroyMethod() ~~~</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><ul><li><p>介绍：AOP(Aspect Oriented Programming)意为面向切面编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发的效率。AOP可以将交叉业务逻辑封装成切面，利用将切面织入到主业务逻辑中。所谓交叉业务逻辑是指通用的、与主业务逻辑无关的代码，如安全检查、事务、日志、缓存等</p></li><li><p>底层原理：动态代理</p><ol><li><p>存在接口：使用JDK动态代理(创建接口实现类代理对象,增强类的方法)</p><p> 案例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  调用Proxy类的newProxyInstance()方法返回代理对象</span></span><br><span class="line"><span class="comment">  public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">  参数解释如下：</span></span><br><span class="line"><span class="comment">    loader：类加载器</span></span><br><span class="line"><span class="comment">    interfaces：增强方法所在的类实现的接口,支持多接口</span></span><br><span class="line"><span class="comment">    InvocationHandler：创建代理对象,增强功能的主要逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  UserDaoImpl impl = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">  UserDao userDao = (UserDao) Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> Class[]&#123;UserDao<span class="class">.<span class="keyword">class</span>&#125;, (<span class="title">proxy</span>, <span class="title">method</span>, <span class="title">args</span>) -&gt; </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Before method: &#123;&#125; , args: &#123;&#125;"</span>, method.getName(), Arrays.toString(args));</span><br><span class="line">        Object res = method.invoke(impl, args);</span><br><span class="line">        log.info(<span class="string">"After method return: &#123;&#125;"</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;);</span><br><span class="line">  userDao.add(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">  log.info(<span class="string">"UserDao: &#123;&#125;"</span>, userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 打印结果：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-12-05 20:22:03.759 [main] INFO  chapter3.ProxyTest - Before method: add , args: [5, 10]</span><br><span class="line">2020-12-05 20:22:03.762 [main] INFO  chapter3.ProxyTest - After method return: 15</span><br><span class="line">2020-12-05 20:22:03.763 [main] INFO  chapter3.ProxyTest - Before method: toString , args: null</span><br><span class="line">2020-12-05 20:22:03.763 [main] INFO  chapter3.ProxyTest - After method return: chapter3.UserDaoImpl@4b44655e</span><br><span class="line">2020-12-05 20:22:03.763 [main] INFO  chapter3.ProxyTest - UserDao: chapter3.UserDaoImpl@4b44655e</span><br></pre></td></tr></table></figure></li><li><p>不存在接口：使用Cglib动态代理(创建子类的代理对象,增强类的方法)</p></li></ol></li><li><p>AOP中的术语：</p><ol><li>连接点：指可以被切面织入的具体方法。通常业务接口中的方法均为连接点</li><li>切入点：指声明的一个或多个连接点的集合。被标记为final的方法不能作为连接点与切入点</li><li>通知(增强)：表示切面的执行时间，也叫增强。通知定义了增强代码切入到目标代码的时间点。通知类型不同，切入时间不同。<strong>切入点定义切入的位置，通知定义切入的时间</strong></li><li>切面：切面泛指交叉业务逻辑。实际就是对主业务逻辑的一种增强</li><li>目标对象：指将要被增强的对象。即包含主业务逻辑的类的对象</li></ol></li><li><p>Spring中使用AOP</p><ul><li><p>基本介绍：Spring底层使用到AspectJ实现AOP功能。Spring框架一般也是基于AspectJ提供AOP功能</p></li><li><p>相关依赖：Spring-aspects(包含aspectj)</p></li><li><p>切入点表达式：</p><ul><li><p>作用：对哪个类的那个方法进行增强</p></li><li><p>语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></figure><blockquote><p>modifiers-pattern：访问权限类型<br>ret-type-pattern：返回值类型<br>declaring-type-pattern：包名类名<br>name-pattern(param-pattern)：方法名(参数类型和参数个数)<br>throws-pattern：抛出异常类型<br>‘?’表示可选的部分<br>总体可表示为：execution(访问权限 方法返回值 方法声明(参数) 异常类型)</p></blockquote><p>涉及到的符号解释：</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>0至多个任意字符</td></tr><tr><td>..</td><td>用在方法参数中表示任意多个参数;用在包名后表示当前包及其子包路径</td></tr><tr><td>+</td><td>用在类名后表示当前类及其子类;用在接口后表示当前接口及其实类</td></tr></tbody></table></li><li><p>具体例子：execution(* com.xiong.dao.DocService.*(..))</p></li></ul></li><li><p>具体使用：</p><ul><li><p>在业务类上声明@Component注解让其加入Spring容器</p></li><li><p>创建增强类(编写增强逻辑)</p><ol><li>声明@Component加入Spring容器</li><li>声明@Aspect需要生成代理对象</li><li>配置不同类型的通知(使用切入点表达式)</li></ol><blockquote><p>可选项，有多个增强类对同一个方法进行增强时可以声明@Order(int priority)设置增强类优先级，数值类型越小优先级越高</p></blockquote><p>注解配置切入点案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前置通知,可有JoinPoint参数</span></span><br><span class="line">  <span class="meta">@Before</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"UserProxy methodBefore() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后置通知(返回通知),注解中有returning属性用于接受目标方法返回值</span></span><br><span class="line">  <span class="meta">@AfterReturning</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAfterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"UserProxy methodAfterReturning() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终通知</span></span><br><span class="line">  <span class="meta">@After</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"UserProxy methodAfter() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常通知,注解中有throwing属性用于接受抛出的异常</span></span><br><span class="line">  <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAfterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"UserProxy methodAfterThrowing() ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环绕通知</span></span><br><span class="line">  <span class="meta">@Around</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">methodAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    log.info(<span class="string">"UserProxy methodAround() ~~~"</span>);</span><br><span class="line">    log.info(<span class="string">"Before jointPoint invoke ~~~"</span>);</span><br><span class="line">    <span class="comment">// 被增强的方法执行</span></span><br><span class="line">    Object ans = proceedingJoinPoint.proceed();</span><br><span class="line">    log.info(<span class="string">"After jointPoint invoke ~~~"</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽取相同的切入点进行化简：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽取相同的切入点</span></span><br><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(* chapter3.User.add(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(value = <span class="string">"pointcutMethod()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  log.info(<span class="string">"UserProxy pointcutBefore() ~~~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置切入点案例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置aop增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* chapter3.Book.buy())"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"bookProxy"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 增强作用在具体的方法上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Spring环境(xml/注解)</p><ol><li><p>基于xml：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件自动扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"chapter3"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Aspect生成代理对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"chapter3"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li></ul><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><ul><li><p>基础介绍：事务是数据库中的概念(一组操作要么全部成功,要么全部失败)，在Dao层，但一般将事务提升到Service业务层</p></li><li><p>四个特性(ACID)：原子性、一致性、隔离性、持久性</p></li><li><p>Spring中的事务管理：</p><ol><li><p>编程式事务管理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  transaction.begin();</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">  doSomethingAfterException(e);</span><br><span class="line">  transaction.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明式事务管理</p><blockquote><p>推荐使用，底层使用AOP</p></blockquote></li></ol></li><li><p>Spring事务管理类：</p><ul><li>基类为PlatformTransactionManager接口，定义了事务的提交、回滚以及获取事务的状态信息操作<br><img src="PlatformTransactionManager%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95.png" alt="PlatformTransactionManager接口方法"><br><img src="Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Spring事务管理类继承结构图"></li><li>两个常用的实现类：<ol><li><strong>DataSourceTransactionManager</strong>：使用JDBC或MyBatis进行数据库操作时使用</li><li><strong>HibernateTransactionManager</strong>：使用Hibernate(JPA)进行持久化数据时使用</li></ol></li><li>Spring的回滚方式：<strong>默认发生运行时异常和error时回滚，发生受查(编译)异常时提交</strong>。对于受查异常也可以手工设置其回滚方式<blockquote><p>Throwable类是Java语言中所有错误或异常的超类。只有当对象是此类(或其子类之一)的实例时，才能通过Java虚拟机或者throw语句抛出<br>Error是程序在运行过程中出现的无法处理的错误，比如OutOfMemoryError、ThreadDeath、NoSuchMethodError等。当这些错误发生时，程序是无法处理(捕获或抛出)的，JVM一般会终止线程<br>程序在编译和运行时出现的另一类错误称之为异常，它是JVM通知程序员的一种方式。通过这种方式，让程序员知道已经或可能出现错误，要求程序员对其进行处理。异常分为运行时异常与受查异常：<br>运行时异常，是RuntimeException类或其子类，即只有在运行时才出现的异常。如NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等均属于运行时异常。这些异常由JVM抛出，在编译时不要求必须处理(捕获或抛出)。只要代码编写足够仔细，程序足够健壮，运行时异常是可以避免的<br>受查异常，也叫编译时异常(即在代码编写时要求必须捕获或抛出的异常)。若不处理，则无法通过编译。如SQLException、ClassNotFoundException和IOException等都属于受查异常<br>RuntimeException及其子类以外的异常均属于受查异常。自定义的Exception的子类(即用户自定义的异常)也属受查异常。在定义异常时，只要未明确声明定义的为RuntimeException的子类，那么定义的就是受查异常</p></blockquote></li></ul></li><li><p>事务管理操作步骤：</p><ul><li><p>声明需要事务操作的方法/类：</p><ol><li><p>基于注解方式(声明@Transactional注解)：</p><blockquote><p>@Transactional用在方法上：只能用于public方法上。对于其他非public方法，如果声明了注解@Transactional，虽然Spring不会报错，但不会将指定事务织入到该方法中。Spring会忽略掉所有非public方法上的@Transaction注解<br>@Transactional用在在类上：则表示该类上所有的方法均将在执行时织入事务</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED, rollbackFor = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">transferAccount</span>(<span class="title">String</span> <span class="title">fromUsername</span>, <span class="title">String</span> <span class="title">toUsername</span>, <span class="title">Double</span> <span class="title">money</span>) </span>&#123;</span><br><span class="line">  accountDao.reduceMoney(fromUsername, money);</span><br><span class="line">  <span class="comment">// int i = 10 / 0;</span></span><br><span class="line">  accountDao.addMoney(toUsername, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于xml配置方式：</p><ol><li><p>配置通知：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvice"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置事务参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transferAccount"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置切入点和切面：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务切入点和切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* chapter5.AccountService.*(..))"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>配置事务管理器</p><ol><li><p>基于注解方式(此方式只支持注解方式声明)：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"chapter5"</span>) <span class="comment">// 配置包扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAnnoConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建数据库连接池</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql:///test"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"password"</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建JdbcTemplate对象</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会在ioc容器中根据类型找到dataSource</span></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">    <span class="comment">// 注入dataSource</span></span><br><span class="line">    jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建事务管理器</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">    transactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于xml方式(是否声明支持注解根据声明事务的方式)</p><ol><li><p>配置基于注解的声明方式：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器tx --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启事务注解,需要引入tx命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开始包扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"chapter5"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置基于配置的声明方式：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器tx --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul></li><li><p>事务注解相关属性介绍：</p><ol><li><p>propagation：事务传播行为(处于不同事务中的方法在相互调用时,执行期间事务的维护情况)，默认REQUIRED</p><table><thead><tr><th>传播属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>PROPAGATION_REQUIRED</strong></td><td>Spring默认的事务传播行为;如果存在当前事务则用当前事务;否则就新建一个事务</td></tr><tr><td><strong>PROPAGATION_REQUIRES_NEW</strong></td><td>如果当前存在事务把当前事务挂起,开启一个新事务,新事务执行完毕后唤醒之前挂起的事务继续执行。如果不存在当前事务则新建一个事务</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务,如果当前没有事务就以非事务方式执行</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作,如果当前存在事务就把当前事务挂起</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>支持当前事务,如果当前没有事务就抛出异常</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行,如果当前存在事务则抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务则在当前事务的嵌套事务内执行。否则启动一个新的事务并在自己的事务内运行</td></tr></tbody></table></li><li><p>ioslation：事务隔离级别，默认DEFAULT</p><p> 存在三种读问题：</p><table><thead><tr><th>读问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个未提交事务读取到另一个未提交事务的数据</td></tr><tr><td>不可重复读</td><td>一个未提交事务读取到另一提交事务修改数据</td></tr><tr><td>幻读</td><td>一个未提交事务读取到另一提交事务添加数据</td></tr></tbody></table><p> 提供的四种隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>DEFAULT</strong></td><td>采用数据库默认的事务隔离级别</td><td>\</td><td>\</td></tr><tr><td>READ_UNCOMMITTED(读未提交)</td><td>有</td><td>有</td><td>有</td></tr><tr><td>READ_COMMITTED(读已提交)</td><td>无</td><td>有</td><td>有</td></tr><tr><td>REPEATABLE_READ(可重复读)</td><td>无</td><td>无</td><td>有</td></tr><tr><td>SERIALIZABLE(串行化)</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><blockquote><p>MySQL默认隔离级别为REPEATABLE_READ,Oracle默认为READ_COMMITTED</p></blockquote></li><li><p>timeout：用于设置本操作与数据库连接的超时时限</p><blockquote><p>单位为秒，默认-1(即没有时限)</p></blockquote></li><li><p>readOnly：用于设置该方法对数据库的操作是否是只读的，默认false</p></li><li><p>rollbackFor：指定需要回滚的异常类</p><blockquote><p>类型为Class[]，默认值为空数组。若只有一个异常类时，可以不使用数组</p></blockquote></li><li><p>rollbackForClassName：指定需要回滚的异常类类名</p><blockquote><p>类型为String[]，默认值为空数组。若只有一个异常类时，可以不使用数组</p></blockquote></li><li><p>noRollbackFor：指定不需要回滚的异常类</p></li><li><p>noRollbackForClassName：指定不需要回滚的异常类类名</p></li></ol></li></ul><h2 id="Spring5新功能"><a href="#Spring5新功能" class="headerlink" title="Spring5新功能"></a>Spring5新功能</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud基础</title>
      <link href="/2020/11/18/SpringSeries/SpringCloud/SpringCloud%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/11/18/SpringSeries/SpringCloud/SpringCloud%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#SpringCloud概述">SpringCloud概述</a></li><li><a href="#Eureka注册中心介绍">Eureka注册中心介绍</a></li><li><a href="#Eureka停更后的替换组件">Eureka停更后的替换组件</a></li><li><a href="#Ribbon负载均衡介绍">Ribbon负载均衡介绍</a></li></ul><a id="more"></a><h2 id="SpringCloud概述"><a href="#SpringCloud概述" class="headerlink" title="SpringCloud概述"></a>SpringCloud概述</h2><ul><li>微服务是什么：微服务架构下的一整套解决方案<br><img src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%86%85%E5%AE%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="微服务解决方案内容示意图"></li><li>SpringCloud是什么：分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶<br><img src="%E4%BA%AC%E4%B8%9C%E4%BF%83%E9%94%80%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="京东促销架构示意图"><br><img src="%E4%BA%AC%E4%B8%9C%E7%89%A9%E6%B5%81%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="京东物流架构示意图"><br><img src="%E9%98%BF%E9%87%8C%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阿里架构示意图"><br><img src="%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="基础服务微服务架构示意图"></li><li>SpringCloud版本<br>SpringCloud采用英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依此类推的形式发布迭代版本<br>SpringCloud是由许多子项目组成的综合项目，各子项目有不同的发布节奏，为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版对应的子项目版本。为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版采用了名称而非版本号命名，例如Angel、Brixton。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个Service releases版本，俗称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第二个SRX版本</li><li>SpringBoot和SpringCloud的版本约束<br>SpringBoot和SpringCloud的版本选择也不是任意的，而是应该参考官网的约束配置<br><img src="SpringBoot%E5%92%8CSpringCloud%E7%9A%84%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SpringBoot和SpringCloud的版本约束示意图"><br>地址：<a href="https://spring.io/projects/spring-cloud#overview" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud#overview</a><br>版本对应：<a href="https://start.spring.io/actuator/info" target="_blank" rel="noopener">https://start.spring.io/actuator/info</a></li><li>SpringCloud各种组件的停更/升级/替换<ol><li>停更的具体形式：<ol><li>被动修复Bugs</li><li>不再接受合并请求</li><li>不再发布新版本</li></ol></li><li>组件具体明细条目<ul><li>服务调用<ol><li>Eureka</li><li>Zookeeper</li><li>Consul</li><li>Nacos(推荐)</li></ol></li><li>服务调用<ol><li>Feign</li><li>OpenFeign(推荐)</li><li>Ribbon</li><li>LoadBalancer</li></ol></li><li>服务降级<ol><li>Hystrix</li><li>resilience4j</li><li>sentienl(推荐)</li></ol></li><li>服务网关<ol><li>Zuul</li><li>Zuul2</li><li>Gateway(推荐)</li></ol></li><li>服务配置<ol><li>Config</li><li>Nacos(推荐)</li></ol></li><li>服务总线<ol><li>Bus</li><li>Nacos(推荐)</li></ol></li></ul></li></ol></li><li>SpringCloud资料<br>官网文档：<a href="https://spring.io/projects/spring-cloud#learn" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud#learn</a><br>SpringCloud中文文档：<a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></li></ul><h2 id="Eureka注册中心介绍"><a href="#Eureka注册中心介绍" class="headerlink" title="Eureka注册中心介绍"></a>Eureka注册中心介绍</h2><ul><li><p>Eureka基础知识：</p><ol><li>什么是服务注册？<br>Eureka Server作为服务注册功能的服务器，它是服务注册中心，而系统中其他微服务，使用Eureka客户端连接到Eureka Server并维持心跳连接，这样系统维护人员就可以通过 Eureka Server来监控各个微服务是否正常运行<br>在服务注册与发现中有一个注册中心，服务器启动时，会把当前自己的服务器信息比如服务地址、通信地址等注册到注册中心上，另一方(消费者)以别名的方式在注册中心上获取实际的服务器通讯地址，然后再实现本地RPC调用远程RPC<br><img src="Eureka%E4%B8%8EDubbo%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Eureka与Dubbo架构对比示意图"></li><li>Eureka的两个组件<ul><li>Eureka Server：提供服务注册服务。各个微服务节点通过配置启动后，会在 Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息</li><li>Eureka Client：通过注册中心进行访问。是一个Java客户端，用于简化与Eureka Server的交互，客户端也同时具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中将这个服务节点移除(默认90秒)</li></ul></li></ol></li><li><p>Eureka工作原理：</p><ul><li>服务注册：将服务信息注册进注册中心</li><li>服务发现：从注册中心上获取服务信息</li><li>实质：存key服务命名，取value调用地址</li></ul></li><li><p>单机Eureka Server搭建(小口诀：建module,改pom,写yml,主启动)：</p><ol><li><p>导入依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改yml配置文件：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># eureka服务端实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心,职责是维护服务实例,并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 设置与eureka server交互的地址;查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>启动类上添加注解声明启动Eureka服务端</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer7001Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(EurekaServer7001Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试(看到eureka服务页面)：<a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a></p></li></ol></li><li><p>Eureka Client搭建：</p><ol><li><p>导入依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改yml配置文件：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示是否将自己注册进Eureka Server,默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息,默认为true;</span></span><br><span class="line">    <span class="comment"># 单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>启动类上添加注解声明启动Eureka客户端</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderPayment8001Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(EurekaServer7001Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：<a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a><br> 可以看到Instances中包含服务提供方<br> <img src="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt="测试结果"></p></li></ol></li><li><p>集群Eureka配置</p><ul><li><p>背景：微服务RPC远程调用最核心就是高可用。假设注册中心只有一个，如果出现了故障，那么将会导致整个微服务不可用，所以需要搭建Eureka注册中心集群，实现负载均衡和故障容错</p></li><li><p>集群原理：相互注册、相互守望</p></li><li><p>前提：由于hostname不能重复，在本地hosts修改映射，将eureka7001.com、eureka7002.com都映射到localhost上</p></li><li><p>具体步骤：</p><ol><li><p>Eureka Server修改yml配置：</p><p> <code>EurekaServer7001配置</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># eureka服务端实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心,职责就是维护服务实例,无需检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 向另外的eureka服务注册,如果多个用,隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p> <code>EurekaServer7002配置</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># eureka服务端实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心,职责就是维护服务实例,无需检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 向另外的eureka服务注册,</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>测试：<a href="http://eureka7001.com:7001" target="_blank" rel="noopener">http://eureka7001.com:7001</a>、<a href="http://eureka7002.com:7002" target="_blank" rel="noopener">http://eureka7002.com:7002</a><br> 分别发现另一方成为各自的DS Replicas<br> <img src="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt="测试结果"></p></li></ol></li></ul></li><li><p>Eureka Client集群(服务)注册进Eureka集群</p><ul><li><p>背景：假设有两个微服务payment8001和payment8002需要注册进上面的Eureka集群</p></li><li><p>具体步骤：</p><ol><li><p>Eureka Client集群(服务)修改yml配置：</p><p> <code>Payment8001配置</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 服务名称,为了保证服务对外暴露的是同一个服务提供者,服务名要保持一致</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示向注册中心注册自己,默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 入驻地址,向eurekaServer注册,多个地址用','分割</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 设置实例编号,用于区分</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">provider-payment-8001</span></span><br><span class="line">    <span class="comment"># 是否显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p> <code>Payment8002配置</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 服务名称,为了保证服务对外暴露的是同一个服务提供者,服务名要保持一致</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 表示向注册中心注册自己,默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 入驻地址,向eurekaServer注册,多个地址用','分割</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 设置实例编号,用于区分</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">provider-payment-8001</span></span><br><span class="line">    <span class="comment"># 是否显示ip</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>测试：<a href="http://eureka7001.com:7001" target="_blank" rel="noopener">http://eureka7001.com:7001</a><br> 发现PAYMENT-SERVICE中两个服务提供者，分别为8001和8002<br> <img src="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C3.png" alt="测试结果"></p></li></ol></li></ul></li><li><p>调用服务提供者</p><ul><li><p>背景：上述工作完成了服务提供者payment-provider集群注册进eureka集群中，此时需要有一个消费者微服务调用服务</p></li><li><p>具体步骤：</p><ol><li><p>导入依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写yml：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer-order-80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 将自己注册进EurekaServer,默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 从EurekaServer抓取已有的注册信息,默认为true</span></span><br><span class="line">    <span class="comment"># 单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># defaultZone: http://eureka7001.com:7001/eureka/</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>主启动：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerOrder80Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConsumerOrder80Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置RestTemplate的负载均衡策略：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="comment">// 赋予RestTemplate负载均衡能力</span></span><br><span class="line">  <span class="comment">// 这是Ribbon的功能,Eureka默认自带Ribbon</span></span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体消费端Controller：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 服务提供方的具体服务名,由eureka负责解析</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">"http://PROVIDER-PAYMENT/payment"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/payment/add"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Result <span class="title">add</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">"/add"</span>, payment, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Result <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="string">"/get/"</span> + id, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：<a href="http://localhost/order/payment/get/1" target="_blank" rel="noopener">http://localhost/order/payment/get/1</a><br><img src="%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C4.png" alt="测试结果"></p></li></ol></li></ul></li><li><p>actuator微服务信息完善</p><ul><li><p>需要导入的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 监控 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看健康信息：<a href="http://hostname:port/actuator/health">http://hostname:port/actuator/health</a></p></li><li><p>设置微服务显示名称和ip显示</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Erueka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># 服务名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="comment"># 访问路径显示IP地址</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务发现Discovery</p><ul><li><p>作用：可以通过服务发现获取注册进eureka的微服务的信息</p></li><li><p>相关类：</p><ol><li>@EnableDiscoveryClient</li><li>DiscoveryClient</li></ol></li><li><p>具体API：</p><ol><li>获取列表：<code>List&lt;String&gt; services = discoveryClient.getServices();</code></li><li>获取实例：<code>List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;PAYMENT-SERVICE&quot;);</code></li><li>获取ServiceId：<code>serviceInstance.getServiceId();</code></li><li>获取端口号：<code>serviceInstance.getPort();</code></li><li>获取URL：<code>serviceInstance.getURL();</code></li></ol></li><li><p>具体步骤：</p><ol><li><p>在payment8001的controller中添加代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/discovery"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">discovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">  <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(service);</span><br><span class="line">    <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">      log.info(<span class="string">"ServiceId: &#123;&#125; , host: &#123;&#125; , port: &#123;&#125; , uri: &#123;&#125;"</span>, instance.getServiceId(), instance.getHost(), instance.getPort(), instance.getUri());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="number">200</span>, <span class="string">"查询成功~~~"</span>, discoveryClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：<a href="http://localhost:8001/payment/discovery" target="_blank" rel="noopener">http://localhost:8001/payment/discovery</a></p><p> <code>控制台输出如下</code></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-11-19 19:16:39.535  INFO 4394 --- [nio-8001-exec-9] c.x.cloud.controller.PaymentController   : ServiceId: PROVIDER-PAYMENT , host: 10.21.176.180 , port: 8001 , uri: http://10.21.176.180:8001</span><br><span class="line">2020-11-19 19:16:39.535  INFO 4394 --- [nio-8001-exec-9] c.x.cloud.controller.PaymentController   : ServiceId: PROVIDER-PAYMENT , host: 10.21.176.180 , port: 8002 , uri: http://10.21.176.180:8002</span><br></pre></td></tr></table></figure><p> <code>返回json结果如下</code></p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"resultCode"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"resultMessage"</span>: <span class="string">"查询成功~~~"</span>,</span><br><span class="line">  <span class="attr">"resultData"</span>: &#123;</span><br><span class="line">    <span class="attr">"discoveryClients"</span>: [&#123;</span><br><span class="line">      <span class="attr">"order"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"services"</span>: [<span class="string">"provider-payment"</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"order"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"services"</span>: []</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">"services"</span>: [<span class="string">"provider-payment"</span>],</span><br><span class="line">    <span class="attr">"order"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>Eureka自我保护机制</p><ul><li><p>概念：<br>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务<br>如果在Eureka Server的首页看到以下这段提示，说明Eureka进入了保护模式<br><img src="Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%8F%90%E7%A4%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Eureka自我保护提示示意图"><br>通俗的话来说：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。这属于CAP里面的AP分支</p></li><li><p>导致原因：<br>默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例，默认为90秒。但当网络分区故障发生(延时、卡顿、拥挤)时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险了————因为微服务本身其实是健康的，此时不应该注销这个微服务。Eureka通过自我保护模式来解决这个问题，当Eureka Server节点在短时间丢失过多客户端，那么这个节点就会进入自我保护模式，这是一种高可用的机制<br>在自我保护模式下，Eureka Server会保护服务注册表中的信息，不在注销任何服务实例<br>综上，自我保护模式是一种应对网络异常的安全保护措施，它的架构哲学是宁可保留所有微服务，也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加健壮，稳定</p></li><li><p>禁止自我保护(Eureka默认开启自我保护)：</p><ol><li><p>Eureka服务端设置：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment"># 关闭自我保护机制</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 心跳时间默认90s,改为2000ms,即2s</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure></li><li><p>Eureka客户端设置</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># Eureka客户端向服务端发送心跳的时间间隔,单位为秒,默认30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Eureka服务端在收到最后一次心跳后等待时间上限,单位为秒,默认90秒,超时将剔除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><p>设置完成后，只要服务宕机，会马上从服务注册列表中清楚</p></li></ul></li><li><p>Eureka停更之后的替代者：</p><ol><li>Zookeeper</li><li>Consul</li><li>Nacos</li></ol></li></ul><h2 id="Eureka停更后的替换组件"><a href="#Eureka停更后的替换组件" class="headerlink" title="Eureka停更后的替换组件"></a>Eureka停更后的替换组件</h2><ul><li><p>Zookeeper</p><ul><li><p>Zookeeper介绍：一个分布式协调工具，可以实现注册中心功能</p></li><li><p>注册服务进Zookeeper：</p><ol><li><p>引入pom依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot整合zookeeper客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 先排除自带的zookeeper3.5.3 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加zookeeper3.6.2版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改yml配置文件：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 服务别名——注册进zookeeper注册中心的服务名</span></span><br><span class="line">    <span class="comment"># 多个服务实例要设置同一个服务别名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">test1:2181</span></span><br></pre></td></tr></table></figure></li><li><p>修改主启动类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderPayment8004Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ProviderPayment8004Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>思考：<br>服务已经成功注册到Zookeeper客户端，那么注册上去的节点为临时节点还是持久节点？<br>首先Eureka有自我保护机制，也就是某个服务下线后，不会立刻清除该服务，而是将服务保留一段时间<br>Zookeeper一样在服务下线后也会等待一段时间，之后才会把该节点删除，这就说明Zookeeper上的节点是临时节点</p></li></ul></li><li><p>Consul</p><ul><li><p>Consul介绍</p><ul><li>简介：<br>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发<br>提供了微服务系统中的服务治理、配置中心、控制总线等功能，这些功能中的每一个都可以根据需要单独使用，也可以一起使用构建全方位的服务网路，总之Consul提供了一种完整的服务网络解决方案<br>具有很多优点，包括：基于raft协议，比较简洁；支持健康检查；同时支持HTTP和DNS协议；支持跨数据中心的WAN集群；提供图形化界面；跨平台，支持Linux、MAC、Windows</li><li>官网：<a href="https://www.consul.io/" target="_blank" rel="noopener">https://www.consul.io/</a></li><li>功能：<ol><li>服务发现：提供HTTP和DNS两种发现方式</li><li>健康监测：支持多种方法，HTTP，TCP，Docker，Shell脚本定制化</li><li>KV存储：Key，Value的存储方式</li><li>多数据中心：Consul支持多数据中心</li><li>可视化Web界面</li></ol></li><li>安装：<ol><li>官网下载(可执行文件)</li><li>查看版本：<code>consul --version</code></li><li>运行：<code>consul agent -dev</code></li><li>测试：访问<a href="http://test1:8500" target="_blank" rel="noopener">http://test1:8500</a>进入consul可视化界面</li></ol></li></ul></li><li><p>注册服务进Consul：</p><ol><li><p>引入pom依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- consul --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改yml配置文件：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">test1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试：访问<a href="http://test1:8500" target="_blank" rel="noopener">http://test1:8500</a>进入consul可视化界面，发现微服务已注册进consul</p></li></ol></li></ul></li><li><p>总结三个注册中心：</p><table><thead><tr><th>组件名</th><th>语言</th><th>健康检查</th><th>对外暴露接口</th><th>CAP</th><th>Spring Cloud集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>可配支持</td><td>HTTP</td><td>AP</td><td>已集成</td></tr><tr><td>Consul</td><td>Go</td><td>支持</td><td>HTTP/DNS</td><td>CP</td><td>已集成</td></tr><tr><td>Zookeeper</td><td>Java</td><td>支持</td><td>客户端</td><td>CP</td><td>已集成</td></tr></tbody></table></li><li><p>CAP理论：<br>C(Consistency)表示强一致性；A(Availability)表示高可用；P(Partition Tolerance)表示分区容错性。CAP理论关注粒度是数据，而不是整体系统设计的策略<br>CAP理论的核心：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这个三个需求。现在的微服务架构要么是CP要么是AP(即P一定需要保证)，最多只能较好地同时满足两个<br>根据CAP原理可将一个分布式系统分成CA、CP和AP三大类：</p><ol><li>CA：单点集群，满足一致性、可用性的系统，通常在可扩展性上不太满足</li><li>CP：满足一致性、分区容忍性，通常性能不是特别高</li><li>AP：满足可用性、分区容忍性，通常对一致性要求低一些</li></ol></li><li><p>AP架构(Eureka)：<br><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5%E4%B8%8BAP%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="网络分区情况下AP应对策略示意图"><br>因为同步原因出现问题，而造成数据没有一致性<br>当出现网络分区后，为了保证高可用，系统B可以返回旧值，保证系统的可用性<br>结论：违背了一致性C的要求，只满足可用性和分区容错性，即AP</p></li><li><p>CP架构(Zookeeper、Consul)：<br><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5%E4%B8%8BCP%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="网络分区情况下CP应对策略示意图"><br>当出现网络分区后，为了保证一致性，就必须拒绝请求，否者无法保证一致性<br>结论：违背了可用性A的要求，只满足一致性和分区容错性，即CP</p></li></ul><h2 id="Ribbon负载均衡介绍"><a href="#Ribbon负载均衡介绍" class="headerlink" title="Ribbon负载均衡介绍"></a>Ribbon负载均衡介绍</h2><ul><li><p>Ribbon介绍：<br>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具<br>Ribbon是NetFlix发布的开源项目。主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供了一系列完善的配置项如连接超时、重试等。简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动地基于某种规则(简单轮询、随机连接等)去连接这些机器。很容易使用Ribbon实现自定义的负载均衡算法</p></li><li><p>负载均衡介绍：<br>Load Balance，简单来说就是将用户的请求平摊地分配到多个服务上，从而达到系统的HA(高可用)。常见的负载均衡有软件Nginx、LVS等，硬件有F5等</p><ol><li>集中式LB：在服务的消费方和提供方之间使用独立的LB设施(可以是硬件,如F5;也可以是软件,如Nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方</li><li>进程内LB：将LB逻辑集成到消费方————消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址</li><li>Ribbon和Nginx的对比：<ul><li>Nginx是服务器负载均衡，客户端所有的请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的</li><li>Ribbon是本地负载均衡，在调用微服务接口时会从注册中心上获取注册信息服务列表，再缓存到JVM本地，从而在本地实现RPC远程调用</li></ul></li></ol></li><li><p>Ribbon工作原理：<br>Ribbon其实就是一个软负载均衡的客户端组件，它可以和其它所需请求的客户端结合使用，和Eureka结合只是其中的一个实例<br><img src="Ribbon%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Ribbon工作原理示意图"><br>Ribbon在工作时分成两步：</p><ol><li>首先选择Eureka Server，它优先选择在同一个区域内负载较少的Server</li><li>再根据用户指定的策略，从Server取到的服务注册列表中选择一个地址(Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权)</li></ol></li><li><p>具体实践：</p><ol><li><p>引入Ribbon：新版Eureka已默认引入Ribbon，无需额外引入</p></li><li><p>核心组件IRule介绍：<br> Ribbon默认使用轮询作为负载均衡算法<br> IRule根据特定算法从服务列表中选取一个要访问的服务，IRule是一个接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRule</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Ribbon提供了多种IRule的默认实现<br> <img src="IRule%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9B%BE.png" alt="IRule继承类图"><br> 共有以下七种：</p><ol><li>RoundRobinRule：轮询</li><li>RandomRule：随机</li><li>RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用服务</li><li>WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择的权重越大，越容易被选择</li><li>BestAvailableRule：会先过滤掉由于多次访问故障而处于短路跳闸状态的服务，然后选择一个并发量最小的服务</li><li>AvailabilityFilteringRule：先过滤掉故障实例，在选择并发较小的实例</li><li>ZoneAvoidanceRule：默认规则，符合判断server所在区域的性能和server的可用性选择服务器</li></ol></li><li><p>默认负载均衡算法替换</p><ul><li><p>Ribbon的小bug：官网警告自定义的配置类不能放在@ComponentScanner所扫描的当前包以及子包下，否者自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了(不能在SpringApplication主启动类的同级及子包下)</p></li><li><p>创建自定义Rule接口：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRibbonRule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">getRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义为随机规则</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主启动类中设置新规则(<code>@RibbonClient</code>)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"PROVIDER-PAYMENT"</span>, configuration = MyRibbonRule<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ConsumerOrder80Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConsumerOrder80Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>手写Ribbon负载均衡算法</p><ul><li><p>原理：<br>记实际调用服务器位置下标为serviceIndex，服务器集群总数量为serviceCount，rest接口请求次数为n，则有：<code>serviceIndex = n % serviceCount</code>(即轮询的原理)</p></li><li><p>RoundRobinRule原理(发现采用思想一样,再加入了一些判断和CAS线程安全保证)：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> AVAILABLE_ONLY_SERVERS = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ALL_SERVERS = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nextServerCyclicCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setLoadBalancer(lb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">      List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">      <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">      <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">      server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/* Transient. */</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (server);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next.</span></span><br><span class="line">      server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">      <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">      <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现自己版本的负载均衡算法：</p><ol><li><p>原理：从Eureka服务器获取实例地址信息 + 机器数取余 + JUC(CAS + 原子整型)</p></li><li><p>准备工作：删除RestTemplate上的@LoadBalance注解，防止Ribbon LB的干扰</p></li><li><p>仿造创建LoadBalanced接口：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">  <span class="function">ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实现类：MyLoadBalancer</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子整型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取Rest调用的次数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前值</span></span><br><span class="line">      current = atomicInteger.get();</span><br><span class="line">      <span class="comment">// 计数达到最大值,重回0</span></span><br><span class="line">      next = current &gt;= Integer.MAX_VALUE ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// CAS比较并交换</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!atomicInteger.compareAndSet(current, next));</span><br><span class="line">    log.info(<span class="string">"Next: &#123;&#125;"</span>, next);</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取具体服务提供者实例信息</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前访问机器的下标：调用次数 % 机器总数</span></span><br><span class="line">    <span class="keyword">int</span> index = getAndIncrement() % serviceInstances.size();</span><br><span class="line">    <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体使用：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入自己声明为@Component的MyLoadBalancer</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/payment/getLb/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getByIdInLoadBalance</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">  List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"PROVIDER-PAYMENT"</span>);</span><br><span class="line">  <span class="keyword">if</span> (instances == <span class="keyword">null</span> || instances.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  ServiceInstance instance = loadBalancer.instances(instances);</span><br><span class="line">  URI uri = instance.getUri();</span><br><span class="line">  <span class="keyword">return</span> restTemplate.getForObject(uri + <span class="string">"/payment/get/"</span> + id, Result<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol></li><li><p>Ribbon停更后的替代者：Spring Cloud自己提供的LoadBalancer</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Java</title>
      <link href="/2020/11/15/ProgrammingLanguage/Java/Effective_Java/"/>
      <url>/2020/11/15/ProgrammingLanguage/Java/Effective_Java/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#引言">引言</a></li><li><a href="#创建和销毁对象">创建和销毁对象</a></li><li><a href="#对于所有对象都通用的方法">对于所有对象都通用的方法</a></li></ul><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java语言支持四种类型：接口(包括注释)、类(包括enum)、数组和基本类型。前三种种类型通常被称为引用类型(reference type)，类实例和数组是对象(object)，而基本类型的值则不是对象。类的成员(member)由它的域(field)、方法(method)、成员类(member class)和成员接口(member interface)组成。方法的签名(signature)由它的名称和所有参数类型组成；签名不包括方法的返回类型</p><h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><ul><li><p>第一条：用静态工厂方法代替构造器</p><ol><li><strong>第一大优势在于前者有名称</strong>。如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读</li><li><strong>第二大优势在于不必在每次调用它们的时候都创建一个新对象</strong>。这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象</li><li><strong>第三大优势在于它们可以返回原返回类型的任何子类型的对象</strong>。这样在选择返回对象的类时就有了更大的灵活性。这种灵活性的一种应用是API可以返回对象，同时又不会使对对象的类变成公有的。以这种方式隐藏实现类会使API变得非常简洁</li><li><strong>第四大优势在于所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</strong>。只要是已声明的返回类型的子类型，都是允许的</li><li><strong>第五大优势在于方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在</strong>(规范,可插拔,例如JDBC具体实现)</li><li><strong>主要缺点在于类如果不含公有的或者受保护的构造器，就不能被子类化</strong>(Collections中便利的实现类子类化)</li><li>总结：静态工厂方法和公有构造器都各有用处，需要理解它们各自的长处。静态工厂经常更加合适，切忌第一反应就是提供公有的构造器，而不先考虑静态工厂</li></ol></li><li><p>第二条：遇到多个构造器参数时要考虑使用构建器</p><ol><li><p>静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数</p></li><li><p>方案1：重叠构造器(telescoping constructor)模式。在这种模式下，提供的第一个构造器只有必要的参数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依此类推。<strong>重叠构造器模式可行，但当有许多参数的时候，客户端代码会很难编写，并且仍然较难阅读</strong></p></li><li><p>方案2：JavaBean模式。在这种模式下，先调用一个无参构造器来创建对象，然后再调用setter 方法来设置每个必要的参数，以及每个相关的可选参数。这种模式弥补了重叠构造器模式的不足：创建实例很容易，代码读起来也很容易</p><ul><li>JavaBean模式的缺点：JavaBean模式自身有着很严重的缺点。因为构造过程被分到了几个调用中，<strong>在构造过程中JavaBean可能处于不一致的状态</strong>。类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误的代码大相径庭，因此调试起来十分困难。<strong>另一点不足在于JavaBean模式使得把类做成不可变的可能性不复存在</strong>，这就需要付出努力确保线程安全</li><li>不一致的解释：模拟多线程获取同一个JavaBean的场景，线程A获取Obj对象，对其属性进行set；同时线程B获取Obj对象对其进行get；这时可能会出现线程A中没有set完毕，线程B就开始get相应的属性</li></ul></li><li><p>方案3：建造者(Buidler)模式。它既能保证重叠构造器模式那样的安全性，也能保证JavaBean模式那么好的可读性。它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器(或静态工厂)，得到一个builder对象。然后客户端在builder对象上调用类似setter的方法来设置每个相关的可选参数。最后客户端调build()方法来生成通常是不可变的对象。这个builder通常是它构建的类的静态成员类</p><ul><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ice;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sugar;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> addPearl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ice = NORMAL_ICE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sugar = NORMAL_SUGAR;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> addPearl = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">ice</span><span class="params">(<span class="keyword">int</span> ice)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ice = ice;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">sugar</span><span class="params">(<span class="keyword">int</span> sugar)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sugar = sugar;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addPearl</span><span class="params">(<span class="keyword">boolean</span> addPearl)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.addPearl = addPearl;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MilkTea <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MilkTea(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MilkTea</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = builder.size;</span><br><span class="line">    <span class="keyword">this</span>.sugar = builder.sugar;</span><br><span class="line">    <span class="keyword">this</span>.addPearl = builder.addPearl;</span><br><span class="line">    <span class="keyword">this</span>.ice = builder.ice;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>客户端代码很容易编写、易于阅读。<strong>模拟了具名的可选参数</strong></p></li><li><p><strong>适用于类层次结构</strong>。 使用平行层次结构的builder时，各自嵌套在相应的类中。抽象类有抽象的builder，具体类有具体的builder</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公共属性...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 泛型,递归参数类型,在子类中适当地进行方法链接,无需转换类型</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 公共属性...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">setCommonFileds</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 公共属性赋值</span></span><br><span class="line">      <span class="keyword">return</span> self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractResource <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 模拟self类型</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AbstractResource(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">    <span class="comment">// 设置公共属性...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公共属性...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 公共属性...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setFields</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 子类特有属性赋值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build返回都是子类的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">AbstractResource <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConcreteResource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConcreteResource</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(builder);</span><br><span class="line">    <span class="comment">// 设置公共属性...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Builder模式十分灵活</p></li></ol></li><li><p>缺点：</p><ol><li>为了创建对象，必须先创建它的构建器</li><li>模式较冗长，但容易扩展</li></ol></li></ul></li><li><p>总结：<strong>如果类的构造器或者静态工厂中具有多个参数，Builder模式是一种不错的选择</strong>，特别是当大多数参数类型相同或是可选参数时</p></li></ol></li><li><p>第三条：用私有构造器或者枚举类型强化Singleton属性</p><ol><li><p>Singleton是指仅仅被实例化一次的类，通常被用来代表无状态的对象，比如那些本质上唯一的系统组件</p></li><li><p>方案1：饿汉式(静态常量),懒加载问题有时可忽略</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、构造器私有化(防止外部new)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、类内创建对象(静态常量)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">// 3、向外暴露静态公共方法,返回单例instance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 缺陷：如果Singleton需要可序列化，仅仅加上implements Serializable是不够的。为了维护并保证Singleton，必须声明所有实例域都是瞬时(transient)的，并提供一个readResolve方法。否则每次反序列化一个序列化的实例时都会创建一个新的实例</p></li><li><p>方案2：声明一个包含单个元素的枚举类型</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 优点：该方式无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但<strong>单枚举类型经常成为实现Singleton的最佳方法</strong><br> 注意：如果Singleton必须扩展一个超类，而不是扩展Enum时，则不宜使用这个方法</p></li><li><p>单例模式的其他介绍参见设计模式</p></li></ol></li><li><p>第四条：通过私有构造器强化不可实例化的能力</p><ol><li><p>有时可能需要编写只包含静态方法和静态域的类。这些工具类不希望被实例化，因为实例化对它没有任何意义。然而在缺少显式构造器的情况下，编译器会自动提供一个公有的、无参的缺省构造器。对于用户而言，这个构造器与其他的构造器没有任何区别</p></li><li><p><strong>企图通过将类做成抽象类来强制该类不可被实例化是行不通的</strong>。该类可以被子类化并且该子类也可以被实例化。这种方式还会产生误导</p></li><li><p>有些简单方法可以确保类不可被实例化。由于只有当类不包含显式的构造器时，编译器才会生成缺省的构造器，因此只要让<strong>该类包含一个私有构造器，它就不能被实例化</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">UtilClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常能避免在类内部调用私有构造器；<strong>最好的做法是在私有构造器中标明注释以及抛出异常时显式指出异常信息</strong>。这种方法也有副作用————它使得此类不能被子类化(所有构造器都必须显式或隐式调用超类构造器)</p></li></ol></li><li><p>第五条：优先考虑依赖注入来引用资源</p><ol><li>有许多类会依赖一个或多个底层的资源，<strong>但静态工具类Singleton类不适合需要引用底层资源的类</strong></li><li>依赖注入适用于任意数量的资源以及任意的依赖形式。依赖注入的对象资源具有不可变性，因此多个客户端可以共享依赖对象(假设客户端们想要的是同一个底层资源)。依赖注入也同样适用于构造器、静态工厂和构建器</li><li>依赖注入的最简单的模式是<strong>当创建一个新实例时就将该资源传到构造器中</strong>；另一种有用的变体是将资源工厂(factory)传给构造器，工厂是可以被重复调用来创建类型实例的一个对象，这类工厂具体表现为工厂方法模式(Java8增加的接口SupplierT&lt;&gt;最适合用于表示工厂)；另一种方式是采用依赖注入框架，如Dagger、Guice或Spring(设置成手动依赖注入的API,一般都适用)</li><li>总结：不要用Singleton和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源。应该将这些资源或者工厂传给构造器(静态工厂/构建器)，通过它们来创建类。该实践就被称作依赖注入，它极大地提升了类的灵活性、可重用性和可测试性</li></ol></li><li><p>第六条：避免创建不必要的对象</p><ol><li><p>一般来说最好能用单个对象，而不是在每次需要的时候就创建一个相同功能的新对象。重用方式既快速，又流行。如果对象是不可变的(immutable)，它就始终可以被重用</p></li><li><p>对于同时提供了静态工厂方法(static factory method)和构造器的不可变类，通常优先使用静态工厂方法而不是构造器，以避免创建不必要的对象</p></li><li><p>有些对象创建的成本比其他对象要高得多。如果重复地需要这类”昂贵的对象”，建议将它缓存下来重用<br> <code>案例如下：</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.matches(<span class="string">"xxxx"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern pattern = Pattern.compile(<span class="string">"xxxx"</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：<strong>String.matches()方法易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的情形中重复使用</strong>。问题在于，它在内部为正则表达式创建了一个Pattern实例，却只使用了一次，之后就可以进行垃圾回收了。创建Pattern的实例的成本很高，因为需要将正则表达式编译成一个有限状态机(finite state machine)。为了提升性能，应该显式地将正则表达式编译成一个Pattern实例(不可变)，让它成为类初始化的一部分，并将它缓存起来</p></li><li><p>如果一个对象是不变的，那么它显然能够被安全地重用，但其他有些情形则并不总是这么明显。考虑虑适配器(adapter)的情形，有时也叫作视图(view)。适配器是指这样一个对象：它把功能委托给一个后备对象(backing object)，从而为后备对象提供一个可以替代的接口。由于适配器除了后备对象之外没有其他的状态信息，所以针对某个给定对象的特定适配器而言，它不需要创建多个适配器实例</p></li><li><p>例如Map接口的keySet()方法返回该Map对象的Set视图，其中包含该Map中所有的键(key)。乍看之下，好像每次调用keySet()都应该创建一个新的Set实例，但对于一个给定的Map对象，实际上每次调用keySet()都返回同样的Set实例。虽然被返回的Set实例一般是可改变的，但所有返回的对象在功能上是等同的；当其中一个返回对象发生变化的时候，所有其他的返回对象也要发生变化，因为它们是由同一个Map实例支撑的</p></li><li><p>另一种创建多余对象的方法，称作自动装箱(autoboxing)。它允许程序员将基本类型和装箱基本类型(Boxed Primitive Type)混用，按需要自动装箱和拆箱。<strong>自动装箱使基本类型和装箱基本类型之间的差别变得模糊起来，但并没有完全消除</strong>。它们在语义上还有着微妙的差别，在性能上也有着比较明显的差别<br> <code>案例如下</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long sum = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) sum += i;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：这段程序算出的答案是正确的，但是比实际情况要更慢一些，只因为声明为装箱类型。变量sum 被声明成Long而不是long意味着程序构造了大约2^31个多余的Long实例(大约每次往Long sum中增加long时构造一个实例)。因此，<strong>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱</strong></p></li><li><p>不要错误地认为本条目所介绍的内容暗示着”创建对象的代价非常昂贵,应尽可能避免创建对象”。相反，由于小对象的构造器只做很少量的显式工作，小对象的创建和回收动作是非常廉价的，特别是在现代的JVM 实现上更是如此。通过创建附加的对象，提升程序的清晰性、简洁性和功能性，这通常是件好事</p></li><li><p>反之通过维护自己的对象池(object pool)来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的。正确使用对象池的典型对象示例就是数据库连接池。建立数据库连接的代价是非常昂贵的，因此重用这些对象非常有意义。而且，数据库的许可可能限制只能使用一定数量的连接。但一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用(footprint)，并且还可能会损害性能。现代的JVM实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能</p></li></ol></li><li><p>第七条：消除过期的对象引用</p><ol><li><p>简单案例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    elements[size++] = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elements[--size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">      elements = Arrays.copyOf(elements, size + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例解读：没有很明显的错误。无论如何测试，它都会成功地通过每一项测试，但是当中隐藏着一个问题。不严格地讲，这段程序有一个”内存泄漏”，随着垃圾回收器活动的增加，或者由于内存占用的不断增加，程序性能的降低会逐渐表现出来。在极端的情况下，这种内存泄漏会导致磁盘交换(Disk Paging)，甚至导致程序失败(OutOfMemoryError错误)，但这种失败情形相对比较少见</p></li><li><p>案例中哪里发生了内存泄漏呢？<br>如果一个栈先是增长然后再收缩，那么从栈中弹出来的对象将不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，它们也不会被回收。这是因为栈内部维护着对这些对象的过期引用(obsolete reference)。所谓的过期引用，是指永远也不会再被解除的引用。在本例中，凡是在elements数组的”活动部分”(active portion)之外的任何引用都是过期的。活动部分是指elements中下标小于size的那些元素</p></li><li><p>在支持垃圾回收的语言中，内存泄漏是很隐蔽的(称这类内存泄漏为”无意识的对象保持”(unintentional object retention)更为恰当)。如果一个对象引用被无意识地保留起来了，那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象。即使只有少量的几个对象引用被无意识地保留下来，也会有许许多多的对象被排除在垃圾回收机制之外，从而对性能造成潜在的重大影响</p></li><li><p>这类问题的修复方法很简单：一旦对象引用已经过期，只需清空这些引用即可。对于上述案例中的Stack类而言，只要一个单元被弹出栈，指向它的引用就过期了。pop()方法的修订版本如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">  Object result = elements[--size];</span><br><span class="line">  elements[size] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清空过期引用的另一个好处是，如果它们以后又被错误地解除引用，程序就会立即抛出NullPointerException异常，而不是悄悄地错误运行下去。尽快地检测出程序中的错误总是有益的</p></li><li><p>当第一次被类似这样的问题困扰的时候，往往会过分小心：对于每一个对象引用，一旦程序不再用到它，就把它清空。其实这样做既没必要，也不是我们所期望的，因为这样做会把程序代码弄得很乱。<strong>清空对象引用应该是一种例外，而不是一种规范行为</strong>。消除过期引用最好的方法是让包含该引用的变量结束其生命周期。如果是在最紧凑的作用域范围内定义每一个变量，这种情形就会自然地发生</p></li><li><p>一般来说，<strong>只要类是自己管理内存，就应该警惕内存泄漏问题</strong>。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空</p></li><li><p><strong>内存泄漏的另一个常见来源是缓存</strong>。一旦把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中。一种有效的方案如下：<br>只要在缓存之外存在对某个项的键的引用，该项就有意义，那么就可以用WeakHashMap代表缓存。当缓存中的项过期之后，它们就会自动被删除。但只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，WeakHashMap才有用处</p></li><li><p>更为常见的情形则是，”缓存项的生命周期是否有意义”并不是很容易确定，随着时间的推移，其中的项会变得越来越没有价值。在这种情况下，缓存应该时不时地清除掉没用的项。这项清除工作可以由一个后台线程(可能是ScheduledThreadPoolExecutor)来完成，或者也可以在给缓存添加新条目的时候顺便进行清理。LinkedHashMap类利用它removeEldestEntry()方法可以很容易地实现后一种方案。对于更复杂的缓存，可以使用java.lang.ref</p></li><li><p><strong>内存泄漏的第三个常见来源是监昕器和其他回调</strong>。如果你实现了一个API，客户端在这个API中注册了回调，却没有显式地取消注册，那么除非你采取某些动作，否则它们就会不断地堆积起来。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用(weak reference)，例如，只将它们保存成WeakHashMap中的键</p></li><li><p>由于内存泄漏通常不会表现成明显的失败，所以它们可以在一个系统中存在很多年。往往只有通过仔细检查代码，或者借助于Heap剖析工具(Heap Profiler)才能发现内存泄漏问题。因此如果能够在内存泄漏发生之前就知道如何预测此类问题并阻止它们发生，那是最好不过的</p></li></ol></li><li><p>第8条：避免使用终结方法和清除方法</p><ol><li><strong>终结方法(finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的</strong>。用终结方法会导致行为不稳定、性能降低，以及可移植性问题。当然，终结方法也有其可用之处；但是根据经验，应该避免使用终结方法。在Java9中使用清除方法(cleaner)代替了终结方法。<strong>清除方法没有终结方法那么危险，但仍然不可预测、运行缓慢，一般情况下也是不必要的</strong></li><li>在C++中，析构器是回收一个对象所占用资源的常规方法，是构造器所必需的对应物。而在Java中，当一个对象变得不可到达的时候，垃圾回收器会回收与该对象相关联的存储空间，并不需要程序员做专门的工作。C++的析构器也可以被用来回收其他的非内存资源，而在Java中一般用try-finally块来完成类似的工作</li><li>终结方法和清除方法的缺点在于不能保证会被及时执行。从一个对象变得不可到达开始，到它的终结方法被执行，所花费的这段时间是任意长的。这意味着，<strong>注重时间(time-critical)的任务不应该由终结方法或者清除方法来完成</strong>。例如用终结方法或者清除方法来关闭已经打开的文件，这就是个严重的错误，因为打开文件的描述符是一种很有限的资源。如果系统无法及时运行终结方法或者清除方法就会导致大量的文件仍然保留在打开状态，于是当一个程序再也不能打开文件的时候，它可能会运行失败</li><li>及时地执行终结方法和清除方法正是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中会大相径庭。如果程序依赖于终结方法或者清除方法被执行的时间点，那么这个程序的行为在不同的JVM中运行的表现可能就会截然不同</li><li>延迟终结过程并不只是一个理论问题。在很少见的情况下，为类提供终结方法可能会随意地延迟其实例的回收过程。Java语言规范并不保证哪个线程将会执行终结方法，所以除了不使用终结方法之外，并没有很轻便的办法能够避免这样的问题。在这方面，清除方法比终结方法稍好一些，因为类的设计者可以控制自己的清除线程，但清除方法仍然在后台运行，处于垃圾回收器的控制之下，因此不能确保及时清除</li><li>Java语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证它们会被执行。当一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有被执行，这是完全有可能的。结论是：<strong>永远不应该依赖终结方法或者清除方法来更新重要的持久状态</strong>。例如，依赖终结方法或者清除方法来释放共享资源(比如数据库)上的永久锁，这很容易让整个分布式系统垮掉</li><li>不要被System.gc()和System.runFinalization()这两个方法所诱惑，它们确实增加了终结方法或者清除方法被执行的机会，但是它们并不保证终结方法或者清除方法会被执行。唯一声称保证它们会被执行的两个方法是System.runFinalizersOnExit()及其臭名昭著的孪生兄弟Runtime.runFinalizersOnExit()。这两个方法都有致命的缺陷，井且已经被废弃很久了</li><li><strong>使用终结方法和清除方法有非常严重的性能损失</strong></li><li><strong>终结方法有一个严重的安全问题：它们为终结方法攻击(finalizer attack)打开了类的大门</strong>。终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体(readObject和readResolve方法)抛出异常，恶意子类的终结方法就可以在构造了部分的应该已经半途夭折的对象上运行。这个终结方法会将对该对象的引用记录在一个静态域中，阻止它被垃圾回收。一旦记录到异常的对象，就可以轻松地在这个对象上调用任何原本永远不允许在这里出现的方法。<strong>从构造器抛出的异常，应该足以防止对象继续存在；有了终结方法的存在，这一点就做不到了</strong>。这种攻击可能造成致命的后果。final类不会受到终结方法攻击，因为没有人能够编写出final类的恶意子类。<strong>为了防止非final类受到终结方法攻击，要编写一个空的final的finalize()方法</strong></li><li>如果类的对象中封装的资源(例如文件或者线程)确实需要终止，应该怎么做才能不用编写终结方法或者清除方法呢？只需<strong>让类实现AutoCloseable</strong>，并要求其客户端在每个实例不再需要的时候调用close()方法，一般是利用try-with-resources确保终止，即使遇到异常也是如此。值得提及的一个细节是，该实例必须记录下自己是否已经被关闭了————close()方法必须在一个私有域中记录下”该对象已经不再有效”。如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并抛出IllegalStateException异常</li><li>学finalize()…</li><li>总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用清除方法，对于在Java9之前的发行版本，则尽量不要使用终结方法。若使用了终结方法或者清除方法，则要注意它的不确定性和性能后果</li></ol></li><li><p>第9条：try-with-resources优先于try-finally</p><ol><li><p>Java类库中包括许多必须通过调用close()方法来手工关闭的资源。例如InputStream、OutputStrea以及java.sql.Connection。客户端经常会忽略资源的关闭，造成严重的性能后果也就可想而知了。虽然这其中的许多资源都是用终结方法作为安全网，但效果并不理想</p></li><li><p>根据经验，try-finally语句是确保资源会被适时关闭的最佳方法，就算发生异常或者返回也一样</p><p> <code>一个try-finally的示例</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reader.readLine();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>即使用try-finally语句正确地关闭了资源，也存在着些许不足。因为在try块和finally块中的代码，都可能会抛出异常。例如在firstLineOfFile()方法中，如果底层的物理设备异常，那么调用readLine()方法就会抛出异常。基于同样的原因，调用close()方法也会出现异常。在这种情况下，第二个异常完全抹除了第一个异常。在异常堆枝轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂，因为通常需要看到第一个异常才能诊断出问题何在。虽然可以通过编写代码来禁止第一个异常，保留第一个异常，但事实上没有人会这么做，因为实现起来太烦琐了</p></li><li><p>当Java7引人try-with-sources语句时，所有这些问题一下子就全部解决。要使用这个构造的资源，必须先实现AutoCloseable接口，其中包含了声明返回值void的close()方法。Java类库与第三方类库中的许多类和接口，现在都实现或扩展了AutoCloseable接口。如果编写了一个类且它代表的是必须被关闭的资源，那么该类也应该实现AutoCloseable</p><p> <code>firstLineOfFile的try-with-sources示例</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">    <span class="keyword">return</span> reader.readLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用try-with-resources不仅使代码变得更简洁易懂，也更容易进行诊断。以firstLineOfFile()方法为例，如果调用readLine()和(不可见的)close()方法都抛出异常，后一个异常就会被禁止，以保留第一个异常。事实上，为了保留想要看到的那个异常，即便多个异常都可以被禁止。这些被禁止的异常并不是简单地被抛弃了，而是会被打印在堆栈轨迹中，并注明它们是被禁止的异常。通过编程调用getSuppressed()方法还可以访问到它们，getsuppressed()方法已经添加到Java7的Throwable类中</p></li><li><p>在try-with-resources语句中还可以使用catch子句，就像在平时的try-finally语句一样</p></li><li><p>结论：在处理必须关闭的资源时，始终要优先考虑用try-with-resources，而不是用try-finally。这样得到的代码将更加简洁、清晰，产生的异常也更有价值。有了try-with-resources语句，在使用必须关闭的资源时，就能更轻松地正确编写代码了。实践证明，这个用try-finally是不可能做到的</p></li></ol></li></ul><h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志</title>
      <link href="/2020/10/29/ProgrammingLanguage/Java/Java%E6%97%A5%E5%BF%97/"/>
      <url>/2020/10/29/ProgrammingLanguage/Java/Java%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#日志介绍">日志介绍</a></li><li><a href="#日志实现">日志实现</a></li><li><a href="#日志门面">日志门面</a></li><li><a href="#SpringBoot中的日志">SpringBoot中的日志</a></li></ul><a id="more"></a><h2 id="日志介绍"><a href="#日志介绍" class="headerlink" title="日志介绍"></a>日志介绍</h2><ul><li><strong>日志文件是用于记录系统操作事件的文件集合</strong>，可分为事件日志和消息日志。具有处理历史数据、诊断问题的追踪以及理解系统的活动等重要作用。在计算机中，日志文件是记录在操作系统或其他软件运行中发生的事件或在通信软件的不同用户之间的消息的文件</li><li>日志的价值、好处：<ol><li>记录系统中硬件、软件和系统问题的信息，监视系统中发生的事件</li><li>检查错误发生的原因</li><li>发现一些之前从未意识到的问题</li></ol></li><li>现有Java日志框架介绍：<ul><li>日志实现：<ol><li>JUL(java util logging)</li><li>logback</li><li>log4j</li><li>log4j2</li></ol></li><li>日志门面：<ol><li>JCL(Jakarta Commons Logging)</li><li>slf4j(Simple Logging Facade for Java)</li><li>log4j2</li></ol></li></ul></li><li>为什么需要日志框架：<ol><li>集中精力完成系统的业务逻辑设计</li><li>框架一般是成熟，稳健的，可以处理系统很多细节问题</li><li>经过实践检验，结构很好，扩展性强，可以不断升级</li></ol></li><li>Java日志框架主要解决的问题：<ol><li>控制日志输出的内容和格式</li><li>控制日志输出的位置(file,console)</li><li>日志优化：异步日志，日志文件的归档和压缩</li><li>日志系统的维护</li><li>面向接口开发——日志的门面(适配性能更高的日志框架)</li></ol></li></ul><h2 id="日志实现"><a href="#日志实现" class="headerlink" title="日志实现"></a>日志实现</h2><ol><li><p>JUL入门</p><ul><li><p>JUL介绍：全称Java util Logging，是java原生的日志框架，使用时不需要另外引用第三方类库。相对其他日志框架使用方便，学习简单，能够在小型应用中灵活使用</p></li><li><p>架构介绍：<br><img src="JUL%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="JUL架构示意图"><br>Loggers：记录器，应用程序通过获取Logger对象调用其API来发布日志信息。Logger通常是应用程序访问日志系统的入口<br>Appenders：也称为Handlers，每个Logger都会关联一组Handlers。Logger将日志交给关联Handlers处理，由Handlers负责将日志做记录。Handlers是一个抽象，其具体的实现决定了日志记录的位置，可以是控制台、文件、网络上的其他日志服务或操作系统日志等<br>Layouts：也称为Formatters，负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式<br>Level：每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，可以将Level和Loggers，Appenders关联以便于过滤消息<br>Filters：过滤器，根据需要定制哪些信息会被记录，哪些信息会被放行</p></li><li><p>入门案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取日志记录器</span></span><br><span class="line">Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line"><span class="comment">// 2、日志记录输出</span></span><br><span class="line">logger.info(<span class="string">"Hello JUL~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用方法进行日志记录</span></span><br><span class="line">logger.log(Level.INFO, <span class="string">"Hello SOBXiong~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过占位符方式输出变量值</span></span><br><span class="line">String name = <span class="string">"SOBXiong"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line">logger.log(Level.INFO, <span class="string">"Hello &#123;0&#125;,&#123;1&#125;"</span>, <span class="keyword">new</span> Object[]&#123;name, age&#125;);</span><br></pre></td></tr></table></figure></li><li><p>日志级别：</p><ol><li>SEVERE(最高值)</li><li>WARNING</li><li>INFO(默认级别)</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST(最低值)</li><li>OFF(关闭日志记录)</li><li>ALL(启用所有消息的日志记录)</li></ol></li><li><p>自定义日志级别案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取日志记录器</span></span><br><span class="line">Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭系统默认配置</span></span><br><span class="line">logger.setUseParentHandlers(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义日志级别</span></span><br><span class="line"><span class="comment">// 创建ConsoleHandler</span></span><br><span class="line">ConsoleHandler consoleHandler = <span class="keyword">new</span> ConsoleHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建简单格式转换对象</span></span><br><span class="line">SimpleFormatter simpleFormatter = <span class="keyword">new</span> SimpleFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行关联</span></span><br><span class="line">consoleHandler.setFormatter(simpleFormatter);</span><br><span class="line">logger.addHandler(consoleHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置日志具体级别</span></span><br><span class="line">logger.setLevel(Level.ALL);</span><br><span class="line">consoleHandler.setLevel(Level.ALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileHandler文件输出</span></span><br><span class="line">FileHandler fileHandler = <span class="keyword">new</span> FileHandler(<span class="string">"jul.log"</span>);</span><br><span class="line">fileHandler.setFormatter(simpleFormatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行关联(一个logger可以设置多个handler)</span></span><br><span class="line">logger.addHandler(fileHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、日志记录输出</span></span><br><span class="line">logger.severe(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger.warning(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line"><span class="comment">// jul默认日志级别为info</span></span><br><span class="line">logger.info(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger.config(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger.fine(<span class="string">"Hello SOBXiong"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Logger之间父子关系案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JUL中Logger之间存在父子关系，这种父子关系通过树状结构存储。JUL在初始化时会创建一个顶层RootLogger作为所有Logger的父Logger，存储上作为树状结构的根节点。父子关系通过路径来关联</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Logger logger1 = Logger.getLogger(<span class="string">"com.xiong"</span>);</span><br><span class="line">Logger logger2 = Logger.getLogger(<span class="string">"com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">logger1.log(Level.INFO, <span class="string">"logger1 == logger2 &#123;0&#125;"</span>, logger1.getParent() == logger2);</span><br><span class="line">System.out.println(logger2.getParent());</span><br><span class="line"><span class="comment">// 所有日志记录器的顶级父元素: LogManager$RootLogger, name为空</span></span><br><span class="line">System.out.println(logger2.getParent().getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭默认配置</span></span><br><span class="line">logger2.setUseParentHandlers(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置logger2日志级别</span></span><br><span class="line">ConsoleHandler consoleHandler = <span class="keyword">new</span> ConsoleHandler();</span><br><span class="line">SimpleFormatter simpleFormatter = <span class="keyword">new</span> SimpleFormatter();</span><br><span class="line">consoleHandler.setFormatter(simpleFormatter);</span><br><span class="line">logger2.addHandler(consoleHandler);</span><br><span class="line">logger2.setLevel(Level.ALL);</span><br><span class="line">consoleHandler.setLevel(Level.ALL);</span><br><span class="line"></span><br><span class="line">logger1.severe(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger1.warning(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger1.info(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger1.config(<span class="string">"Hello SOBXiong"</span>);</span><br><span class="line">logger1.fine(<span class="string">"Hello SOBXiong"</span>);</span><br></pre></td></tr></table></figure></li><li><p>日志配置文件案例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RootLogger顶级父元素指定的默认处理器为ConsoleHandler</span></span><br><span class="line"><span class="attr">handlers</span>=<span class="string">java.util.logging.ConsoleHandler,java.util.logging.FileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RootLogger顶级父元素默认日志级别为ALL,名次为空</span></span><br><span class="line"><span class="meta">.level</span>=<span class="string">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义Logger</span></span><br><span class="line"><span class="meta">com.xiong.logger.handlers</span>=<span class="string">java.util.logging.ConsoleHandler</span></span><br><span class="line"><span class="meta">com.xiong.logger.level</span>=<span class="string">CONFIG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭默认配置</span></span><br><span class="line"><span class="meta">com.xiong.logger.useParentHandlers</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向日志文件输出的handler对象</span></span><br><span class="line"><span class="comment"># 指定日志文件路径</span></span><br><span class="line"><span class="meta">java.util.logging.FileHandler.pattern</span>=<span class="string">java%u.log</span></span><br><span class="line"><span class="comment"># 指定日志文件内容大小</span></span><br><span class="line"><span class="meta">java.util.logging.FileHandler.limit</span>=<span class="string">50000</span></span><br><span class="line"><span class="comment"># 指定日志文件数量</span></span><br><span class="line"><span class="meta">java.util.logging.FileHandler.count</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 指定handler对象日志消息格式对象</span></span><br><span class="line"><span class="meta">java.util.logging.FileHandler.formatter</span>=<span class="string">java.util.logging.SimpleFormatter</span></span><br><span class="line"><span class="comment"># 指定以追加方式添加日志内容</span></span><br><span class="line"><span class="meta">java.util.logging.FileHandler.append</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向控制台输出的handler对象</span></span><br><span class="line"><span class="comment"># 指定handler对象的日志级别</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.level</span>=<span class="string">ALL</span></span><br><span class="line"><span class="comment"># 指定handler对象的日志消息格式对象</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.formatter</span>=<span class="string">java.util.logging.SimpleFormatter</span></span><br><span class="line"><span class="comment"># 指定handler对象的字符集</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志消息格式</span></span><br><span class="line"><span class="meta">java.util.logging.SimpleFormatter.format</span>=<span class="string">%4$s: %5$s [%1$tc]%n</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件,通过类加载器</span></span><br><span class="line">InputStream is = getClass().getClassLoader().getResourceAsStream(<span class="string">"logging.properties"</span>);</span><br><span class="line"><span class="comment">// 创建LogManager</span></span><br><span class="line">LogManager logManager = LogManager.getLogManager();</span><br><span class="line"><span class="comment">// 通过LogManager加载配置文件</span></span><br><span class="line">logManager.readConfiguration(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建日志记录器</span></span><br><span class="line">Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line"></span><br><span class="line">logger.severe(<span class="string">"Hello SOBXiong1"</span>);</span><br><span class="line">logger.warning(<span class="string">"Hello SOBXiong2"</span>);</span><br><span class="line">logger.info(<span class="string">"Hello SOBXiong3"</span>);</span><br><span class="line">logger.config(<span class="string">"Hello SOBXiong4"</span>);</span><br><span class="line">logger.fine(<span class="string">"Hello SOBXiong5"</span>);</span><br></pre></td></tr></table></figure></li><li><p>日志原理解析：<br><img src="JUL%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="JUL流程示意图"></p><ol><li>初始化LogManager<ol><li>LogManager加载logging.properties配置</li><li>添加Logger到LogManager</li></ol></li><li>从单例LogManager获取Logger</li><li>设置级别Level，并指定日志记录LogRecord</li><li>Filter提供了日志级别之外更细粒度的控制</li><li>Handler用来处理日志输出位置</li><li>Formatter用来格式化LogRecord</li></ol></li></ul></li><li><p>log4j入门</p><ul><li><p>log4j介绍：Log4j是Apache下的一款开源的日志框架，通过在项目中使用Log4J，可控制日志信息输出到控制台、文件、甚至是数据库中。可控制每一条日志的输出格式；通过定义日志的输出级别，可以更灵活地控制日志的输出过程；方便项目的调试。官网：<a href="http://logging.apache.org/log4j/1.2/" target="_blank" rel="noopener">http://logging.apache.org/log4j/1.2/</a></p></li><li><p>入门案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化配置信息,当前暂使用代码不使用配置文件</span></span><br><span class="line">BasicConfigurator.configure();</span><br><span class="line"><span class="comment">// 获取日志记录器对象</span></span><br><span class="line">Logger logger = Logger.getLogger(Log4jTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 日志记录输出</span></span><br><span class="line">logger.info(<span class="string">"Hello Log4j"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别</span></span><br><span class="line"><span class="comment">// 严重错误,一般会造成系统崩溃并终止运行</span></span><br><span class="line">logger.fatal(<span class="string">"fatal"</span>);</span><br><span class="line"><span class="comment">// 错误信息,不会影响系统运行</span></span><br><span class="line">logger.error(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// 警告信息,可能会发生问题</span></span><br><span class="line">logger.warn(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// 运行信息,数据连接、网络连接、IO操作等等</span></span><br><span class="line">logger.info(<span class="string">"info"</span>);</span><br><span class="line"><span class="comment">// 调试信息,一般在开发中使用,记录程序变量参数传递信息等等</span></span><br><span class="line">logger.debug(<span class="string">"debug"</span>);</span><br><span class="line"><span class="comment">// 追踪信息,记录程序所有的流程信息</span></span><br><span class="line">logger.trace(<span class="string">"trace"</span>);</span><br></pre></td></tr></table></figure></li><li><p>日志级别：</p><ol><li>fatal：指出每个将会导致应用程序退出的严重的错误事件</li><li>error：指出虽然发生错误事件，但仍然不影响系统继续运行</li><li>warn：表明会出现潜在的错误情形</li><li>info：一般用于粗粒度级别上，强调应用程序的运行全程</li><li>debug：一般用于细粒度级别上，对调试应用程序非常有帮助</li><li>trace：程序追踪，可以用于输出程序运行中的变量，显示执行的流程</li><li>OFF：用来关闭日志记录</li><li>ALL：启用所有消息的日志记录</li></ol></li><li><p>组件：log4j主要由Loggers(日志记录器)、Appenders(输出端)和Layout(日志格式化器)组成。其中Loggers控制日志的输出级别与日志是否输出；Appenders指定日志的输出方式(输出到控制台、文件等)；Layout控制日志信息的输出格式</p><ol><li>Loggers：日志记录器，负责收集处理日志记录。实例的命名就是类的全限定名，Logger的名字大小写敏感，其命名有继承机制。例如：name为org.apache.commons的logger会继承name为org.apache的logger<br>log4j中有一个特殊的logger叫”root”，它是所有logger的根，也意味着其他所有的logger都会直接或者间接地继承自root。root logger可以用Logger.getRootLogger()方法获取</li><li>Appenders：用来指定日志输出到哪个地方，可以同时指定日志的输出目的地。常用有以下5种：<table><thead><tr><th>输出端类型</th><th>作用</th></tr></thead><tbody><tr><td>ConsoleAppender</td><td>将日志输出到控制台</td></tr><tr><td>FileAppender</td><td>将日志输出到文件中</td></tr><tr><td>DailyRollingFileAppender</td><td>将日志输出到一个日志文件,并且每天输出到一个新的文件</td></tr><tr><td>RollingFileAppender</td><td>将日志信息输出到一个日志文件,并且指定文件的最大尺寸;当文件大小达到指定尺寸时,会自动把文件改名,同时产生一个新的文件</td></tr><tr><td>JDBCAppender</td><td>把日志信息保存到数据库中</td></tr></tbody></table></li><li>Layouts：布局器Layouts用于控制日志输出内容的格式，可使用各种指定的格式输出日志。常用的Layouts有以下3种：<table><thead><tr><th>格式化器类型</th><th>作用</th></tr></thead><tbody><tr><td>HTMLLayout</td><td>格式化日志输出为HTML表格形式</td></tr><tr><td>SimpleLayout</td><td>简单的日志输出格式化,打印的日志格式为(info - message)</td></tr><tr><td>PatternLayout</td><td>最强大的格式化器,可以根据自定义格式输出日志;如果没有指定转换格式,就是用默认的转换格式</td></tr></tbody></table></li></ol></li><li><p>Layout格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># log4j采用类似C语言printf()函数的打印格式格式化日志信息,具体的占位符及其含义如下： %m 输出代码中指定的日志信息</span><br><span class="line">%p 输出优先级,即DEBUG、INFO等</span><br><span class="line">%n 换行符</span><br><span class="line">%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">%c 输出打印语句所属的类的全名</span><br><span class="line">%t 输出产生该日志的线程全名</span><br><span class="line">%d 输出服务器当前时间,默认为ISO8601;也可以指定格式,如：%d&#123;yyyy年MM月dd日 HH:mm:ss&#125;</span><br><span class="line">%l 输出日志时间发生的位置,包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10)</span><br><span class="line">%F 输出日志消息产生时所在的文件名称</span><br><span class="line">%L 输出代码中的行号</span><br><span class="line">%% 输出一个'%'字符</span><br><span class="line"></span><br><span class="line"># 可以在'%'与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式：</span><br><span class="line">%5c 输出category名称,最小宽度是5;category&lt;5,默认的情况下右对齐</span><br><span class="line">%-5c 输出category名称,最小宽度是5;category&lt;5,"-"号指定左对齐,会有空格</span><br><span class="line">%.5c 输出category名称,最大宽度是5;category&gt;5,就会将左边多出的字符截掉;&lt;5不会有空格</span><br><span class="line">%20.30c 输出category名称,&lt;20补空格,并且右对齐;&gt;30就从左边多出的字符截掉</span><br></pre></td></tr></table></figure></li><li><p>配置文件案例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认类路径下的log4j.properties文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定RootLogger顶级父元素默认配置</span></span><br><span class="line"><span class="comment"># 指定日志级别为trace,使用appender为console、file</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">trace,console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义logger对象设置,不显式声明appender则使用rootLogger的appender</span></span><br><span class="line"><span class="meta">log4j.logger.com.xiong.logger</span> = <span class="string">info,file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定控制台日志输出的appender</span></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="comment"># 指定消息格式layout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment"># 指定消息格式内容(OGNL表达式)</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.conversionPattern</span> = <span class="string">[%-10p]%r  %l %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件输出的appender对象</span></span><br><span class="line"><span class="meta">log4j.appender.file</span> = <span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="comment"># 指定消息格式layout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment"># 指定消息格式内容(OGNL表达式)</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.conversionPattern</span> = <span class="string">[%-10p]%r  %l %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %m%n</span></span><br><span class="line"><span class="comment"># 指定日志文件保存路径</span></span><br><span class="line"><span class="meta">log4j.appender.file.file</span> = <span class="string">log4j.log</span></span><br><span class="line"><span class="comment"># 指定日志文件的字符集</span></span><br><span class="line"><span class="meta">log4j.appender.file.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照文件大小拆分的appender对象</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile</span> = <span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="comment"># 指定消息格式layout</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment"># 指定消息格式内容(OGNL表达式)</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.layout.conversionPattern</span> = <span class="string">[%-10p]%r  %l %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %m%n</span></span><br><span class="line"><span class="comment"># 指定日志文件保存路径</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.file</span> = <span class="string">log4j.log</span></span><br><span class="line"><span class="comment"># 指定日志文件的字符集</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># 指定日志文件内容的大小</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.maxFileSize</span> = <span class="string">1MB</span></span><br><span class="line"><span class="comment"># 指定日志文件的数量</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.maxBackupIndex</span> = <span class="string">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照时间规则拆分的appender对象</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile</span> = <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="comment"># 指定消息格式layout</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment"># 指定消息格式内容(OGNL表达式)</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.layout.conversionPattern</span> = <span class="string">[%-10p]%r  %l %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %m%n</span></span><br><span class="line"><span class="comment"># 指定日志文件保存路径</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.file</span> = <span class="string">log4j.log</span></span><br><span class="line"><span class="comment"># 指定日志文件的字符集</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.encoding</span> = <span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># 指定日期的拆分规则</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.datePattern</span> = <span class="string">'.'yyyy-MM-dd-HH-mm-ss</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>logback入门：</p><ul><li><p>logback介绍：Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好。官网：<a href="https://logback.qos.ch/index.html" target="_blank" rel="noopener">https://logback.qos.ch/index.html</a><br>logback主要分为三个模块：</p><ol><li>logback-core：基础核心模块</li><li>logback-classic：log4j的一个改良版本，并完整实现了slf4j API</li><li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能</li></ol></li><li><p>入门案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogbackTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由于logback和slf4j是同一作者,API设置差不多</span></span><br><span class="line">  <span class="comment">// 日志输出</span></span><br><span class="line">  logger.error(<span class="string">"error"</span>);</span><br><span class="line">  logger.warn(<span class="string">"warn"</span>);</span><br><span class="line">  logger.info(<span class="string">"info"</span>);</span><br><span class="line">  logger.debug(<span class="string">"debug"</span>);</span><br><span class="line">  logger.trace(<span class="string">"trace"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>logback配置：</p><ul><li><p>读取配置流程(依次去读)：</p><ol><li>logback.groovy</li><li>logback-test.xml</li><li>logback.xml</li><li>默认配置</li></ol></li><li><p>logback组件间的关系：</p><ol><li>Logger：日志记录器，关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别</li><li>Appender：用于指定日志输出的目的地，可以是控制台、文件、数据库等等</li><li>Layout：负责把事件转换成字符串(格式化的日志信息)。在logback中Layout对象被封装在encoder中</li></ol></li><li><p>基本配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    日志输出格式：</span></span><br><span class="line"><span class="comment">    %-5level: 级别,左对齐,5个字符</span></span><br><span class="line"><span class="comment">    %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;: 格式化日期</span></span><br><span class="line"><span class="comment">    %c: 类的完整名称</span></span><br><span class="line"><span class="comment">    %M: method方法名</span></span><br><span class="line"><span class="comment">    %L: 行号</span></span><br><span class="line"><span class="comment">    %thread: 线程名称</span></span><br><span class="line"><span class="comment">    %m/%msg: 信息</span></span><br><span class="line"><span class="comment">    %n: 换行</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 定义打印pattern --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %c [%thread] %-5level %msg%n"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 定义日志文件保存路径属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logDir"</span> <span class="attr">value</span>=<span class="string">"logback"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 控制台日志输出的appender --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制输出流对象,默认System.out,改为System.err --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span>&gt;</span>System.err<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志消息格式配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 日志文件输出的appender --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logDir&#125;/tmp.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志消息格式配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- HTML格式日志文件输出appender --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"htmlFile"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logDir&#125;/tmp.html<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- html日志消息格式配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.html.HTMLLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 日志拆分和归档压缩的appender对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"rollFile"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;logDir&#125;/roll_logback.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志消息格式配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定拆分规则 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 按照时间和压缩格式声明拆分的文件名 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %i根据文件排序 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;logDir&#125;/rolling.%d&#123;yyyy-MM-dd-HH-mm-ss&#125;.%i.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 按照文件大小拆分 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志级别过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 日志过滤规则 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 异步日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"async"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定某个具体的appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"rollFile"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- root logger配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"ALL"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;appender-ref ref="console"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;appender-ref ref="file"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;appender-ref ref="htmlFile"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"async"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  自定义logger对象</span></span><br><span class="line"><span class="comment">  additivity: 自定义logger对象是否继承rootLogger</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.xiong.logger"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>logback-access使用：logback-access模块与Servlet容器(如Tomcat、Jetty)集成以提供HTTP访问日志功能。可使用logback-access模块来替换tomcat的访问日志</p><ol><li><p>将logback-access.jar与logback-core.jar复制到$TOMCAT_HOME/lib/目录下</p></li><li><p>修改$TOMCAT_HOME/conf/server.xml中的Host元素中添加：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"ch.qos.logback.access.tomcat.LogbackValve"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>logback默认会在$TOMCAT_HOME/conf下查找文件logback-access.xml</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 参考自http://logback.qos.ch/access.html#configuration --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- always a good activate OnConsoleStatusListener --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">statusListener</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.status.OnConsoleStatusListener"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_DIR"</span> <span class="attr">value</span>=<span class="string">"$&#123;catalina.base&#125;/logs"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_DIR&#125;/access.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>access.%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 访问日志的格式 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>combined<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li><li><p>log4j2入门(即是日志门面也是日志实现)：</p><ul><li><p>log4j2介绍：Apache Log4j2是对Log4j的升级版，参考了logback的一些优秀的设计，并且修复了一些问题，带来了一些重大的提升，主要有：</p><ol><li>异常处理：在logback中，Appender中的异常不会被应用感知到；在log4j2中提供了一些异常处理机制</li><li>性能提升：log4j2相较于log4j和logback具有明显的性能提升</li><li>自动重载配置：参考了logback的设计，提供了自动刷新参数配置，在生产上可以动态地修改日志的级别而不需要重启应用</li><li>无垃圾机制：log4j2在大部分情况下都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的JVM GC<br>官网：<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/</a></li></ol></li><li><p>入门案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Log4j2门面API--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Log4j2日志实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义日志记录器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(Log4j2Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速入门</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 日志消息输出</span></span><br><span class="line">  logger.error(<span class="string">"error"</span>);</span><br><span class="line">  logger.warn(<span class="string">"warn"</span>);</span><br><span class="line">  logger.info(<span class="string">"info"</span>);</span><br><span class="line">  logger.debug(<span class="string">"debug"</span>);</span><br><span class="line">  logger.trace(<span class="string">"trace"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>log4j2配置：log4j2默认加载classpath下的log4j2.xml文件中的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">status="debug": warn为日志框架本身的输出日志级别</span></span><br><span class="line"><span class="comment">monitorInterval="5": 自动加载配置文件的间隔时间,不低于5s</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"debug"</span> <span class="attr">monitorInterval</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 集中配置属性进行管理,可以使用$&#123;&#125;获取 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>log4j2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 日志处理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] [%-5level] %c&#123;36&#125;:%L - -- %m%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志文件输出appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/file.log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%-5level] %l %c&#123;36&#125; - %m%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 随机读写流输出appender,性能提高 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RandomAccessFile</span> <span class="attr">name</span>=<span class="string">"accessFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/accessFile.log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%-5level] %l %c&#123;36&#125; - %m%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RandomAccessFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    按照一定的规则拆分日志文件appender</span></span><br><span class="line"><span class="comment">    filePattern拆分规则</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"rollingFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/rollingFile.log"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">filePattern</span>=<span class="string">"log4j2/$$&#123;date:yyyy-MM-dd&#125;/rollingFile-%d&#123;yyyy- MM-dd-HH-mm&#125;-%i.log"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 日志级别过滤器 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 日志消息格式 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%-5level] %l %c&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 策略 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在系统启动时触发拆分规则,产生一个新日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">OnStartupTriggeringPolicy</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按照文件大小进行拆分,产生一个新日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"10 MB"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按照时间节点拆分,规则由filePattern定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在同一个目录下,文件个数限定,超过进行覆盖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- logger定义 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用rootLogger配置以及level --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>log4j2异步日志：log4j2最大的特点就是异步日志，其性能的提升也主要在异步日志<br><img src="%E5%90%8C%E6%AD%A5%E6%97%A5%E5%BF%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="同步日志执行流程示意图"><br><img src="%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="异步日志执行流程示意图"><br>Log4j2提供了两种实现异步日志的方式：</p><ol><li><p>通过AsyncAppender，对应Appender组件</p></li><li><p>通过AsyncLogger，对应Logger组件</p><ul><li>导入依赖(异步日志需要另外依赖)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--异步日志依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>AsyncAppender方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/log4j2.log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"Async"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Async"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>AsyncLogger方式：AsyncLogger才是log4j2的重头戏，也是官方推荐的异步方式。它可使调用Logger.log返回地更快。有两种选择：全局异步和混合异步</p><ol><li><p><strong>全局异步</strong>：所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个<code>log4j2.component.properties</code>配置</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Log4jContextSelector</span>=<span class="string">org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span></span><br></pre></td></tr></table></figure></li><li><p><strong>混合异步</strong>：可在应用中同时使用同步日志和异步日志，这使得日志的配置方式更加灵活</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/log4j2.log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d %p %c&#123;1.&#125; [%t] %m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"Async"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">"com.xiong"</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">includeLocation</span>=<span class="string">"false"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>使用异步日志<strong>需要注意的问题</strong>：</p><ol><li>如果使用异步日志，AsyncAppender、AsyncLogger和全局日志不要同时出现。性能会和AsyncAppender一致，降至最低(木桶原理)</li><li>需设置includeLocation=false，打印位置信息会急剧降低异步日志的性能，比同步日志还要慢</li></ol></li></ul></li><li><p>log4j2无垃圾记录：<br>垃圾收集暂停是延迟峰值的常见原因。对于许多系统而言，需要花费大量精力来控制这些暂停<br>许多日志库(包括以前版本的Log4j)在稳态日志记录期间分配临时对象，如日志事件对象、字符串、字符数组、字节数组等。这会对垃圾收集器造成压力并增加GC暂停发生的频率<br>从版本2.6开始，默认情况下Log4j以”无垃圾”模式运行，重用对象和缓冲区，并且尽可能不分配临时对象。还有一个”低垃圾”模式，它不是完全无垃圾，但不使用ThreadLocal字段<br>Log4j版本2.6中的无垃圾日志记录部分通过重用ThreadLocal字段中的对象来实现，部分通过在将文本转换为字节时重用缓冲区来实现<br>有两个单独的系统属性可用于手动控制Log4j避免创建临时对象的机制：</p><ol><li><code>log4j2.enableThreadlocals</code>：true(非Web应用程序的默认值)，则对象存储在ThreadLocal字段中并重新使用，否则将为每个日志事件创建新对象</li><li><code>log4j2.enableDirectEncoders</code>：tru(默认)，则将日志事件转换为文本，此文本转换为字节而不创建临时对象。注意：由于共享缓冲区上的同步，在此模式下多线程应用程序的同步日志记录性能可能更差。如果应用程序是多线程的并且日志记录性能很重要，请考虑使用异步记录器</li></ol></li></ul></li></ol><h2 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h2><ul><li><p>背景：<br>当系统变得更加复杂时，日志就容易发生混乱。随着系统开发的进行，可能会更新不同的日志框架，这会造成当前系统中存在不同的日志依赖，难以统一地管理和控制。就算强制要求所有的模块使用相同的日志框架，系统中也难以避免使用其他类似Spring、MyBatis等其他的第三方框架，它们依赖于不同的日志框架，而且它们自身的日志系统有着不一致性，依然会导致日志体系的混乱<br>借鉴JDBC的思想，可为日志系统也提供一套门面，那么就可以面向这些接口规范来开发，免去直接依赖具体的日志实现框架</p></li><li><p>日志框架出现顺序：<br>log4j -&gt; JUL -&gt; JCL -&gt; slf4j -&gt; logback -&gt; log4j2</p></li><li><p>具体日志门面框架：</p><ol><li><p>JCL入门：</p><ul><li><p>介绍：JCL(Jakarta Commons Logging)是Apache提供的一个通用日志API。它为”所有的Java日志实现”提供一个统一的接口，它自身也提供一个简单日志的实现(SimpleLog,但功能非常常弱)。它允许使用不同的具体日志实现框架：Log4j、JDK自带的日志(JUL)以及SimpleLog。JCL有两个基本的抽象类：Log(基本记录器)和LogFactory(负责创建Log实例)</p></li><li><p>入门案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuick</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 获取log日志记录器对象</span></span><br><span class="line">  Log log = LogFactory.getLog(JCLTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="comment">// 日志记录输出</span></span><br><span class="line">  log.info(<span class="string">"Hello JCL"</span>);</span><br><span class="line">  log.fatal(<span class="string">"fatal"</span>);</span><br><span class="line">  log.error(<span class="string">"error"</span>);</span><br><span class="line">  log.warn(<span class="string">"warn"</span>);</span><br><span class="line">  log.info(<span class="string">"info"</span>);</span><br><span class="line">  log.debug(<span class="string">"debug"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JCL原理：</p><ol><li><p>通过LogFactory动态加载Log实现类</p></li><li><p>获取具体的日志实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] classesToDiscover = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">  <span class="string">"org.apache.commons.logging.impl.Log4JLogger"</span>, <span class="string">"org.apache.commons.logging.impl.Jdk14Logger"</span>, <span class="string">"org.apache.commons.logging.impl.Jdk13LumberjackLogger"</span>, <span class="string">"org.apache.commons.logging.impl.SimpleLog"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 默认加载第一个发现的日志实现框架</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classesToDiscover.length &amp;&amp; result == <span class="keyword">null</span>; ++i) &#123;</span><br><span class="line">  result = <span class="keyword">this</span>.createLogFromClass(classesToDiscover[i], logCategory, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>slf4j入门：</p><ul><li><p>介绍：<br>简单日志门面slf4j((Simple Logging Facade For Java))主要是为了给Java日志访问提供一套标准、规范的API框架。主要意义在于提供接口，具体的实现交由其他日志框架，如log4j2和logback等<br>slf4j自身也提供功能较为简单的实现，但基本不使用。slf4j是目前市面上最流行的日志门面。现在项目中基本上都使用slf4j作为日志门面，配上具体的实现框架(log4j2、logback等)，中间使用桥接器完成桥接<br>slf4j日志门面主要提供两大功能：日志框架的绑定和桥接<br>官方网站：<a href="https://www.slf4j.org/" target="_blank" rel="noopener">https://www.slf4j.org/</a></p></li><li><p>入门案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--slf4j core 使用slf4j必須添加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slf4j 自带的简单日志实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Slf4jTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 日志输出</span></span><br><span class="line">  LOGGER.error(<span class="string">"error"</span>);</span><br><span class="line">  LOGGER.warn(<span class="string">"warn"</span>);</span><br><span class="line">  LOGGER.info(<span class="string">"info"</span>);</span><br><span class="line">  LOGGER.debug(<span class="string">"debug"</span>);</span><br><span class="line">  LOGGER.trace(<span class="string">"trace"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用占位符输出日志信息</span></span><br><span class="line">  String name = <span class="string">"SOBXiong"</span>;</span><br><span class="line">  Integer age = <span class="number">23</span>;</span><br><span class="line">  LOGGER.info(<span class="string">"Name: &#123;&#125; , age: &#123;&#125;"</span>, name, age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常信息输出</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">"Error Occurs: "</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>slf4j的好处：</p><ol><li>使用slf4j框架，可在部署时迁移到所需的日志记录框架</li><li>slf4j提供了对所有流行的日志框架的绑定，例如log4j，JUL，Simple logging和NOP等。因此可在部署时切换到任何这些框架</li><li>无论使用哪种绑定，slf4j都支持参数化日志记录消息。由于slf4j将应用程序和日志记录框架分离，因此可以轻松编写独立于日志记录框架的应用程序，而无需担心用于编写应用程序的日志记录框架</li><li>slf4j提供了一个简单的Java工具，称为迁移器。使用此工具，可以迁移现有项目到slf4j</li></ol></li><li><p>绑定日志实现(Bind)：slf4j支持各种日志框架。slf4j发行版附带了几个称为”slf4j绑定”的jar包，每个绑定对应一个受支持的框架</p><ul><li><p>绑定流程：</p><ol><li>添加slf4j-api的依赖</li><li>使用slf4j的API在项目中进行统一的日志记录</li><li>绑定具体的日志实现框架<ol><li>绑定已经实现了slf4j的日志框架：直接添加对应依赖</li><li>绑定没有实现slf4j的日志框架：先添加日志的适配器，再添加实现类的依赖</li></ol></li><li>slf4j有且仅有一个日志实现框架的绑定(如果出现多个默认使用第一个依赖日志实现)</li></ol></li><li><p>常用的绑定日志实现pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- slf4j core,使用slf4j必须添加 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- logback默认支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jul --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jcl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>绑定原理：<br>要切换日志框架只需替换类路径上的slf4j绑定。例如从java.util.logging切换到log4j，只需将slf4j-jdk14.jar替换为slf4j-log4j12.jar即可<br>slf4j不依赖于任何特殊的类装载。实际上每个slf4j绑定在编译时都是硬连线以使用一个且只有一个特定的日志记录框架。以下是一般概念的图解说明：<br><img src="slf4j%E7%BB%91%E5%AE%9A%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="slf4j绑定示意图"></p></li></ul></li><li><p>桥接旧日志框架(Bridge)<br>通常，依赖的某些组件依赖于slf4j以外的日志记录API。假设这些组件在不久的将来不会切换到slf4j。为解决该情况，slf4j附带了几个桥接模块，这些模块将对log4j、JCL和java.util.logging的API调用重定向，就好像它们是对slf4j API操作一样<br>桥接解决的是项目中日志的遗留问题，当系统中存在之前的日志API，可通过桥接转换到slf4j的实现：</p><ol><li><p>先去除之前老的日志框架的依赖</p></li><li><p>添加slf4j提供的桥接组件</p></li><li><p>为项目添加slf4j的具体实现<br><img src="slf4j%E6%A1%A5%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="slf4j桥接示意图"><br>常用的桥接依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jul --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jcl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ol><li>jcl-over-slf4j.jar和slf4j-jcl.jar不能同时部署。前一个jar文件将导致JCL将日志系统的选择委托给slf4j，后一个jar文件将导致slf4j将日志系统的选择委托给JCL，从而导致无限循环(其余同理)</li><li>所有的桥接都只对Logger日志记录器对象有效，如果程序中调用了内部的配置类或者是Appender、Filter等对象，将无法产生效果</li></ol></li><li><p>slf4j原理：</p><ol><li>slf4j通过LoggerFactory加载日志具体的实现对象</li><li>LoggerFactory在初始化的过程中，通过performInitialization()方法绑定具体的日志实现</li><li>在绑定具体实现时通过类加载器加载org/slf4j/impl/StaticLoggerBinder.class</li><li>因此只要是一个日志实现框架，且在org.slf4j.impl包中提供一个自己的StaticLoggerBinder类，提供具体日志实现的LoggerFactory，就可以被slf4j加载</li></ol></li></ul></li></ol></li></ul><h2 id="SpringBoot中的日志"><a href="#SpringBoot中的日志" class="headerlink" title="SpringBoot中的日志"></a>SpringBoot中的日志</h2><ul><li><p>基本介绍：SpringBoot框架在企业中的使用越来越普遍，SpringBoot日志也是开发中常用的日志系统。SpringBoot默认采用slf4j作为日志门面，logback作为日志实现来记录日志</p></li><li><p>SpringBoot中的日志设计</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="依赖关系图"><br>总结：</p><ol><li>默认使用slf4j作为日志门面，logback作为日志实现</li><li>将jul和log4j转为slf4j</li></ol></li><li><p>SpringBoot中日志的使用：</p><ol><li><p>修改默认日志配置：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.itheima</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment"># 在控制台输出的日志的格式,同logback</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] [%-5level] %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">logs/springboot.log</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br></pre></td></tr></table></figure></li><li><p>指定配置：在类路径下添加每个日志框架的配置文件时，SpringBoot就不使用默认配置</p><table><thead><tr><th>日志框架</th><th>配置文件</th></tr></thead><tbody><tr><td>logback</td><td>logback-spring.xml,logback.xml(直接被日志框架识别)</td></tr><tr><td>log4j2</td><td>log4j2-spring.xml,log4j2.xml</td></tr><tr><td>JUL</td><td>logging.properties</td></tr></tbody></table></li><li><p>使用SpringBoot解析日志配置</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback-spring.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"prod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyyMMdd:HH:mm:ss.SSS&#125; [%thread] %-5level %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="meta">spring.profiles.active</span> = <span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>将日志切换为log4j2(log4j2 + slf4j是趋势)</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 排除logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加log4j2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/10/09/BasicSkill/DesignPattern/"/>
      <url>/2020/10/09/BasicSkill/DesignPattern/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#七大原则">七大原则</a></li><li><a href="#UML类图">UML类图</a></li><li><a href="#设计模式概述">设计模式概述</a></li><li><a href="#单例模式">单例模式</a></li><li><a href="#工厂模式">工厂模式</a></li><li><a href="#原型模式">原型模式</a></li><li><a href="#建造者模式">建造者模式</a></li><li><a href="#适配器模式(待完善)">适配器模式</a></li><li><a href="#桥接模式">桥接模式</a></li><li><a href="#装饰者模式">装饰者模式</a></li><li><a href="#组合模式">组合模式</a></li><li><a href="#外观模式">外观模式</a></li><li><a href="#享元模式">享元模式</a></li><li><a href="#代理模式">代理模式</a></li><li><a href="#模板方法模式">模板方法模式</a></li><li><a href="#命令模式">命令模式</a></li><li><a href="#访问者模式">访问者模式</a></li><li><a href="#迭代器模式">迭代器模式</a></li><li><a href="#观察者模式">观察者模式</a></li><li><a href="#中介者模式">中介者模式</a></li><li><a href="#备忘录模式">备忘录模式</a></li><li><a href="#解释器模式">解释器模式</a></li><li><a href="#状态模式">状态模式</a></li><li><a href="#策略模式">策略模式</a></li><li><a href="#职责链模式">职责链模式</a></li></ul><a id="more"></a><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><ul><li><p>设计模式目的：编写软件过程中，程序员面临着来自耦合性、内聚性、可维护性、可扩展性、重用性和灵活性等多方面的挑战，设计模式是为了让程序(软件)具有更好的</p><ol><li>代码重用性(相同功能的代码,不用多次编写)</li><li>可读性(编程规范性,便于其他程序员的阅读和理解)</li><li>可扩展性(当需要增加新的功能时非常的方便,也称为可维护性)</li><li>可靠性(当我们增加新的功能后对原来的功能没有影响)</li><li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li></ol></li><li><p>设计模式原则其实就是程序员在编程时应当遵守的原则，也是各种设计模式的基础</p></li><li><p>设计原则核心思想：</p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不和不需要变化的代码混在一起</li><li>面向接口编程，而不是面向实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ol></li><li><p>七大原则：</p><ol><li>单一职责原则：<strong>一个类和方法只做一件事，一个类应该也只有一个引起它修改的原因</strong></li><li>接口隔离原则：<strong>客户端不应依赖它不需要的接口</strong></li><li>依赖倒转(倒置)原则：<strong>细节依赖抽象，下层依赖上层</strong></li><li>里氏替换原则：<strong>子类应该可以完全替换父类。在使用继承时只扩展新功能而不破坏父类原有的功能</strong></li><li>开闭原则：<strong>一个软件实体如类、模块和函数应该对修改封闭，对扩展开放</strong></li><li>迪米特原则：<strong>最小知道原则，一个类不应知道自己操作的类的细节</strong></li><li>合成复用原则</li></ol></li><li><p>单一职责原则</p><ul><li><p>基本介绍：对类来说一个类应该只负责一项职责。如类A负责两个不同职责——职责1和2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1和A2</p></li><li><p>案例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始方案</span></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案1</span></span><br><span class="line"><span class="comment">// 1、遵守单一职责原则</span></span><br><span class="line"><span class="comment">// 2、但是这样做的改动很大,将类分解同时修改客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"公路运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"天空运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"水中运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">roadVehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案2</span></span><br><span class="line"><span class="comment">// 1、没有对原来的类做大的修改,只是增加方法</span></span><br><span class="line"><span class="comment">// 2、虽然没有在类这个级别上遵守单一职责原则,但在方法级别上仍然是遵守单一职责</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在天空上运行...."</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在水中行...."</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">vehicle.runAir(<span class="string">"飞机"</span>);</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节</p><ol><li>降低类的复杂度，一个类只负责一项职责(尽量)</li><li>提高类的可读性、可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则。只有逻辑足够简单时才可以在代码级违反单一职责原则；只有类中方法数量足够少时才可以在方法级别保持单一职责原则</li></ol></li></ul></li><li><p>接口隔离原则</p><ul><li><p>基本介绍：客户端不应该依赖它不需要的接口(<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>)</p></li><li><p>案例分析：<br><img src="%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D.png" alt="接口隔离案例介绍"></p><ul><li><p>改进措施：将接口Interface1拆分为独立的几个接口，类A和C分别与它们需要的接口建立依赖关系(也就是采用接口隔离原则)</p></li><li><p>改进结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">interface1</span>, <span class="title">interface2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">interface1</span>, <span class="title">interface3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>依赖倒转原则</p><ul><li><p>基本介绍：</p><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li><li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong></li><li>设计理念：相对于细节的多变，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中抽象指的是接口或抽象类，细节是具体的实现类</li><li><strong>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</strong></li></ol></li><li><p>案例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="comment">// 如果我们getInfo需要微信、短信等消息</span></span><br><span class="line"><span class="comment">// 则新增类同时Person类也要增加相应的接收方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123; System.out.println(email.getInfo());&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案：引入一个抽象的接口IReceiver表示接收者</span></span><br><span class="line"><span class="comment">// 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">// Email、WeiXin等属于接收者的范围,各自实现IReceiver接口,遵循了依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增接收者不需要对Person类进行改动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 改为对接口IReceiver的依赖</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123; System.out.println(receiver.getInfo());&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">person.receive(<span class="keyword">new</span> WeiXin());</span><br></pre></td></tr></table></figure></li><li><p>依赖关系传递的三种方式：</p><ol><li><p>接口依赖</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemote</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">closeTv</span><span class="params">(ITv tv)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> <span class="keyword">implements</span> <span class="title">IRemote</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeTv</span><span class="params">(ITv tv)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mate30Pro close tv~~~"</span>);</span><br><span class="line">    tv.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法传递</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITv tv;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mate30Pro</span><span class="params">(ITv tv)</span> </span>&#123; <span class="keyword">this</span>.tv = tv;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.tv.close();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>setter方式传递</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITv tv;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setTv</span><span class="params">(ITv tv)</span> </span>&#123; <span class="keyword">this</span>.tv = tv;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.tv.close();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注意事项和细节：</p><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li><li><strong>变量的声明类型尽量是抽象类或接口</strong>，这样变量引用和实际对象间存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol></li></ul></li><li><p>里氏替换原则</p><ul><li>OO(Object Oriented,面向对象)继承性的思考和说明：<ol><li>继承包含这一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约。虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</li><li>继承在给程序设计带来便利的同时，也带来了弊端。如使用继承会给程序带来侵入性、程序的可移植性降低、增加对象间的耦合性；如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及子类的功能都有可能产生错误</li><li>问题提出：在编程中，如何正确的使用继承?——遵循里氏替换原则</li></ol></li><li>基本介绍：<ol><li>里氏替换原则(Liskov Substitution Principle)在1988年由麻省理工学院的以为姓里的女士提出</li><li>如果每个类型为T1的对象o1都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<strong>换句话说，所有引用基类的地方必须都能透明地使用其子类的对象</strong></li><li>在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不重写父类的方法</strong></li><li>里氏替换原则告诉我们继承实际上让两个类耦合性增强了，在适当的情况下，可通过<strong>聚合、组合和依赖</strong>来解决问题</li></ol></li></ul></li><li><p>开闭原则</p><ul><li><p>基本介绍：</p><ol><li>开闭原则(Open Closed Principle)是编程中<strong>最基础、最重要</strong>的设计原则</li><li>一个软件实体如类、模块和函数应该<strong>对扩展开放(对提供方)，对修改关闭(对使用方)</strong>。用抽象构建框架，用实现扩展细节</li><li>当软件需要变化时，<strong>尽量通过扩展</strong>软件实体的行为来实现变化，<strong>而不是通过修改</strong>已有的代码来实现变化</li><li>编程中设计模式和其他原则的基础就是开闭原则</li></ol></li><li><p>案例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.type == <span class="number">1</span>) drawRectangle(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s.type == <span class="number">2</span>) drawCircle(s);</span><br><span class="line">    <span class="comment">// 新增三角形</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s.type == <span class="number">3</span>) drawTriangle(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Rectangle"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Circle"</span>);&#125;</span><br><span class="line">  <span class="comment">// 新增三角形</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Triangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; <span class="keyword">int</span> type;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Rectangle() &#123; <span class="keyword">super</span>.type = <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Circle() &#123; <span class="keyword">super</span>.type = <span class="number">2</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Triangle() &#123; <span class="keyword">super</span>.type = <span class="number">3</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123; s.draw();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Rectangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Circle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Triangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一样的调用方式</span></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>迪米特法则</p><ul><li>基本介绍：<ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则(Demeter Principle)又叫<strong>最少知识原则，即一个类对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多：依赖、关联、组合和聚合等。其中称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li></ol></li><li>注意事项和细节：<ol><li>迪米特法则的核心是降低类之间的耦合</li><li>注意：迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</li></ol></li></ul></li><li><p>合成复用原则(Composite Reuse Principle)：尽量使用合成/聚合的方式，而不是使用继承</p></li></ul><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><ul><li>UML基本介绍：<ol><li>UML——Unified modeling language(统一建模语言)是一种用于软件系统分析和设计的语言工具，用于帮助软件开发人员进行思考和记录思路的结果</li><li>UML本身是一套符号的规定，就像数学符号和化学符号一样。这些符号用于描述软件模型中的各个元素和它们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li></ol></li><li>UML图分类：<ol><li>用例图(use case)</li><li>静态结构图：类图(描述类与类之间的关系,是UML图中最核心的)、对象图、包图、组件图、部署图</li><li>动态行为图：交互图(时序图与协作图)、状态图、活动图</li></ol></li><li>UML类图基本介绍：<ol><li>用于描述系统中的<strong>类(对象)本身的组成和类(对象)之间的各种静态关系</strong></li><li>类之间的关系：<strong>依赖、泛化(继承)、实现、关联、聚合与组合</strong></li></ol></li><li>类之间的关系：<ol><li>依赖关系(Dependence)：<ul><li>基本介绍：<strong>只要是在类中用到了对方，那么他们之间就存在依赖关系</strong>。如果没有对方，连编绎都通过不了</li><li>具体体现：<ol><li>类的成员属性</li><li>类的成员方法的返回类型</li><li>类的成员方法接收的参数类型</li><li>类的成员方法中使用到</li><li>存在继承、实现等多态关系</li></ol></li></ul></li><li>泛化关系(Generalization)：<strong>泛化关系实际上就是继承关系</strong>，是依赖关系的特例</li><li>实现关系(Implementation)：<strong>实现关系实际上就是实现(接口)关系</strong>，是依赖关系的特例</li><li>关联关系(Association)：<ul><li>基本介绍：关联关系实际上就是<strong>类与类之间的联系</strong>，是依赖关系的特例(引用数)</li><li>性质：<ol><li>具有<strong>导航性</strong>：即双向或单向关系</li><li>具有多重性：如”1”(表示有且仅有一个)、”0…”(表示0个或者多个)、”0,1”(表示0个或1个),”n…m”(表示n到m个),”m…”(表示至少m个)</li></ol></li></ul></li><li>聚合关系(Aggregation)：<strong>表示的是整体和部分的关系，整体与部分可以分开</strong>。聚合关系是关联关系的特例，所以具有关联的导航性与多重性</li><li>组合关系(Composition)：也是整体与部分的关系，但是整体与部分不可以分开(逻辑或者代码层面上)</li></ol></li></ul><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><ul><li>基本介绍：<ol><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。设计模式不是代码，而是某类问题的通用解决方案，设计模式(Design pattern)代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验总结出来的</li><li>设计模式的本质：提高软件的维护性、通用性和扩展性，降低软件的复杂度</li><li>设计模式并不局限于某种语言，Java，PHP，C++都有设计模式</li></ol></li><li>类型：<ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</li><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)</li></ol></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>介绍：保证一个类只有一个实例，哪怕多线程同时访问，并提供一个全局访问此实例的方法</p></li><li><p>典型场景：</p><ol><li>数据库连接池</li><li>Spring中的单例Bean</li></ol></li><li><p>单例设计模式的八种实现方式</p><ol><li><p><strong>饿汉式(静态常量)</strong></p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、构造器私有化(防止外部new)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、类内创建对象(静态常量)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">// 3、向外暴露静态公共方法,返回单例instance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>优点：写法较简单，在类装载的时候就完成了实例化。避免了线程同步问题</li><li>缺点：在类装载时就完成了实例化，没有达到Lazy Loading(懒加载)的效果。如果从始至终未使用过这个实例，则会造成内存的浪费</li><li>该方式基于类加载机制避免了多线程的同步问题，instance在类装载时就实例化。虽然导致类装载的原因有很多种，在单例模式中大多数时候都是调用getInstance()方法。但不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化instance就没有达到Lazy Loading的效果</li><li>结论：该单例模式可用，但可能造成内存浪费(一般可忽略)</li></ol></li></ul></li><li><p><strong>饿汉式(静态代码块)</strong></p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、在静态代码块中,创建单例对象</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4、提供一个公有静态方法,返回实例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>该方式和方式一类似，过将类实例化的过程放在静态代码块中。在类装载时执行静态代码块中的代码，初始化类的实例。优缺点同方式一</li><li>结论：该单例模式可用，但可能造成内存浪费(一般可忽略)</li></ol></li></ul></li><li><p>懒汉式(线程不安全)</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>起到了Lazy Loading的效果，但只能在单线程下使用</li><li>在多线程下，当一个线程进入了if判断语句块，还未来得及往下执行；同时另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不使用这种方式</li></ol></li></ul></li><li><p>懒汉式(线程安全,同步方法)</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例(声明为同步方法,解决线程安全问题)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> Singleton();&#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>解决了线程安全问题</li><li>效率太低了，每个线程在想获得该类的实例时执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return即可。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol></li></ul></li><li><p>懒汉式(线程不安全,同步代码块)</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例(加入synchronized同步代码块,还存在线程安全问题)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>还存在线程安全问题(都进入到判断后,未开始同步,会实例化两次)</li><li>结论：在实际开发中，不使用这种方式</li></ol></li></ul></li><li><p><strong>双重检查(Double-Check)</strong></p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例(volatile声明,内存可见)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,设置双重检查,解决线程安全问题,同时解决懒加载问题,保证了效率,推荐使用</span></span><br><span class="line">  <span class="comment">// 几乎解决了线程安全问题</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> Singleton();&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>Double-Check概念是多线程开发中常使用到的。进行了两次if检查，这几乎可以保证线程安全</li><li>实例化代码只执行一次，再次访问时直接返回实例化对象。也避免反复进行方法同步</li><li>线程安全、延迟加载、效率较高</li><li>结论：在实际开发中推荐使用该方式</li></ol></li></ul></li><li><p>静态内部类</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态内部类,该类中有一个静态常量Singleton</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,直接返回静态内部类中的静态常量INSTANCE</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>该方式在Singleton类被装载时并不会立即实例化，而是在首次调用getInstance()方法时装载SingletonInstance类，从而完成Singleton的实例化</li><li>类的静态属性只会在第一次加载类的时候初始化，在这里JVM帮助我们保证了线程的安全性。在类进行初始化时其他线程是无法进入的</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li><li>结论：推荐使用</li></ol></li></ul></li><li><p>枚举</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、声明枚举类</span></span><br><span class="line"><span class="keyword">enum</span> Singletion&#123;</span><br><span class="line">  <span class="comment">// 2、声明一个实例</span></span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="comment">// 测试方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"ok~"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</li><li>在有继承的场景下不适用</li><li>结论：推荐使用(Effective Java作者推荐)</li></ol></li></ul></li></ol></li><li><p>源码中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime.class</span></span><br><span class="line"><span class="comment">// 采用饿汉式创建,因为其他地方需要用到,不会产生内存浪费</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currentRuntime;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单例模式注意事项和细节说明：</p><ol><li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源。对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，要使用相应的获取对象的方法(通常是getInstance())，而不是使用new创建</li><li>单例模式使用的场景：<strong>需要频繁地进行创建和销毁的对象</strong>、创建对象耗时过多或耗费资源过多(即<strong>重量级对象</strong>)但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session工厂</strong>等)</li></ol></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li><p>问题背景：在平时编程中，构建对象最常用的方式是new一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每new一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式</p></li><li><p>简单工厂模式</p><ul><li><p>基本介绍：让一个工厂类继承构建所有对象的职责(将构建工作封装到一个工厂类中)</p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是对传统方式做了一层简单的封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用处代码修改较小,大多只需在工厂类中修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果某个构造方式相当复杂,可以大大减少代码重复</span></span><br><span class="line">    <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"apple"</span>: <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"huawei"</span>: &#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Mate()</span><br><span class="line">        <span class="comment">// 具体设置工作...</span></span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No other brands now~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">PhoneFactory factory = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line"><span class="comment">// 直接new需要知道mate和iphone的具体构造细节</span></span><br><span class="line">Phone mate = factory.create(<span class="string">"huawei"</span>);</span><br><span class="line">Phone iphone = factory.create(<span class="string">"apple"</span>);</span><br><span class="line">mate.takePhoto();</span><br><span class="line">iphone.takePhoto();</span><br></pre></td></tr></table></figure></li><li><p>弊端：</p><ol><li>如果需生产的产品过多会导致工厂类过于庞大，承担过多的职责，变成超级类。每个产品生产过程的修改都需要修改工厂类(不止一个引起修改的原因)。违背了单一职责原则</li><li>当要生产新的产品时，必须在工厂类中添加新的判断分支。而开闭原则告诉我们：类应该对修改封闭。即添加新功能时最好只需增加新的类，而不是修改既有的类</li></ol></li></ul></li><li><p>工厂方式模式：</p><ul><li><p>由来：为了解决简单工厂的两处弊端</p></li><li><p>基本介绍：<strong>定义一个创建对象的抽象方法，由子类决定要实例化的类</strong>。工厂方法模式<strong>将对象的实例化推迟到子类</strong></p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、产品种类增加时不会变成超级工厂,工厂类会变多,保持灵活</span></span><br><span class="line"><span class="comment">2、改变只需改变对应工厂的方法</span></span><br><span class="line"><span class="comment">3、新增产品,无需修改已有的工厂,只需添加新工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 注意：factory接口必须声明慎重,更改接口需要更改所有的工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Mate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">PhoneFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">Phone iphone = appleFactory.create();</span><br><span class="line">PhoneFactory huaweiFactory = <span class="keyword">new</span> HuaweiFactory();</span><br><span class="line">Phone mate = huaweiFactory.create();</span><br><span class="line">iphone.takePhoto();</span><br><span class="line">mate.takePhoto();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽象工厂模式：</p><ul><li><p>基本介绍：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。简单来说工厂方法是创建出<strong>一种</strong>产品，抽象工厂则是创建<strong>一类</strong>产品</p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TerminalFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Pad <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Watch <span class="title">ceate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">TerminalFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pad <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPad();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Watch <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Watch();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>源码中的应用(简单工厂)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Calendar.getInstance();</span><br><span class="line"><span class="comment">// Calendar.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone, Locale aLocale)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">    String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">    <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结：</p><ol><li>工厂模式的意义：将实例化对象的代码提取出来放到一个类中统一管理和维护，达到解耦的目的，从而提高项目的扩展和维护性</li><li>设计模式的依赖抽象原则：<ol><li>创建对象实例时尽量不要直接new，而是封装到工厂的方法中</li><li>尽量不要让类继承具体类，而是继承抽象类或者是实现接口</li><li>尽量不要覆盖基类中已经实现的方法</li></ol></li></ol></li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><ul><li><p>传统方式</p><ul><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以买周董同款奶茶为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea jZhouMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">jZhouMilkTea.type = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">jZhouMilkTea.isCold = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假复制(和周董喝的是同一杯奶茶)</span></span><br><span class="line">MilkTea xiongMilkTea = jZhouMilkTea;</span><br><span class="line"><span class="comment">// 真复制</span></span><br><span class="line">MilkTea xiongMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">xiongMilkTea.type = jZhouMilkTea.type;</span><br><span class="line">xiongMilkTea.isCold = jZhouMilkTea.isCold;</span><br></pre></td></tr></table></figure></li><li><p>优缺点：</p><ol><li>优点：比较好理解，简单易操作</li><li>如果对象的属性较多或需要复制的数量较多，那么会造成大量的重复</li><li>如果对象改变，使用复制的代码也需进行较大的改动</li></ol></li></ul></li><li><p>原型模式</p><ul><li><p>基本介绍：</p><ol><li>原型模式(Prototype)指<strong>用原型实例指定创建对象的细节，通过拷贝原型创建新的对象</strong></li><li>原型模式是一种创建型设计模式，允许通过一个对象再创建另外一个可定制的对象而无需知道如何创建的细节</li><li>Java中原生支持——Object的clone()方法</li></ol></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java自带的clone()方法是浅拷贝,只有基本类型的属性会被拷贝,类类型几乎都是传递引用(String等除外)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCold;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MilkTea <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MilkTea) <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea jZhouMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">jZhouMilkTea.type = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">jZhouMilkTea.isCold = <span class="keyword">true</span>;</span><br><span class="line">MilkTea xiongMilkTea = jZhouMilkTea.clone();</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节：</p><ol><li>创建新的对象比较复杂时可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li></ol></li><li><p>源码中的应用：Java中的Object的clone()方法，采用C++ Cloneable接口，否则运行时出错</p></li></ul></li><li><p>浅拷贝和深拷贝：</p><ul><li><p>浅拷贝介绍：</p><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递(将该属性值复制一份给新的对象)</li><li>对于数据类型是引用数据类型的成员变量(某个数组、某个类的对象等)，那么浅拷贝会进行引用传递(实际也是值拷贝,引用值拷贝)，即只是将该成员变量的引用值(内存地址)复制一份给新的对象。因此实际上两个对象的该成员变量都指向同一个实例。在该情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>Java Object的clone()方法默认就是浅拷贝</li></ul></li><li><p>深拷贝介绍：</p><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，复制每个引用数据类型成员变量所引用的对象(该对象可达的所有对象)。即<strong>对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝</strong></li><li>在Java中可通过以下两种方式实现深拷贝：<ol><li>自定义类中实现cloneable接口重写clone()方法</li><li>通过对象序列化</li></ol></li></ul></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> Test test;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    obj = <span class="keyword">super</span>.clone();</span><br><span class="line">    DeepCloneObject deepObj = (DeepCloneObject) obj;</span><br><span class="line">    deepObj.test = (Test) test.clone();</span><br><span class="line">    <span class="keyword">return</span> deepObj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">try</span> (ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">         oos.write(<span class="keyword">this</span>);</span><br><span class="line">         ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">         ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis)) &#123;</span><br><span class="line">      <span class="comment">// 反序列化</span></span><br><span class="line">      DeepCloneObject deepObj = (DeepCloneObject) ois.readObject();</span><br><span class="line">      <span class="keyword">return</span> deepObj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul><li><p>基本介绍：</p><ul><li>建造者模式(Builder Pattern)是一种对象构建模式。<strong>将一个复杂的构建与其表示想分离，使同样的构建过程可以创建不同的表示</strong></li><li>传统的建造者模式采用”建造者-指挥者”方式</li><li>现在的建造者模式主要用来链式调用生成不同的配置</li></ul></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addIce;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MilkTea</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...getter/setter</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      milkTea.setName(<span class="string">"珍珠奶茶"</span>);</span><br><span class="line">      milkTea.setPrice(<span class="number">12.5</span>d);</span><br><span class="line">      milkTea.setAddIce(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      milkTea.setName(name);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">      milkTea.setPrice(price);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addIce</span><span class="params">(<span class="keyword">boolean</span> addIce)</span> </span>&#123;</span><br><span class="line">      milkTea.setAddIce(addIce);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MilkTea <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> milkTea;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea milkTea = <span class="keyword">new</span> MilkTea.Builder().setName(<span class="string">"波霸奶茶"</span>).addIce(<span class="keyword">true</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>源码中的应用：OkHttp、Retrofit等</p></li></ul><h2 id="适配器模式-待完善"><a href="#适配器模式-待完善" class="headerlink" title="适配器模式(待完善)"></a>适配器模式(待完善)</h2><ul><li>基本介绍：适配器模式(Adapter Pattern)是结构型模式，将某个类的接口转换成客户端期望的另一个接口表示，目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>具体介绍：<ul><li>类适配器模式：<ul><li>基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src到dst的适配</li><li>注意事项和细节：<ol><li>Java是单继承机制，类适配器需要继承src类。这就要求dst必须是接口，有一定局限性</li><li>src类的方法在Adapter中都会暴露出来，增加了使用的成本</li><li>由于继承了src类，可根据需求重写src类的方法，使得Adapter的灵活性增强</li></ol></li></ul></li><li>对象适配器模式：<ul><li>基本介绍：<ol><li>基本思路和类适配器模式相同，Adapter类不继承src类，而持有src类的实例以解决兼容性的问题——即持有src类对象，实现dst类接口，完成src到dst的适配</li><li>根据”合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系</li><li>对象适配器模式是适配器模式常用的一种</li></ol></li><li>注意事项和细节：<ol><li>对象适配器和类适配器算是同一种思想，只不过实现方式不同</li><li>根据合成复用原则，使用组合替代继承。解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口</li><li>使用成本更低，更灵活</li></ol></li></ul></li><li>接口适配器模式：<ol><li>一些书籍称为缺省适配器模式</li><li>核心思想：当无需实现接口提供的全部方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空实现)。则该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li><li>适用于一个接口不使用其所有的方法的情况</li></ol></li></ul></li><li>源码中的应用：通过jdbc访问SQLServer(jdbc-odbc)</li></ul><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li><p>基本介绍：</p><ol><li>桥接模式(Bridge Pattern)是一种结构型设计模式，指将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变</li><li>桥接模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而保持各部分的独立性以及应对他们的功能扩展</li></ol></li><li><p>传统模式：</p><ul><li><p>需求1：绘三种图案：矩形、圆形和三角形</p></li><li><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据OOP思想,三个具体实现类一个抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Rectangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Circle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Triangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需求2：在1的基础上添加颜色选择，每种颜色都需有四种不同颜色</p></li><li><p>解决方案：</p><ol><li><p>复用形状，将具体形状定义为父类，每种不同颜色的图形继承其形状父类，共12个类</p></li><li><p>复用颜色，将每种颜色定义为父类，每种不同颜色的图形继承其颜色父类，共12个类</p></li><li><p>采用桥接模式，<strong>将形状与颜色分离，根据需要对颜色和形状组合</strong>，不会产生类爆炸问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"red"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Yellow Blue Green...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectange</span> <span class="keyword">implements</span> <span class="title">Shape</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span></span>&#123; <span class="keyword">this</span>.color = color; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw "</span> + color.getColor() + <span class="string">"Triangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>注意事项和细节：</p><ol><li>实现了抽象和实现部分的分离，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统</li><li><strong>桥接模式替代多层继承方案，可以减少子类的个数</strong>，降低系统的管理和维护成本</li><li>桥接模式<strong>要求正确识别出系统中两个独立变化的维度(抽象、和实现)</strong>，其使用范围有一定的局限</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</li></ol></li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul><li><p>基本介绍：</p><ul><li>装饰者模式<strong>动态地将新功能附加到对象上</strong>。在对象功能扩展方面比继承更有弹性，体现了开闭原则(OCP)</li><li>主要作用：<ol><li>增强一个类原有的功能</li><li>为一个类添加新的功能</li></ol></li></ul></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">implements</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Milk~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceDecorator</span> <span class="keyword">implements</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condiment origin;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IceDecorator</span><span class="params">(Condiment condiment)</span></span>&#123; origin = condiment; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Add Ice~~~"</span>);</span><br><span class="line">    origin.getCondiment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condiment condiment = <span class="keyword">new</span> IceDecorator(<span class="keyword">new</span> Milk());</span><br><span class="line">Condiment.getCondiment();</span><br></pre></td></tr></table></figure></li><li><p>源码中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterInputStream.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ul><li><p>基本介绍：组合模式(Composite Pattern)又叫部分整体模式，属于结构型模式。用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象来表示部分以及整体层次</p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFile</span> <span class="keyword">extends</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"ConcreteFile name: "</span> + name + <span class="string">" , createTime: "</span> + createTime); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;File&gt; childFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(File file)</span></span>&#123; childFiles.add(file);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Folder name: "</span> + name + <span class="string">" , createTime: "</span> + createTime);</span><br><span class="line">    <span class="keyword">for</span> (File file : childFiles) &#123; file.printInfo(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节：</p><ol><li>能简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题</li><li>具有较强的扩展性，当要更改组合对象时只需要调整内部的层次关系，客户端不用做出任何改动</li><li>方便创建出复杂的层次结构。客户端不用理会组合里的组成细节，易添加节点从而创建出复杂的树形结构</li><li>需要<strong>遍历组织机构或处理的对象具有树形结构时</strong>，非常适合使用组合模式</li><li>要求较高的抽象性，如果<strong>非叶节点和叶节点有很多差异性</strong>的话，比如很多方法和属性都不一样，不适合使用组合模式</li></ol></li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ul><li>基本介绍：外观模式(Facade Pattern)又名门面模式。外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使得子系统更易使用<br><img src="%E5%9B%BE%E8%A7%A3%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt="图解外观模式"></li><li>注意事项和细节：<ol><li>外观模式对外屏蔽了子系统的细节，降低了客户端使用子系统的复杂性；使客户端与子系统解耦，子系统内部的模块更易维护和扩展</li><li>当系统需进行分层设计时可考虑使用Facade模式</li><li>维护一个遗留的大型系统时，可能该系统已变得非常难以维护和扩展。此时可考虑为新系统开发一个Facade类来提供遗留系统较清晰简单的接口，让新系统与Facade类交互，提高复用性</li><li>合理地使用外观模式可以更好地划分访问层次，不能过多或不合理地使用外观模式。使用外观模式好还是直接调用模块好取决于问题复杂度和实际情况。要以让系统有层次和利于维护为目的</li></ol></li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ul><li><p>基本介绍：</p><ol><li>通过运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，需要时可以直接使用，避免重新创建；如果没有线程再创建</li><li>能够解决对象重复创建销毁的资源耗费。当系统中有大量相似对象需要缓冲池时，不需总是创建新对象，而是从缓冲池里拿</li><li>经典的应用场景就是池技术——String常量池、数据库连接池、缓冲池等；享元模式是池技术的重要实现方式</li></ol></li><li><p>内部状态和外部状态</p><ol><li>享元模式提出了两个要求：细粒度和共享对象。这就涉及到内部状态和外部状态了，即将对象的信息分为两个部分——内部状态和外部状态</li><li><strong>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</strong></li><li><strong>外部状态指对象得以依赖的一个标记，是随环境改变而改变、不可共享的状态</strong></li></ol></li><li><p>源码中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试案例</span></span><br><span class="line"><span class="comment">// 第二次把127全替换为200</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">  Integer.valueOf(<span class="number">127</span>), <span class="keyword">new</span> Integer(<span class="number">127</span>),</span><br><span class="line">  Integer.valueOf(<span class="number">127</span>), <span class="keyword">new</span> Integer(<span class="number">127</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; integers.length; j++) &#123;</span><br><span class="line">    System.out.println(String.format(<span class="string">"i%d.equals(i%d)[%s], i%d == i%d[%s]"</span>,</span><br><span class="line">      i, j, integers[i].equals(integers[j]),</span><br><span class="line">      i, j, integers[i] == integers[j]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一次结果：</span></span><br><span class="line"><span class="comment">  i0.equals(i1)[true], i0 == i1[false]</span></span><br><span class="line"><span class="comment">  i0.equals(i2)[true], i0 == i2[true]</span></span><br><span class="line"><span class="comment">  i0.equals(i3)[true], i0 == i3[false]</span></span><br><span class="line"><span class="comment">  i1.equals(i2)[true], i1 == i2[false]</span></span><br><span class="line"><span class="comment">  i1.equals(i3)[true], i1 == i3[false]</span></span><br><span class="line"><span class="comment">  i2.equals(i3)[true], i2 == i3[false]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 如果i在[low, high]区间,在cache中获取,否则返回新创建的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">      <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 内部缓存,使用享元模式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最低-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// 最高127,但可以通过VM设置</span></span><br><span class="line">      <span class="comment">// high value may be configured by property</span></span><br><span class="line">      <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">      String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">      <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">          i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">          <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">          h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">          <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      high = h;</span><br><span class="line"></span><br><span class="line">      cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> j = low;</span><br><span class="line">      <span class="comment">// 在静态初始化时把[-128, 127]全加入缓存</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">      <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节</p><ol><li>“享”表示共享，”元”表示对象</li><li>系统中有大量对象且这些对象消耗大量内存并且对象的状态大部分可以外部化时，可考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。大多用HashMap/HashTable存储</li><li>大大减少了对象的创建开销，降低了程序内存的占用，提高效率</li><li>提高了系统的复杂度，需剥离出内部状态和外部状态。外部状态具有固化特性，不随内部状态的改变而改变。此为使用享元模式需要注意的地方</li><li>要注意划分内部状态和外部状态，并且通常需要一个工厂类加以控制</li></ol></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li><p>基本介绍：</p><ol><li>代理模式：为一个对象提供一个替身以控制对该对象的访问。通过代理对象访问目标对象的好处是——可在目标对象实现的基础上，增强额外的功能操作——即扩展目标对象的功能</li><li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li><li>代理模式有不同的形式，主要有三种：<strong>静态代理</strong>、<strong>JDK代理</strong>(又名接口代理,底层采用asm)和<strong>Cglib代理</strong>(可在内存动态地创建对象,无需实现接口,属于动态代理的范畴,底层采用asm)</li></ol></li><li><p>静态代理</p><ul><li><p>基本介绍：静态代理在使用时需要定义接口或父类，被代理对象(即目标对象)与代理对象一起实现相同的接口或是继承相同父类(形如装饰模式,但重在控制)</p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> <span class="keyword">implements</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITestDao</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITestDao target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestDaoProxy</span><span class="params">(ITestDao target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Enter TestDaoProxy test()~~~"</span>);</span><br><span class="line">    target.test();</span><br><span class="line">    System.out.println(<span class="string">"Leave TestDaoProxy test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ITestDao testDao = <span class="keyword">new</span> TestDao();</span><br><span class="line">TestDaoProxy testDaoProxy = <span class="keyword">new</span> TestDaoProxy(testDao);</span><br><span class="line">testDaoProxy.test();</span><br></pre></td></tr></table></figure></li><li><p>优缺点总结：</p><ol><li>优点：在不修改目标对象功能前提下能通过代理对象对目标功能进行扩展</li><li>缺点：因代理对象需要与目标对象实现一样的接口，因此会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护</li></ol></li></ul></li><li><p>JDK代理：</p><ul><li><p>基本介绍：</p><ol><li>代理对象不需要实现接口，但目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成是利用JDK的API，动态地在内存中构建代理对象</li></ol></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testWithParam</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> <span class="keyword">implements</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithParam</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao testWithParam("</span> + value + <span class="string">")~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 维护一个目标对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ClassLoader loader：指定当前目标对象使用的类加载,获取加载器的方法是固定的</span></span><br><span class="line">    <span class="comment">// Class&lt;?&gt;[] interfaces：目标对象实现的接口类型,使用泛型方式确定类型</span></span><br><span class="line">    <span class="comment">// InvocationHandler h：事件处理,执行目标对象方法时会触发事件处理器方法,会把当前目标对象方法作为参数传入</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">      target.getClass().getClassLoader(),</span><br><span class="line">      target.getClass().getInterfaces(),</span><br><span class="line">      (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Jdk Proxy start~~~"</span>);</span><br><span class="line">        <span class="comment">// 反射机制调用目标对象方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"Jdk Proxy end~~~"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给目标对象创建代理对象</span></span><br><span class="line">ITestDao proxyInstance = (ITestDao)<span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> TestDao()).getProxyInstance();</span><br><span class="line">proxyInstance.test();</span><br><span class="line">System.out.println(proxyInstance.testWithParam(<span class="string">"Hello Proxy"</span>));</span><br><span class="line">System.out.println(proxyInstance);</span><br><span class="line">System.out.println(proxyInstance.getClass());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Cglib代理</p><ul><li><p>基本介绍：</p><ol><li>静态代理和JDK代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个<strong>单独的对象且并没有实现任何的接口</strong>，这时候可使用目标对象子类来实现代理——Cglib代理</li><li>Cglib代理也叫作<strong>子类代理</strong>，它在内存中构建一个子类对象从而实现对目标对象功能的扩展，一些资料也将Cglib代理归属到动态代理</li><li>Cglib是一个强大的高性能的代码生成包，它可在运行期扩展java类与实现java接口。它广泛地被许多AOP框架使用，如Spring AOP，用于实现方法拦截</li><li>在AOP编程中如何选择代理模式：<ol><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ol></li><li>Cglib包的底层是<strong>通过使用字节码处理框架ASM来转换字节码并生成新的类</strong></li></ol></li><li><p>注意事项：</p><ol><li>需要引入cglib的jar文件(Spring中集成了Cglib的使用)</li><li>注意代理的类不能为final，否则报错——java.lang.IllegalArgumentException</li><li>目标对象的方法如果为final/static方法，那么就不会被拦截——即不会执行目标对象额外的业务方法</li></ol></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"TestDao test()~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 维护一个目标对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建一个工具类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 2、设置父类</span></span><br><span class="line">    enhancer.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 3、设置回调函数</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 4、创建子类对象即代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写intercept方法,会调用目标对象的方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Cglib Proxy start~~~"</span>);</span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">"Cglib Proxy end~~~"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestDao proxyInstance = (TestDao) <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> TestDao()).getProxyInstance();</span><br><span class="line">proxyInstance.test();</span><br><span class="line">System.out.println(proxyInstance);</span><br><span class="line">System.out.println(proxyInstance.getClass());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>几种常见的代理模式(常见变体)</p><ol><li>缓存代理：如当请求图片文件等资源时，先到缓存代理取，如果取不到资源再到公网或者数据库取，然后缓存</li><li>远程代理：通过远程对象的本地代表可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li><li>同步代理：主要使用在多线程编程中完成多线程间同步工作</li></ol></li></ul><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul><li>基本介绍：<ol><li>模板方法模式(Template Method Pattern)又叫模板模式，属于行为型模式。在一个抽象类公开定义执行方法的模板。子类可按需重写方法实现，但调用将以抽象类中定义的方式进行</li><li>模板方法模式定义一个操作中算法的骨架，而将一些步骤延迟到子类，这使得子类可以不改变一个算法的结构就可以重定义算法的某些特定步骤</li></ol></li><li>注意事项和细节：<ol><li>基本思想：算法只存在于一个地方也就是在父类中，容易修改。需要修改算法时只需修改父类的模板方法或已经实现的某些步骤，子类就会继承这些修改</li><li>实现了代码复用的最大化。父类的模板方法和已实现的某些步骤会被子类继承直接使用</li><li>既统一了算法也提供了很大的灵活性。父类的模板方法确保算法结构保持不变，同时由子类提供部分步骤的实现</li><li>模式的不足之处：每一个不同的实现都需要一个子类实现，这会导致类的个数增加，使得系统更加庞大</li><li>不希望子类覆写的方法(模版方法)用final修饰；要求子类必须覆写的方法用abstract修饰</li><li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤且这一系列的步骤基本相同，但其个别步骤在实现时可能不同。这种情况下通常考虑用模板方法模式来处理</li></ol></li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li><p>基本介绍：命令模式(Command Pattern)将一个请求封装为一个对象，可参数化请求对象，支持对请求排队、记录和撤销的操作</p></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOpenCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Light light;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightOpenCommand</span><span class="params">(Light light)</span> </span>&#123; <span class="keyword">this</span>.light = light;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn on~~~"</span>);</span><br><span class="line">    light.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn off~~~"</span>);</span><br><span class="line">    light.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightCloseCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Light light;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightCloseCommand</span><span class="params">(Light light)</span> </span>&#123; <span class="keyword">this</span>.light = light; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn off~~~"</span>);</span><br><span class="line">    light.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn on~~~"</span>);</span><br><span class="line">    light.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelevisionOpenCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Television television;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TelevisionOpenCommand</span><span class="params">(Television television)</span> </span>&#123; <span class="keyword">this</span>.television = television; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn on~~~"</span>);</span><br><span class="line">    television.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn off~~~"</span>);</span><br><span class="line">    television.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelevisionCloseCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Television television;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TelevisionCloseCommand</span><span class="params">(Television television)</span> </span>&#123; <span class="keyword">this</span>.television = television; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn off~~~"</span>);</span><br><span class="line">    television.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn on~~~"</span>);</span><br><span class="line">    television.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  List&lt;ICommand&gt; iCommands;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MicroCommand</span><span class="params">(List&lt;ICommand&gt; iCommands)</span> </span>&#123; <span class="keyword">this</span>.iCommands = iCommands;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MicroCommand execute~~~"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ICommand iCommand : iCommands) &#123; iCommand.execute(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MicroCommand undo~~~"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ICommand iCommand : iCommands) &#123; iCommand.undo(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light light = <span class="keyword">new</span> Light();</span><br><span class="line">ICommand lightOpenCommand = <span class="keyword">new</span> LightOpenCommand(light);</span><br><span class="line">ICommand lightCloseCommand = <span class="keyword">new</span> LightCloseCommand(light);</span><br><span class="line"></span><br><span class="line">Television television = <span class="keyword">new</span> Television();</span><br><span class="line">ICommand televisionOpenCommand = <span class="keyword">new</span> TelevisionOpenCommand(television);</span><br><span class="line">ICommand televisionCloseCommand = <span class="keyword">new</span> TelevisionCloseCommand(television);</span><br><span class="line"></span><br><span class="line">ICommand microCommand = <span class="keyword">new</span> MicroCommand(Arrays.asList(lightCloseCommand, lightOpenCommand, televisionOpenCommand, televisionCloseCommand));</span><br><span class="line"></span><br><span class="line">lightOpenCommand.execute();</span><br><span class="line">lightOpenCommand.undo();</span><br><span class="line">lightCloseCommand.execute();</span><br><span class="line">lightCloseCommand.undo();</span><br><span class="line"></span><br><span class="line">televisionOpenCommand.execute();</span><br><span class="line">televisionOpenCommand.undo();</span><br><span class="line">televisionCloseCommand.execute();</span><br><span class="line">televisionCloseCommand.undo();</span><br><span class="line"></span><br><span class="line">microCommand.execute();</span><br><span class="line">microCommand.undo();</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节：</p><ol><li>容易设计一个命令队列。只要把命令对象放到列队就可以多线程地执行命令</li><li>容易实现请求的撤销和重做</li><li>可能导致某些系统有过多的具体命令类，增加了系统的复杂度</li><li><strong>空命令也是一种设计模式，它省去了判空的操作</strong></li><li>经典应用场景：界面的一个按钮都是一条命令、模拟CMD(DOS命令)、订单的撤销/恢复、触发-反馈机制</li></ol></li></ul><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><ul><li><p>基本介绍：</p><ol><li><strong>访问者模式(Visitor Pattern)封装一些作用于某种数据结构各元素的操作，使得可在不改变数据结构的前提下定义作用于这些元素的新操作</strong></li><li>核心思想：<strong>将数据结构与数据操作分离</strong>，解决数据结构和操作耦合性问题</li><li>基本工作原理：在被访问的类中加一个对外提供访问的接口(accept)</li><li>主要应用场景：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需避免这些操作”污染”这些对象的类</li></ol></li><li><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chip</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Visitor visitor)</span></span>&#123; visitor.accept(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMD</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Design"</span>);</span><br><span class="line">    chip.setValue(<span class="number">4000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSMC</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Original Entrusted Manufacture"</span>);</span><br><span class="line">    chip.setValue(<span class="number">4500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TMALL</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Sell"</span>);</span><br><span class="line">    chip.setValue(<span class="number">5500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Chip chip = <span class="keyword">new</span> Chip();</span><br><span class="line">List&lt;Visitor&gt; capitalists = Arrays.asList(<span class="keyword">new</span> AMD(), <span class="keyword">new</span> TSMC(), <span class="keyword">new</span> TMALL());</span><br><span class="line"><span class="keyword">for</span> (Visitor capitalist : capitalists) &#123;</span><br><span class="line">  chip.visit(capitalist);</span><br><span class="line">  logger.info(<span class="string">"Visit By &#123;&#125; , Chip -&gt; &#123;&#125; , &#123;&#125;"</span>, capitalist.getClass().getSimpleName(), chip.getName(), chip.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项和细节：</p><ul><li>优点：<ol><li>符合单一职责原则、使程序具有优秀的扩展性、灵活性非常高</li><li>可对功能进行统一，可应用于报表、UI、拦截器与过滤器等场景，适用于数据结构相对稳定的系统</li></ol></li><li>缺点<ol><li>具体元素对访问者公布细节，即访问者关注了其他类的内部细节，违背了迪米特法则且具体元素变更比较困难</li><li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li></ol></li><li>总结：如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就比较合适</li></ul></li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ul><li>基本介绍：迭代器模式(Iterator Pattern)属于行为型模式，它<strong>提供一种方法访问一个容器对象中各个元素，而又无需暴露该对象的内部细节</strong></li><li>源码中的应用：JDK(Collection.class, Iterator.class)</li><li>注意事项和细节：<ul><li>优点<ol><li>提供一个统一的方法遍历对象</li><li>隐藏了对象内部细节</li><li>隐藏了一种设计思想：一个类应只有一个引起变化的原因(单一责任原则)。剥离迭代器，<strong>把管理对象集合和遍历对象集合的责任分开</strong></li><li>当要展示一组相似对象或遍历一组相同对象时，适合使用迭代器模式</li></ol></li><li>缺点：当遍历细节不同时，会生成多个具体迭代器类</li></ul></li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li>基本介绍：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li><li>源码中的应用：JDK中的Observable和Observer类</li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><ul><li>基本介绍：中介者模式(Mediator Pattern)属于行为型模式，<strong>定义一个中介对象来封装一系列对象之间的交互</strong>。使原来有对象的耦合松散，且可以独立地改变它们之间的交互</li><li>注意事项和细节：<ol><li>多个类相互耦合会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦</li><li>减少类间依赖，降低了耦合，符合迪米特原则</li><li>中介者承担了较多的责任，需要处理所有类之间的协调工作，一旦中介者出现了问题，整个系统就会受到影响</li><li>如果设计不当，中介者对象本身会变得过于复杂</li></ol></li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ul><li>基本介绍：备忘录模式(Memento Pattern)属于行为型模式，在<strong>不破坏封装性的条件下，通过备忘录对象存储另一个对象内部状态的快照，在将来合适时把这个对象还原到存储时的状态</strong></li><li>注意事项和细节：<ol><li>为用户提供了一种可以恢复状态的机制，可使用户能比较方便地回到某个历史的状态</li><li>实现了信息的封装，使得用户无需关心状态的保存细节</li><li>消耗资源：如果类的成员变量过多，势必会占用比较大的资源，且每一次保存都会消耗一定的内存</li><li>适用的应用场景：<ol><li>打游戏时的存档</li><li>Windows里的Ctrl + z</li><li>浏览器中的后退</li><li>数据库的事务管理</li></ol></li></ol></li></ul><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ul><li>基本介绍：<ol><li>在编译原理中，一个表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里词法分析器和语法分析器都可以看做是解释器</li><li>解释器模式(Interpreter Pattern)：<strong>给定一门语言(表达式)，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子(表达式)</strong></li><li>将不可拆分的最小单元称之为终结表达式，可被拆分的表达式称之为非终结表达式</li></ol></li><li>注意事项和细节：<ol><li>应用场景：编译器、运算表达式计算、正则表达式、机器人等</li><li>可能带来的问题：解释器模式会引起类膨胀；解释器模式通常采用递归，这将会导致调试复杂、运行效率降低</li></ol></li></ul><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ul><li>基本介绍：<ol><li>状态模式(State Pattern)主要用来解决对象在多种状态转换时需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</li><li>当一个<strong>对象的内在状态改变时允许改变其行为</strong>，这个对象看起来像是改变了其类</li></ol></li><li>注意事项和细节：<ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li><li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li><li>符合”开闭原则”，容易增删状态</li><li>会产生很多类。每个状态都需要一个对应的类，当状态过多时会产生很多类，加大维护难度</li><li>应用场景：当一个事件或者对象有多种状态，状态之间会相互转换，对不同的状态要求有不同的行为时可考虑状态模式</li></ol></li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul><li>基本介绍：定义了一系列算法，并将每一个算法封装起来，且使它们可以相互替换。策略模式让算法独立于使用它的客户而独立变化。简单来说，即<strong>殊途同归</strong>——当我们做同一件事有多种方式时可将每种方法封装起来，在不同的场景选择不同的策略，调用不同的方法</li><li>源码中的应用：图片加载框架(Glide,picaso等)缓存策略</li><li>注意事项和细节：<ol><li>关键是分析项目中变化部分与不变部分</li><li>注意多用组合/聚合、少用继承</li><li>体现了OCP原则，客户端增加行为不用修改原有代码，只要添加一种策略(或者行为)即可，避免使用多重if-else</li><li>每添加一个策略就要增加一个类，当策略过多时会导致类数目庞大</li><li>更好的实践：与工厂模式结合，将不同的策略对象封装到工厂类中，只需传递不同的策略类型从工厂中获取对应的策略对象</li></ol></li></ul><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><ul><li>基本介绍：<ol><li>职责链模式(Chain of Responsibility Pattern)又叫责任链模式，属于行为型模式。它为请求创建了一个处理者对象的链，对请求的发送者和接收者进行解耦</li><li>通常每个处理者都包含对另一个处理者的引用。如果一个处理者不能处理该请求，那么它会把该请求传给下一个处理者，依此类推</li></ol></li><li>源码中的应用：javax包下的FilterChain、SpringMVC包装的FilterChain</li><li>注意事项和细节：<ol><li>将请求和处理分开，实现解耦，提高系统的灵活性</li><li>责任分担，每个处理者只处理自身该处理的任务，其余交由下一个处理者完成或提前返回</li><li>性能会受到影响，特别是在链比较长的时候。因此需控制链中最大节点数量</li><li>采用了类似递归的方式，调试不方便</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2020/10/09/BasicSkill/Docker/"/>
      <url>/2020/10/09/BasicSkill/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#Docker简介">Docker简介</a></li><li><a href="#Docker安装">Docker安装</a></li><li><a href="#Docker常用命令">Docker常用命令</a></li><li><a href="#Docker镜像">Docker镜像</a></li><li><a href="#Docker容器数据卷">Docker容器数据卷</a></li><li><a href="#Dockerfile">Dockerfile</a></li><li><a href="#Docker安装步骤">Docker安装步骤</a></li><li><a href="#Docker镜像发布">Docker镜像发布</a></li></ul><a id="more"></a><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul><li>Docker是什么：<ul><li>Docker出现背景：<ol><li>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。开发/运维之间的协作需要我们关心很多东西，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</li><li>Docker之所以发展如此迅速，就是因为它对此给出了一个标准化的解决方案</li><li>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。能不能从根本上解决问题，<strong>软件可以带环境安装？</strong>也就是说，安装的时候，把原始环境一模一样地复制过来。利用Docker可以消除协作编码时”在我的机器上可正常工作”的问题</li><li>之前在服务器配置一个应用的运行环境，要安装各种软件，有时还不能跨平台，移植应用也非常麻烦</li><li>传统上认为，软件编码开发和测试环节结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等。为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件。开发需要清楚地告诉运维部署团队用的全部配置文件和所有软件环境，即便如此仍然会发生部署失败的状况。<strong>Docker镜像的设计打破过去”程序即应用”的观念。透过镜像(images)将作业系统核心除外地运行应用程序所需要的系统环境，由下而上打包，达到应用程序跨平台间的无缝接轨运行</strong></li></ol></li><li>Docker理念：<ol><li>Docker是基于Go语言实现的云开源项目</li><li>Docker的主要目标是”Build, Ship and Run Any App, Anywhere”。即通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP(可以是一个WEB应用或数据库应用等)及其运行环境能够做到”<strong>一次封装，到处运行</strong>“<br> <img src="Docker%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87.png" alt="Docker主要目标"></li><li>Linux容器技术的出现就解决了这样一个问题，而Docker就是在它的基础上发展过来的。将应用运行在Docker容器上面，Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></li></ol></li><li>总结：解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术</li></ul></li><li>Docker与传统虚拟机技术<ul><li>虚拟机技术：<ul><li>虚拟机(virtual machine)是带环境安装的一种解决方案。</li><li>可以在一种操作系统里面运行另一种操作系统(Windows系统里面运行Linux系统)，应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样。而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美地运行了另一套系统，能够使应用程序、操作系统和硬件三者之间的逻辑不变<br><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚拟机架构示意图"></li><li>虚拟机的缺点：<ol><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ol></li></ul></li><li>容器虚拟化技术：<ul><li>由于前面虚拟机存在这些缺点，Linux发展出了另一种虚拟化技术——Linux容器(Linux Containers,缩写为LXC)</li><li>Linux容器并不模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行<br><img src="Docker%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker架构示意图"></li><li>Docker和传统虚拟化方式的不同之处：<ol><li>传统虚拟机技术是虚拟出一套硬件后在其上运行一个完整操作系统，再在该系统上再运行所需的应用进程</li><li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</li><li>每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源</li></ol></li></ul></li></ul></li><li>Docker能干嘛：<ul><li>开发/运维(DevOps,一次构建、随处运行)：<ol><li>一次构建、随处运行：传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间</li><li>更便捷的升级和扩缩容：随着微服务架构和Docker的发展，大量的应用会通过微服务方式构建。应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块”积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级</li><li>更简单的系统运维：应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复</li><li>更高效的计算资源利用：Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率</li></ol></li></ul></li><li>Docker去哪下：<ul><li>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></li><li>镜像仓库：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></li></ul></li></ul><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ul><li><p>前提：Docker只能运行在CentOS-6.5或更高的版本的CentOS上，要求系统为64位、系统内核版本为2.6.32-431或者更高版本(以CentOS为例)</p></li><li><p>Docker的基本组成：</p><ol><li>镜像(image)：Docker镜像就是一个<strong>只读</strong>的模板。镜像可以用来创建容器，<strong>一个镜像可以创建多个容器</strong></li><li>容器(container)：<ul><li>Docker利用容器独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例</strong></li><li>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<strong>可以把容器看做是一个简易版的Linux环境</strong>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序</li><li>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的</li></ul></li><li>仓库(repository)：<ul><li><strong>仓库是集中存放镜像文件的场所</strong></li><li>仓库(Repository)和仓库注册服务器(Registry)是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)</li><li>仓库分为公开仓库(Public)和私有仓库(Private)两种形式</li><li>最大的公开仓库是Docker Hub，里面存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</li></ul></li><li>总结：<ul><li>区分并理解仓储/镜像/容器这些概念</li><li>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件可以生成多个同时运行的容器实例</li><li>image文件生成的容器实例本身也是一个文件，称为镜像文件</li><li>一个容器运行一种服务，当我们需要的时候就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li><li>仓储是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以<br><img src="Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Docker架构图"></li></ul></li></ol></li><li><p>安装步骤(CentOS7)</p><ul><li><p>参考网址：<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p></li><li><p>具体步骤：</p><ol><li><p>卸载老版本依赖</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">  docker-client \</span><br><span class="line">  docker-client-latest \</span><br><span class="line">  docker-common \</span><br><span class="line">  docker-latest \</span><br><span class="line">  docker-latest-logrotate \</span><br><span class="line">  docker-logrotate \</span><br><span class="line">  docker-engine</span><br></pre></td></tr></table></figure></li><li><p>设置yum仓库(repository)</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">  --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>下载最新版本Docker(ce版本——免费,ee版本——商业收费)</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动Docker服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置docker服务开机自启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><p>卸载Docker：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭docker服务</span></span><br><span class="line">sudo systemctl stop docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除docker包和依赖</span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除docker lib</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试docker：docker version</p></li><li><p>配置docker阿里云镜像加速：控制台 -&gt; 容器镜像服务 -&gt; 镜像加速器 -&gt; 查看操作文档</p></li><li><p>永远的hello world：</p><ul><li>运行：docker run hello-world</li><li>run hello-world的流程：<br><img src="hello-world%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="hello-world运行流程"></li></ul></li></ul></li><li><p>底层原理</p><ul><li>Docker是怎么工作的：Docker是一个CS结构的系统，Docker守护进程运行在主机上，通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器是一个运行时环境，就是”🐳背上的集装箱”<br><img src="Docker%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker工作示意图"></li><li>为什么Docker比虚拟机(VM)快：<ol><li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker会在效率上有明显优势</li><li>docker利用的是宿主机的内核，而不需要Guest OS。因此当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。从而避免引寻、加载操作系统内核等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，整个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统、省略了新建过程，新建一个docker容器只需要几秒钟</li></ol></li></ul></li></ul><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><ul><li><p>帮助命令：</p><ol><li>docker version</li><li>docker info</li><li>docker –help</li></ol></li><li><p>镜像命令：</p><ol><li>docker images [Options]<ul><li>介绍：列出本地主机上的镜像</li><li>显示参数介绍：<ol><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小<br>同一仓库源可以有多个TAG，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像<br>如果不指定一个镜像的版本标签，docker将默认使用centos:latest镜像(系统为CentOS)</li></ol></li><li>常用Options说明：<ol><li>-a：列出本地所有的镜像(含中间映像层)</li><li>-q：只显示镜像id</li><li>–digests：显示镜像的摘要信息</li><li>–no-trunc：显示完整的镜像信息</li></ol></li></ul></li><li>docker search [Options] 镜像名<ul><li>默认搜索源：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li><li>常用Options说明：<ol><li>–no-trunc：显示完整的镜像描述</li><li>-s：列出收藏数不小于指定值的镜像</li><li>–automated：只列出automated build类型的镜像</li></ol></li></ul></li><li>docker pull 镜像名[:标签]：下载指定镜像</li><li>docker rmi：删除镜像<ul><li>删除单个：docker rmi -f 镜像id/镜像名[:标签]</li><li>删除多个：docker rmi -f 镜像名1[:标签] 镜像名2[:标签]</li><li>删除全部：docker rmi -f $(docker images -qa)</li></ul></li></ol></li><li><p>容器命令：</p><ol><li><p>新建并启动容器(有镜像才能创建容器)：docker run [Options] image [Command] [args…]</p><ul><li><p>常用Options说明：</p><ol><li>--name dockerName：为容器指定一个名称</li><li>-d：后台运行容器，并返回容器ID(也即启动守护式容器)</li><li><strong>-i：以交互模式运行容器，通常与-t同时使用</strong></li><li><strong>-t：为容器重新分配一个伪输入终端，通常与-i同时使用</strong></li><li>-P: 随机端口映射</li><li>-p: 指定端口映射，有以下四种格式:<ol><li>ip:hostPort:containerPort</li><li>ip::containerPort</li><li><strong>hostPort:containerPort</strong></li><li>containerPort</li></ol></li></ol></li><li><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</span></span><br><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>操作：docker run -d centos</li><li>现象：然后使用docker ps -a进行查看运行的容器，会发现容器已经退出</li><li>原因：Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令(比如运行top、tail)，就会自动退出。这是docker的机制问题，比如web容器。以nginx为例，正常情况下，我们配置启动服务只需要启动响应service即可，例如service nginx start。但是这样做，nginx以后台进程模式运行，就导致docker前台没有运行的应用。这样的容器后台启动后，会立即自杀。因为它觉得无事可做。因此最佳的解决方案是将你要运行的程序以前台进程的形式运行</li></ul></li></ul></li><li><p>列出当前所有正在运行的容器：docker ps [OPTIONS]<br> 常用Options说明：</p><ol><li>-a：列出当前所有<strong>正在运行、历史上运行过</strong>的容器</li><li>-l：显示最近创建的容器</li><li>-n：显示最近n个创建的容器</li><li><strong>-q：静默模式，只显示容器编号</strong></li><li>–no-trunc：不截断输出</li></ol></li><li><p>退出容器(两种方式)</p><ol><li>容器停止退出：exit</li><li>容器不停止退出：ctrl+P+Q</li></ol></li><li><p>启动容器：docker start 容器id/容器名</p></li><li><p>停止容器：docker stop 容器id/容器名</p></li><li><p>强制停止容器：docker kill 容器id/容器名</p></li><li><p>删除已停止的容器：</p><ol><li>删除单个容器：docker rm 容器id</li><li>一次性删除多个容器(-f——force强制,关闭已启动的)：<ol><li>docker rm -f 容器id1 容器id2 …</li><li>docker rm -f $(docker ps -a -q)</li><li>docker ps -a -q | xargs docker rm</li></ol></li></ol></li><li><p>查看容器日志：docker logs -f -t –tail 条数 容器id<br> 参数说明：</p><ol><li>-t：加入时间戳</li><li>-f：跟随最新的日志打印</li><li>–tail num：显示最后多少条</li></ol></li><li><p>查看容器内运行的进程：docker top 容器id</p></li><li><p>查看容器内部细节(资源、配置)：docker inspect 容器id</p></li><li><p>进入正在运行的容器并以命令行交互：</p><ul><li>两种方式：<ol><li>docker exec -it 容器id /bin/bash</li><li>docker attach 容器id</li></ol></li><li>两种方式区别：<ol><li>attach：直接进入容器启动命令的终端，不会启动新的进程</li><li>exec：是在容器中打开新的终端，并且可以启动新的进程</li></ol></li></ul></li><li><p>从容器内拷贝文件到主机上：docker cp 容器id:容器文件路径 主机文件路径</p></li><li><p>命令一览：<br><img src="Docker%E5%91%BD%E4%BB%A4%E7%AE%80%E5%9B%BE.png" alt="Docker命令简图"></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>attach</td><td>Attach to a running container(当前shell下attach连接指定运行镜像)</td></tr><tr><td>build</td><td>Build an image from a Dockerfile(通过Dockerfile定制镜像)</td></tr><tr><td>commit</td><td>Create a new image from a container changes(提交当前容器为新的镜像)</td></tr><tr><td>cp</td><td>Copy files/folders from the containers filesystem to the host path(从容器中拷贝指定文件或者目录到宿主机中)</td></tr><tr><td>create</td><td>Create a new container(创建一个新的容器,同run,但不启动容器)</td></tr><tr><td>diff</td><td>Inspect changes on a container’s filesystem(查看docker容器变化)</td></tr><tr><td>events</td><td>Get real time events from the server(从docker服务获取容器实时事件)</td></tr><tr><td>exec</td><td>Run a command in an existing container(在已存在的容器上运行命令)</td></tr><tr><td>export</td><td>Stream the contents of a container as a tar archive(导出容器的内容流作为一个tar归档文件,对应import)</td></tr><tr><td>history</td><td>Show the history of an image(展示一个镜像形成历史)</td></tr><tr><td>images</td><td>List images(列出系统当前镜像)</td></tr><tr><td>import</td><td>Create a new filesystem image from the contents of a tarball(从tar包中的内容创建一个新的文件系统映像,对应export)</td></tr><tr><td>info</td><td>Display system-wide information(显示系统相关信息)</td></tr><tr><td>inspect</td><td>Return low-level information on a container(查看容器详细信息)</td></tr><tr><td>kill</td><td>Kill a running container(kill指定docker容器)</td></tr><tr><td>load</td><td>Load an image from a tar archive(从一个tar包中加载一个镜像,对应save)</td></tr><tr><td>login</td><td>Register or Login to the docker registry server(注册或者登陆一个 docker源服务器)</td></tr><tr><td>logout</td><td>Log out from a Docker registry server(从当前Docker registry退出)</td></tr><tr><td>logs</td><td>Fetch the logs of a container(输出当前容器日志信息)</td></tr><tr><td>port</td><td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT(查看映射端口对应的容器内部源端口)</td></tr><tr><td>pause</td><td>Pause all processes within a container(暂停容器)</td></tr><tr><td>ps</td><td>List containers(列出容器列表)</td></tr><tr><td>pull</td><td>Pull an image or a repository from the docker registry server(从docker镜像源服务器拉取指定镜像或者库镜像)</td></tr><tr><td>push</td><td>Push an image or a repository to the docker registry server(推送指定镜像或者库镜像至docker源服务器)</td></tr><tr><td>restart</td><td>Restart a running container(重启运行的容器)</td></tr><tr><td>rm</td><td>Remove one or more containers(移除一个或者多个容器)</td></tr><tr><td>rmi</td><td>Remove one or more images(移除一个或多个镜像——无容器使用该镜像才可删除,否则需删除相关容器才可继续或-f强制删除)</td></tr><tr><td>run</td><td>Run a command in a new container(创建一个新的容器并运行一个命令)</td></tr><tr><td>save</td><td>Save an image to a tar archive(保存一个镜像为一个tar包,对应load)</td></tr><tr><td>search</td><td>Search for an image on the Docker Hub(在docker hub中搜索镜像)</td></tr><tr><td>start</td><td>Start a stopped containers(启动容器)</td></tr><tr><td>stop</td><td>Stop a running containers(停止容器)</td></tr><tr><td>tag</td><td>Tag an image into a repository(给源中镜像打标签)</td></tr><tr><td>top</td><td>Lookup the running processes of a container(查看容器中运行的进程信息)</td></tr><tr><td>unpause</td><td>Unpause a paused container(取消暂停容器)</td></tr><tr><td>version</td><td>Show the docker version information(查看docker版本号)</td></tr><tr><td>wait</td><td>Block until a container stops, then print its exit code(截取容器停止时的退出状态值)</td></tr></tbody></table></li></ol></li></ul><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><ul><li>是什么：镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件</strong>。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件<ul><li>UnionFS(联合文件系统,类比花卷)：<ul><li>介绍：Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统。<strong>它支持对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像</li><li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统。联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li></ul></li><li>Docker镜像加载原理：<ul><li>docker的镜像实际上由一层一层的文件系统(UnionFS)组成</li><li>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel。Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是bootfs</strong>。这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</li><li>rootfs(root file system)在bootfs之上。包含典型Linux系统中的/dev、/proc、/bin和/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等</li></ul></li><li>为什么Docker中CentOS镜像出奇的小？(平时安装进虚拟机的CentOS都是好几个G,docker里才200M)<br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。因为底层直接用Host的kernel，自己只需要提供rootfs就行。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs</li><li>Docker镜像采用分层结构的理由：最大好处就是共享资源。比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享</li></ul></li><li>特点：Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层”，”容器层”之下的都叫”镜像层”</li><li>commit命令补充<ul><li>命令介绍：提交容器副本使之成为一个新的镜像</li><li>命令格式：docker commit -m=”提交的描述信息” -a=”作者” 容器id 要创建的目标镜像名:[标签]</li></ul></li></ul><h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><ul><li><p>是什么：Docker的理念是将软件与运行的环境打包形成容器运行，运行可以伴随着容器。但对数据的要求希望是持久化的、容器之间希望有可能共享数据。Docker容器产生的数据如果不通过docker commit生成新的镜像使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。为了能保存数据在docker中我们使用卷。卷类似Redis里面的rdb和aof文件</p></li><li><p>能干嘛：</p><ul><li>容器的持久化</li><li>容器间继承+共享数据</li><li>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，它完全独立于容器的生存周期，Docker不会在容器删除时删除其挂载的数据卷</li><li>特点：<ol><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol></li></ul></li><li><p>数据卷添加</p><ol><li><p>直接命令添加：docker run -it -v /主机目录路径:/容器目录路径 镜像名</p><ul><li>查看是否成功：docker inspect 容器id</li><li>容器停止退出后，主机修改后数据依然同步</li><li>设置只读(read only,容器)：docker run -it -v /主机目录路径:/容器目录路径:ro 镜像名</li></ul></li><li><p>Dockerfile添加：</p><ul><li><p>在新建Dockerfile添加volume指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 说明: 处于可移植和分享的考虑</span></span><br><span class="line"><span class="comment"># 使用-v 主机目录:容器目录这种方式不能直接在Dockerfile中实现</span></span><br><span class="line"><span class="comment"># 宿主机目录是依赖于特定宿主机的,并不能够保证在所有的宿主机上都存设定的特定目录</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>完整Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>, <span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Build Docker with Volume succeed~~~"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>完整流程：</p><ol><li>编写上述Dockerfile</li><li>build生成镜像：docker build -f Dockerfile -t sobxiong/centos .</li><li>run运行容器：docker run -it sobxiong/centos /bin/bash</li><li>查看目录是否存在，测试创建文件并写入内容</li><li>查看宿主机对应目录：docker inspect 容器id</li><li>前往对应目录查看内容</li></ol></li></ul></li></ol></li><li><p>数据卷容器</p><ul><li>是什么：命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享。挂载数据卷的容器称为数据卷容器</li><li>前提：以sobxiong/centos为模板运行容器test1，它具有/dataVolumeContainer1和/dataVolumeContainer2容器卷</li><li>容器间传递共享：<ol><li>先启动父容器test1，并在dataVolumeContainer2中新增内容</li><li>以继承方式启动test2和test3：docker run -it –name test2 –volumes-from test1 sobxiong/centos</li><li>test2和test3分别在dataVolumeContainer2中新增内容</li><li>test1中可以看到新增的内容</li><li>删除test1后，test2修改的内容test3依旧可读</li><li>删除test2后，test3依旧可读之前内容</li><li>新建test4继承test3再删除test3，之前内容依旧可见</li></ol></li><li>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</li></ul></li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li><p>是什么：用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本</p></li><li><p>构建三步骤：</p><ol><li>编写Dockerfile文件</li><li>docker build</li><li>docker run</li></ol></li><li><p>Dockerfile具体实例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以CentOS镜像为例</span></span><br><span class="line"><span class="comment"># https://github.com/CentOS/sig-cloud-instance-images/blob/12a4f1c0d78e257ce3d33fe89092eee07e6574da/docker/Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> centos-8-x86_64.tar.xz /</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> org.label-schema.schema-version=<span class="string">"1.0"</span>     org.label-schema.name=<span class="string">"CentOS Base Image"</span>     org.label-schema.vendor=<span class="string">"CentOS"</span>     org.label-schema.license=<span class="string">"GPLv2"</span>     org.label-schema.build-date=<span class="string">"20200809"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>Dockerfile基础知识：</p><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>‘#’表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol></li><li><p>执行Dockerfile的大致流程</p><ol><li>docker从基础镜像(scratch)运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行Dockerfile中的下一条指令直到所有指令都执行完成</li><li>小总结：<ul><li>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：<ol><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态</li></ol></li><li>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石：<br><img src="Dockerfile%E6%9E%84%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Dockerfile构建示意图"><ol><li>Dockerfile：定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务、内核进程打交道时,需要考虑如何设计namespace的权限控制)等等</li><li>Docker镜像：在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行Docker镜像时真正开始提供服务</li><li>Docker容器：直接提供服务</li></ol></li></ul></li></ol></li><li><p>Dockerfile体系结构(保留字指令)</p><ol><li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的</p></li><li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p></li><li><p>RUN：容器构建时需要运行的命令</p></li><li><p>EXPOSE：当前容器对外暴露出的端口</p></li><li><p>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p></li><li><p>ENV：用来在构建镜像过程中设置环境变量</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境变量可以在后续的任何RUN指令中使用,就如同在命令前面指定了环境变量前缀一样</span></span><br><span class="line"><span class="comment"># 也可以在其它指令中直接使用这些环境变量,如：WORKDIR $MY_PATH</span></span><br><span class="line"><span class="keyword">ENV</span> MY_PATH /usr/mytest</span><br></pre></td></tr></table></figure></li><li><p>ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p></li><li><p>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中源路径的文件/目录复制到新的一层的镜像内的目标路径位置</p><ol><li>COPY src dest</li><li>COPY [“src”, “dest”]</li></ol></li><li><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p></li><li><p>CMD：指定一个容器启动时要运行的命令；Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</p></li><li><p>ENTRYPOINT：指定一个容器启动时要运行的命令；ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数(不像CMD,不会被替换,都生效)</p></li><li><p>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p></li><li><p>小总结：<br><img src="Dockerfile%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4.png" alt="Dockerfile常用保留字指令"></p></li></ol></li><li><p>案例：</p><ul><li><p>Base镜像(scratch)：Docker Hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p></li><li><p>自定义镜像mycentos：</p><ul><li><p>编写：</p><ul><li><p>目标：</p><ol><li>基于centos镜像</li><li>登陆后默认路径为/</li><li>安装vim编辑器</li><li>安装net-tools(支持ifconfig)</li></ol></li><li><p>内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> sobxiong</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"success--------------ok"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>构建：docker build -f Dockerfile -t 新镜像名:Tag .</p></li><li><p>运行：docker run -it 新镜像名:Tag</p></li><li><p>列出镜像变更历史：docker history 镜像名</p></li><li><p>CMD/ENTRYPOINT：均指定一个容器启动时要运行的命令</p><ul><li>CMD：Dockerfile中可以有多个CMD 指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li><li>ENTRYPOINT：docker run之后的参数会被当做参数传递给ENTRYPOINT，之后形成新的命令组合</li></ul></li></ul></li><li><p>总结：<br><img src="Dockerfile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Dockerfile构建过程示意图"></p></li></ul><h2 id="Docker安装步骤"><a href="#Docker安装步骤" class="headerlink" title="Docker安装步骤"></a>Docker安装步骤</h2><ol><li>搜索镜像</li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像</li><li>停止容器</li><li>移除容器</li></ol><h2 id="Docker镜像发布"><a href="#Docker镜像发布" class="headerlink" title="Docker镜像发布"></a>Docker镜像发布</h2><ul><li>发布流程(阿里云)<br><img src="%E9%98%BF%E9%87%8C%E4%BA%91ECS%E7%9A%84Docker%E7%94%9F%E6%80%81%E5%9B%BE.png" alt="阿里云ECS的Docker生态图"><ol><li>生成镜像：<ol><li>从Dockerfile构建</li><li>从容器创建一个新镜像：docker commit [Options] 容器id [Repository[:Tag]]</li></ol></li><li>将本地镜像推送到阿里云<ol><li>登陆阿里云</li><li>创建仓库镜像：命名空间、仓库名称</li><li>根据提示推送镜像到registery(此后可查看可下载)</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2020/10/09/BasicSkill/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/10/09/BasicSkill/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#top命令">top命令</a></li><li><a href="#free命令">free命令</a></li><li><a href="#df命令">df命令</a></li><li><a href="#vmstat命令">vmstat命令</a></li><li><a href="#iostat命令">iostat命令</a></li></ul><a id="more"></a><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><ul><li>查看整机性能：top(主要cpu)<ul><li>按数字1查看cpu各核心情况：<ol><li>us user</li><li>sy system</li><li>id idle(空闲率,越高越好)</li></ol></li><li>load average：a b c(系统1、5、15分钟的系统平均负载量,如果abc平均大于0.6说明系统负担重,大于0.8说明系统快宕机)</li><li>q退出</li></ul></li><li>低配版：uptime</li></ul><h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h2><ul><li>查看内存：free(默认kb)</li><li>free -m(MB)、free -g(GB)</li></ul><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><ul><li>查看磁盘：df(disk free,默认kb)</li><li>df -h(以MB为单位)</li></ul><h2 id="vmstat命令"><a href="#vmstat命令" class="headerlink" title="vmstat命令"></a>vmstat命令</h2><ul><li>查看简单的系统性能：vmstat -n 2 3(2代表每两秒采集一次,3代表共采集三次)</li><li>重要参数：<ol><li>r：runtime process(运行进程数)</li><li>b：blocking process(阻塞进程数,越少越好)</li></ol></li></ul><h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><ul><li>查看磁盘IO情况：iostat -xdk 2 3(2,3同上)</li><li>重要参数：<ol><li>r/s：每秒读</li><li>w/s：每秒写</li><li>%util：一秒中有百分之多少的时间用于I/O操作，或者说一秒中有多少时间I/O队列是非空的</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BasicSkill </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2020/10/08/ProgrammingLanguage/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/10/08/ProgrammingLanguage/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#基础知识">基础知识</a></li><li><a href="#进阶知识">进阶知识</a></li></ul><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>访问修饰符：Java有三个显式关键字来设置类中的访问权限：public(公开)、private(私有)和protected(受保护)。访问修饰符决定了谁能使用它们修饰的方法、变量或类</p><ul><li>四种访问修饰符：<ol><li><code>public</code>(公开)：表示任何人都可以访问和使用该元素</li><li><code>private</code>(私有)：除了类本身和类内部的方法，外界无法直接访问该元素。private是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误</li><li><code>protected</code>(受保护)：类似于private，区别是子类可以访问protected的成员，但不能访问 private成员</li><li><code>default</code>(默认)：如果不使用前面的三者，默认就是default访问权限。default被称为包访问，因为该权限下的资源可以被同一包(库组件)中其他类的成员访问</li></ol></li><li>每个编译单元(文件)中只能有一个public修饰的类，或者没有</li><li>类不能用private和protected修饰，只能用public或者空(default,包访问权限符)修饰</li></ul></li><li><p>零碎知识点：</p><ol><li>Java是单继承结构</li><li>区别组合和聚合的一种方式是整体和部分的生命周期联系(生命周期同步为组合,否则为聚合)</li><li>尽量使用组合而不是继承，继承要慎重</li><li>final：<ul><li>修饰变量：修饰对象引用时，final使引用恒定不变，但对象本身属性是可以修改的(static只会附加静态的属性)；未定义的final属性必须在构造函数或者初始化块(静态/非静态)中赋值</li><li>修饰方法：明确禁止子类覆写方法(private方法隐式指定为final,因为除类本身外不能访问)</li><li>修饰类：禁止类被继承，类中方法隐式地被指定为final</li></ul></li><li>类的代码在首次使用时加载(Class被加载)</li><li>包含抽象方法的类叫抽象类，如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的；可将一个不包含任何抽象方法的类指明为abstract</li></ol></li><li><p>常用数据类型：</p><ol><li><p>基本数据类型：</p><table><thead><tr><th>基本类型</th><th>大小</th><th>最小值</th><th>最大值</th><th>默认值</th><th>包装类型</th></tr></thead><tbody><tr><td>boolean</td><td>/</td><td>/</td><td>/</td><td>false</td><td>Boolean</td></tr><tr><td>char</td><td>16bits</td><td>Unicode0</td><td>Unicode2^16-1</td><td>\u0000(null)</td><td>Character</td></tr><tr><td>byte</td><td>8bits</td><td>-128</td><td>127</td><td>(byte)0</td><td>Byte</td></tr><tr><td>short</td><td>16bits</td><td>-2^15</td><td>2^15-1</td><td>(short)0</td><td>Short</td></tr><tr><td>int</td><td>32bits</td><td>-2^31</td><td>2^31-1</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>64bits</td><td>-2^63</td><td>2^63-1</td><td>0L</td><td>Long</td></tr><tr><td>float</td><td>32bits</td><td>IEEE754</td><td>IEEE754</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>64bits</td><td>IEEE754</td><td>IEEE754</td><td>0.0d</td><td>Double</td></tr><tr><td>void</td><td>/</td><td>/</td><td>/</td><td>/</td><td>Void</td></tr></tbody></table><blockquote><p>基本数据类型只有是字段(类的成员变量/数组成员)/静态变量时才会设置为默认值，局部变量定义的基本数据类型没有默认值</p></blockquote></li><li><p>高精度数值：BigInteger、BigDecimal</p></li><li><p>数组：对象数组默认元素初始化为null，基本类型数组默认元素初始化为0</p></li></ol></li><li><p>运算符：</p><ul><li>相等：<ol><li>==和!=：比较对象引用</li><li>equals()：可覆写，默认也是比较对象引用</li></ol></li><li>移位运算符：<ol><li>&lt;&lt;：向左移动指定位数，低位补0</li><li>&gt;&gt;：向右移动指定位数，如果值为正，高位补0；否则高位补1</li><li>&gt;&gt;&gt;：零扩展向右移动指定位数，无论值的正负，高位都补0</li><li>移位匹配位数(short、char、byte虽然位数少会提升为int,但可移动的位数只有本身长度)</li></ol></li><li>截断和舍入：float和double转为整数值时，小数位将被截断(不存在四舍五入)；四舍五入只能通过<code>Math.round()</code>方法</li></ul></li><li><p>label(标签)：唯一用到标签的地方在循环语句之前；当在循环中嵌套循环或者开关时，break、continue关键字可以和标签搭配使用</p></li><li><p>方法：</p><ol><li><p>如果两个方法命名相同，Java通过参数列表进行区分(无返回值信息和异常说明列表,顺序可以不同)————方法签名包括方法名和参数</p></li><li><p>如果类未显式声明构造器，编译器自动创建一个无参构造器</p></li><li><p><code>finalize()</code>方法：当垃圾回收器准备回收对象的内存时，首先会调用其finalize()方法(不保证一定会发生)，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。注意该方法不等同于C++中的析构函数。该函数在本地方法情况下存在较大的作用</p></li><li><p>创建对象的过程(以类Test为例)</p><ol><li>即使没有显式地使用static关键字，构造器实际上也近似静态方法。所以当首次创建Test类型的对象或是首次访问Test类的静态方法或属性时，Java解释器必须在类路径中查找以定位Test.class</li><li>当加载完Test.class后(将创建一个Class对象)，有关静态初始化的所有动作都会执行。因此静态初始化只会在首次加载Class对象时初始化一次</li><li>当调用<code>new Test()</code>创建对象时，首先会在堆上为Test对象分配足够的存储空间</li><li>分配的存储空间首先会被清零，接着会将Test对象中的所有基本类型数据设置为默认值，引用被置为null</li><li>执行所有出现在字段定义处的初始化动作</li><li>执行构造器</li></ol></li><li><p>显式的非静态与静态实例初始化：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态初始化,构造器之前执行</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java5中重写方法添加了对协变返回类型的支持(重写方法的返回值类型可以是被重写方法返回值类型的子类)</p></li><li><p>不能重写基类的private方法，这样只会屏蔽，而在派生类中生成一个新的方法</p></li><li><p>初始化的过程：</p><ol><li>分配给对象的存储空间初始化为二进制0</li><li>调用基类构造器；如果此时在基类构造器中调用多态方法将会调用到派生类的方法，但派生类的属性目前全为二进制0(可能导致隐蔽的错误)</li><li>按声明顺序初始化成员</li><li>调用派生类的构造器</li></ol></li></ol></li><li><p>多态</p><ol><li>绑定：将一个方法调用和一个方法主体关联起来</li><li>前期绑定：若绑定发生在程序运行前(如果有的话,由编译器和链接器实现)；它是面向过程语言默认绑定方式，C语言只有这一种前期绑定这种方法调用</li><li>后期绑定(动态绑定/运行时绑定)：后期绑定意味着在运行时根据对象的类型进行绑定。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。即编译器仍然不知道对象的类型，但方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到对象中一定存在某种类型信息</li><li>Java中除了static和final方法(private方法也是隐式的final)外，其他所有方法都是后期绑定。这意味着通常情况下不需要判断后期绑定是否会发生————它自动发生</li><li>基类和派生类声明同名的变量会被分配到不同的存储空间，任何属性访问都被编译器解析，因此不存在多态</li><li>静态方法没有多态特性，只与类关联</li></ol></li><li><p>抽象类和接口的区别：</p><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>组合</td><td>新类可以组合多个接口</td><td>只能继承单一抽象类</td></tr><tr><td>状态</td><td>不能包含属性(除了静态属性,不支持对象状态)</td><td>可以包含属性,非抽象方法可能引用这些属性</td></tr><tr><td>默认方法和抽象方法</td><td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td>必须在子类中实现抽象方法</td></tr><tr><td>构造器</td><td>没有构造器</td><td>可以有构造器</td></tr><tr><td>可见性</td><td>隐式public</td><td>可以是protected或public</td></tr></tbody></table></li><li><p>内部类：定义在另一个类中的类</p><ol><li>内部类自动拥有对其外部类所有成员的访问权(当某个外部类的对象创建了一个内部类对象时,此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后在访问此外部类的成员时用那个引用来选择外部类的成员)</li><li>在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗自地连接到建它的外部类对象上。但是如果创建的是嵌套类(静态内部类)，那么它就不需要对外部类对象的引用</li><li>private内部类可以完全隐藏实现的细节，但通过对外暴露接口的方式提供服务(只能得到接口的引用,内部类的引用得不到,因为不可见)</li><li>可以在一个方法或者任意的作用域内定义内部类</li><li>定义一个匿名内部类时，如果内部要使用一个外部环境对象，那么需要参数引用是final的(传给基类构造器无需final)</li><li>匿名类中不能有命名构造器，但通过实例初始化能达到构造器的效果</li><li>匿名内部类与正规的继承相比有些受限————因为匿名内部类要么继承类，要么实现接口(也只能实现一个接口)，但不能两者兼备</li><li>嵌套类是声明为static的内部类，它无需内部类对象与其外部类对象之间有联系</li><li>创建嵌套类的对象时不需要其外部类的对象；不能从嵌套类的对象中访问非静态的外部类对象</li><li>普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西</li><li>嵌套类可作为接口的一部分，接口中的任何类都自动是public和static的；甚至可以在接口的内部类中实现外部接口</li><li>一个内部类被嵌套多少层并不重要————它能透明地访问所有它所嵌入的外部类的所有成员</li><li>内部类可以近似提供继承多个具体或抽象的类的能力</li><li>闭包(closure)是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。内部类是面向对象的闭包，因为它不仅包含外部类对象(创建内部类的作用域)的信息，还自动拥有一个指向此外部类对象的引用。在此作用域内，内部类有权操作所有的成员，包括private成员(Java8及以后还可以使用lambda表达式实现闭包)</li><li>因为内部类的构造器必须连接到指向其外部类对象的引用，所以在继承内部类的时候————那个指向外部类对象的”秘密的”引用必须被初始化，因此继承内部类的构造器必须显式定义含有外部类引用的参数并调用<code>outerClass.super()</code></li></ol></li><li><p>集合</p><ol><li>Java5引入Iterable接口，任何实现了该接口的类都可以使用增强for循环遍历(Collection接口满足,例外的是数组)</li></ol></li><li><p>异常：</p><ol><li><p>抛出异常发生的事：首先同Java中其他对象的创建一样，将使用new在堆上创建异常对象。然后当前的执行路径(它不能继续下去了)被终止，并且从当前环境中弹出对异常对象的引用。此时异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去</p></li><li><p>能够抛出任意类型的Throwable，它是异常类型的根类(Exception是与编程有关的所有异常类的基类)</p></li><li><p>方法显式定义的throws异常称为被检查的异常(在编译时强制检查)</p></li><li><p>Java7新增了多重捕获语法(用’|’分隔多种异常,只需要一条catch语句)</p></li><li><p><code>printStackTrace()</code>方法所提供的信息可以通过<code>getStackTrace()</code>方法来直接访问，该方法将返回一个由栈轨迹中的元素构成的数组(其中每一个元素都表示栈中的一桢)。元素0是栈顶元素也是调用序列中的最后一个方法调用(该Throwable被创建和抛出之处)。最后一个元素是栈底也是调用序列中的第一个方法调用</p></li><li><p>在捕获异常后再原样抛出异常将丢失原来异常抛出点的调用栈信息。可以抛出<code>exception.fillInStack()</code>，这样可以保留</p></li><li><p>在捕获异常后再抛出另一个异常，Exception和RuntimeException提供带cause(Throwable)参数的构造器重抛异常而不丢失信息；但如果要将其他类型异常链接起来，应该使用<code>initCause()</code>而不是构造器</p></li><li><p>Throwable类用来表示任何可以作为异常被抛出的类。Throwable可分为两种类型(从Throwable继承而得到的类)：</p><ol><li>Error：表示编译时和系统错误(由JVM自动抛出)</li><li>Exception：表示可被抛出的基本类型，在Java类库、用户方法以及运行时故障中都可能抛出；特殊的是RuntimeException，它表示编程错误且也由JVM自动抛出，如无法预料的错误(null引用)以及应该在代码中进行检查的错误(数组越界)，该异常不要求强制检查(代码中只有RuntimeException及其子类可以被忽略)</li></ol></li><li><p>finally：finally的作用是把除内存外的资源(文件、网络、图形资源,例外是本地方法占用的内存资源)恢复到初始状态；try-finally会忽略异常，谨慎使用</p></li><li><p>异常限制：覆盖方法时只能抛出在基类方法的异常说明中列出的异常(对构造器不起作用且只能范围相等或更小)</p></li><li><p>构造器中的异常要谨慎，因为可能资源没有被正确地清理</p></li><li><p>Try-With-Resources语法：Java7增加了一个新特性，该特性提供了另外一种管理资源的方式————这种方式能自动关闭文件(或资源)。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)，该特性以try语句的扩展版为基础。当不再需要文件(或其他资源)时，可以防止无意中忘记释放它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  自动资源管理基于try语句的扩展形式：</span></span><br><span class="line"><span class="comment">  当try代码块结束,自动释放资源。不需要显式调用close()方法。该形式也称为"带资源的try语句"</span></span><br><span class="line"><span class="comment">  释放时的close()顺序与声明时的创建顺序相反,因为可能创建过程可能后者依赖于前者</span></span><br><span class="line"><span class="comment">  注意:</span></span><br><span class="line"><span class="comment">  1、try语句中声明的资源被隐式声明为final,资源的作用局限于带资源的try语句</span></span><br><span class="line"><span class="comment">  2、可以在一条try语句中管理多个资源,每个资源以';'隔开即可</span></span><br><span class="line"><span class="comment">  3、需要关闭的资源必须实现AutoCloseable接口或其子接口Closeable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// ()内的部分称为资源规范头</span></span><br><span class="line"><span class="keyword">try</span>(需要关闭的资源声明)&#123;</span><br><span class="line">  <span class="comment">// 可能发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型变量名) &#123;</span><br><span class="line">  <span class="comment">// 异常的处理语句</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 一定执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常匹配：抛出异常的时候，异常处理系统会按照代码的书写顺序找出”最近”的处理程序。找到匹配的处理程序之后就认为异常将得到处理，不再继续查找。查找时并不要求抛出的异常同声明的异常类型完全匹配(派生类也可匹配其基类的处理程序)，如果将基类异常放在派生类异常前，则会屏蔽所有派生类异常</p></li><li><p>异常处理的一个重要原则是————只有在你知道如何处理的情况下才捕获异常。实际上异常处理的一个重要目标就是把处理错误的代码同错误发生的地点相分离</p></li><li><p>在编译时被强制检查的异常称为受检查的异常</p></li><li><p>异常指南————应该在下列情况下使用异常：</p><ol><li>尽可能使用try-with-resource</li><li>在恰当的级别处理问题(在知道该如何处理的情况下才捕获异常)</li><li>解决问题并且重新调用产生异常的方法</li><li>进行少许修补，然后绕过异常发生的地方继续执行</li><li>用别的数据进行计算，以代替方法预计会返回的值</li><li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层</li><li>把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层</li><li>终止程序</li><li>进行简化，不要让异常模式使问题变得复杂</li><li>让类库和程序更安全</li></ol></li></ol></li><li><p>断言：</p><ol><li><p>用法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="keyword">boolean</span>-expression;</span><br><span class="line"><span class="comment">// information-expression用于生成一条有用的消息通知调用者，可以生成任何类型的对象</span></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">boolean</span>-expression: information-expression;</span><br></pre></td></tr></table></figure></li><li><p>可以基于类名或包名打开或关闭断言，也即可以对整个包启用或禁用断言。实现这一点的详细信息在JDK的断言文档中。此特性对于使用断言的大型项目来说很有用(当想打开或关闭某些断言时)。但日志记录(Logging)或者调(Debugging)可能是捕获这类信息的更好工具</p></li><li><p>还可以通过编程的方式通过链接到类加载器对象(ClassLoader)来控制断言。类加载器中有几种方法允许动态启用和禁用断言，其中<code>setDefaultAssertionStatus()</code>可为之后加载的所有类设置断言状态</p></li><li><p>Guava包提供的替换断言的Verify*类</p></li></ol></li><li><p>零碎</p><ol><li>基准测试：JMH</li><li>风格检测：CheckStyle</li><li>静态错误分析：Findbugs</li></ol></li><li><p>优化准则</p><ol><li>避免为了性能牺牲代码的可读性</li><li>不要独立地看待性能。衡量与带来的收益相比所需投入的工作量</li><li>程序的大小很重要。性能优化通常只对运行了长时间的大型项目有价值。性能通常不是小项目的关注点</li><li>运行起来程序比一心钻研它的性能具有更高的优先级。一旦已经有了可工作的程序，如有必要的话，可以使用剖析器提高它的效率。只有当性能是关键因素时，才需要在设计/开发阶段考虑性能</li><li>不要猜测瓶颈发生在哪。运行剖析器，让剖析器告诉你</li><li>无论何时有可能的话，显式地设置实例为null，表明你不再用它。这对垃圾收集器来说是个有用的暗示</li><li>static final修饰的变量(编译期常量)会被JVM优化从而提高程序的运行速度。因而程序中的常量应该声明static final</li></ol></li><li><p>文件：java.nio.file</p></li><li><p>字符串：</p><ol><li>字符串String对象是不可变的(只读)；每个看起来修改String值的方法实际都是创建一个全新的String对象</li><li>对String对象的重载操作符’+’以及”+=”底层反汇编成<code>StringBuilder.append()</code>以及<code>StringBuilder.toString()</code>方法的调用(StringBuilder线程不安全但效率高,StringBuffer线程安全但效率低)</li></ol></li><li><p>类型信息</p><ol><li>RTTI(RunTime Type Information,运行时类型信息)能够在程序运行时发现和使用类型信息</li><li>Java在运行时识别对象和类信息的两种方式：<ol><li>“传统”的RTTI：假定在编译时已经知道所有的类型</li><li>“反射”机制：允许在运行时发现和使用类的信息</li></ol></li><li>Class对象：<ol><li>Class对象用来创建该类所有常规对象</li><li>Java使用Class对象实现RTTI(类型转换也是通过Class)</li><li>每个类都有一个Class对象。每当编写并且编译了一个新类，就会产生一个Class对象(更恰当的是保存在一个同名的.class文件中)。为了生成这个类的对象，JVM先会调用类加载器子系统把这个类加载到内存中</li><li>所有的类都是第一次使用时动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时就会加载这个类。Java程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。类加载器首先会检查这个类的Class对象是否已经加载；如果尚未加载，默认的类加载器就会根据类名查找.class文件(或者利用附加的类加载器通过其它方式获得字节码)。该类的字节码被加载后，JVM 会对其进行验证，确保它没有损坏，并且不包含不良的Java代码(Java安全防范的一种措施)。一旦某个类的Class对象被载入内存，它就可以用来创建这个类的所有对象<blockquote><p>其实构造器也是类的静态方法，虽然构造器前面并没有static关键字。使用new操作符创建类的新对象也算作对类的静态成员引用</p></blockquote></li><li>获取Class对象的方法：<ol><li><code>classObj = Class.forName(完整包名)</code>：会自动初始化该Class对象</li><li><code>xxx.class</code>：类字面常量(编译时受检查,更安全,效率比<code>Class.forName()</code>高)，该方式不会自动初始化该Class对象(直到第一次引用一个static方法(包含构造器)或者非常量的static字段(编译期常量))<blockquote><p>为了使用类而做的准备工作：</p><ol><li>加载，这是由类加载器执行的。该步骤将查找字节码(通常在classpath所指定的路径中查找,但这并非是必须的)，并从这些字节码中创建一个Class对象</li><li>链接。在链接阶段将验证类中的字节码，为static字段分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用</li><li>初始化。如果该类具有超类，则先初始化超类，执行static初始化器和static初始化块</li></ol></blockquote></li></ol></li><li><code>class.newInstance()</code>要求类必须有一个无参构造器，否则会抛出运行时异常，编译期不会产生任何警告信息</li><li>泛化的Class引用(Class&lt;T&gt;)：<ol><li>普通的类引用可以重新赋值指向任何其他的Class对象，但是使用泛型限定的类引用只能指向其声明的类型。通过使用泛型语法可以让编译器强制执行额外的类型检查</li><li>为了在使用Class引用时放松限制，Java使用了通配符’?’，它是Java泛型中的一部分，表示”任何事物”：Class&lt;?&gt;</li><li>使用Class<?>比单纯使用Class要好，虽然它们是等价的，并且单纯使用Class不会产生编译器警告信息。使用Class<?>的好处是它表示并非是碰巧或者由于疏忽才使用了一个非具体的类引用，而是特意为之</li><li>为了创建一个指向某种限定类型或其子类的Class引用，需要将通配符与extends关键字配合使用，创建一个范围限定：Class&lt;? extends Xxx&gt;；与此同时还有Class&lt;? super Xxx&gt;</li><li>向Class引用添加泛型语法的原因只是为了提供编译期类型检查，因此如果操作有误，稍后就会发现这点。使用普通的Class引用要确保不会犯错，因为一旦犯了错误就要等到运行时才能发现它</li><li>泛化语法用于<code>newInstance()</code>将返回对象的确切类型，然而这只限定是确定的泛化(继承的泛化还是返回Object)</li></ol></li></ol></li><li>RTTI的类型：<ol><li>传统的类型转化：<code>(A)b</code></li><li>代表对象类型的Class对象</li><li>关键字instanceof(<code>Class.isInstance()</code>方法提供了一种动态测试对象类型的方法)</li></ol></li></ol></li><li><p>反射：</p><ol><li>类Class支持反射的概念，java.lang.reflect库中包含类Field、Method和Constructor(每一个都实现了Member接口)。这些类型的对象由JVM在运行时创建，以表示未知类中的对应成员。然后可以使用Constructor创建新对象，get()和set()方法读取和修改与Field对象关联的字段，invoke()方法调用与Method对象关联的方法。此外，还可以调用便利方法getFields()、getMethods()、getConstructors()等以返回表示字段、方法和构造函数的对象数组。因此匿名对象的类信息可以在运行时完全确定，编译时不需要知道任何信息</li><li>RTTI和反射的真正区别在于：使用RTTI时，编译器在编译时会打开并检查.class文件(换句话说,可以用”正常”的方式调用一个对象的所有方法)。通过反射，.class文件在编译时不可用，它由运行时环境打开并检查</li><li>JDK动态代理(接口代理)：实现InvocationHandler接口，重写<code>invoke()</code>方法，在属性中加入原对象，<code>invoke()</code>调用时时调用原对象相应方法</li><li>Optional是null的一个轻量级代理</li></ol></li><li><p>泛型：</p></li></ul><h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><ul><li><p>switch字符串：Java7增加了在字符串上switch的用法，这其实时一个逻辑扩展的语法糖(通过字符串的hashCode()等条件转换成整数的switch-case语句)</p></li><li><p>封装：将数据和方法包装进类中并把具体实现隐藏，结果是一个同时带有特征和行为的数据类型</p></li><li><p>接口：</p><ol><li>Java8允许接口包含默认方法和静态方法</li><li>接口中的属性被隐式指明为static和final</li></ol></li><li><p>函数式编程：</p><ol><li><p>Lambda表达式与单独定义类和采用匿名内部类是等价的</p></li><li><p>Lambda表达式是最小可能语法编写的函数定义，它产生函数，但表现为类</p></li><li><p>Lambda基本语法：</p><ol><li>参数，接着箭头”-&gt;”，接着方法体</li><li>如果只有一个参数时不需要括号”()”，如果没有参数必须使用”()”表示空参数列表，如果又多个参数将参数列表放在”()”中</li><li>如果方法体是单行，无需花括号”{}”，结果自动成为返回值，使用return非法；如果多行，需要”{}”和显式的return</li></ol></li><li><p>可以编写递归Lambda表达式，但递归方法必须是实例变量或静态变量</p></li><li><p>方法引用以”::”为特征，左侧是类或对象的名称，右侧是方法名，但没有参数列表(隐式输入传入对象,普通方法隐含需要this,静态方法无需this)；构造器的方法引用是new</p></li><li><p>可以将方法引用传递给函数式接口(名称无关紧要,只要参数类型和返回类型相同)</p></li><li><p>高阶函数：消费或者生产函数的函数</p></li><li><p>被Lambda表达式引用的局部变量必须是final或者等同final效果的(对象引用可以改变改变属性)；但Lambda可以没限制地引用实例变量和静态变量</p></li><li><p>函数组合：多个函数组合成新函数，java.util.function接口中包含支持函数组合的方法</p><table><thead><tr><th>组合方法</th><th>具体操作</th></tr></thead><tbody><tr><td>andThen(argument)</td><td>执行原操作,再执行参数操作</td></tr><tr><td>compose(argument)</td><td>执行参数操作,再执行原操作</td></tr><tr><td>and(argument)</td><td>原谓词(Predicate)和参数谓词的短路逻辑与</td></tr><tr><td>or(argument)</td><td>原谓词和参数谓词的短路逻辑或</td></tr><tr><td>negate()</td><td>该谓词的逻辑非</td></tr></tbody></table></li><li><p>柯里化：将一个多参数的函数转换为一系列单参数函数</p></li></ol></li><li><p>流式编程：</p><ol><li>流(Streams)是与任何特定存储机制无关的元素序列————流是”没有存储”的</li><li>流的核心好处：程序短小且更易理解</li><li>流式编程的核心特征：内部迭代(看不到迭代的过程,使代码可读性更强,能更简单使用多核处理器)</li><li>流是懒加载的，它只在绝对必要时才计算</li><li>流操作的类型有三种：创建流、修改流元素(中间操作)以及消费流元素(终端操作,通常意味着收集流元素)</li><li>命令式编程指明了每一步如何做，而声明式编程声明了要做什么而不指明每一步如何做；声明式编程是函数式编程的风格</li><li>流创建：<ol><li><code>Stream.of()</code>方法</li><li><code>集合.stream()</code>方法</li><li>随机数流：<code>random对象.ints(from, to)</code>方法(long、double同,可使用boxed()方法装箱)</li><li><code>Stream.generate()</code>方法：把任意Supplier&lt;T&gt;用于生成T的流</li><li><code>IntStream.range()</code>方法(long、double类似)</li><li><code>Stream.iterate(x, y)</code>：x是第一个元素(种子)；y是一个函数用于迭代生成元素，会存储每次生成的元素，第一次传入种子</li><li>Stream.Builder：用于接收信息并创建流</li><li><code>Arrays.stream()</code>方法</li></ol></li><li>中间操作：<ol><li><code>peek()</code>：帮助调试，无修改查看流中元素</li><li><code>sorted()</code>：排序，传入一个Comparator参数</li><li><code>distinct()</code>：消除流中重复元素(相比创建set集合消除重复工作量来的少)</li><li><code>filter()</code>：过滤操作，若为true则保留</li><li><code>map()</code>：改变流元素(mapToInt、mapToLong和mapToDouble同理)</li><li><code>flatMap()</code>：扁平化元素————将产生流的函数应用于每个元素上，然后每个流扁平化为元素(floatMapToInt、floatMapToLong和floatMapToDouble同理)</li></ol></li><li>终端操作：<ol><li>转为数组<ul><li><code>toArray()</code>：将流转换成适当类型的数组</li><li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组</li></ul></li><li>循环(遍历)<ul><li><code>forEach(Consumer)</code>：普通循环(并行下不保证顺序)</li><li><code>forEachOrdered(Consumer)</code>：保证forEach按照原始流顺序操作(并行下也保证顺序)</li></ul></li><li>转为集合<ul><li><code>collect(Collector)</code>：使用Collector收集流元素到结果集合中(<code>Collectors.toCollection(xxx::new)</code>可用于构建任何类型集合,toMap同理)</li><li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上；参数1用于创建新的结果集合，参数2用于添加一个元素(逻辑)，参数3用于添加一个集合(逻辑)</li></ul></li><li>组合<ul><li><code>reduce(BinaryOperator)</code>：使用BinaryOperator来组合所有流中的元素。因为流可能为空，其返回值为Optional</li><li><code>reduce(identity, BinaryOperator)</code>：功能同上，但使用identity作为其组合的初始值。因此如果流为空，identity就是结果</li><li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式，它可以提高效率。通常可以显式地组合map和reduce来更简单地表达它</li></ul></li><li>匹配<ul><li><code>allMatch(Predicate)</code>：所有都满足Predicate则返回为true；在第一个不满足处停止执行</li><li><code>anyMatch(Predicate)</code>：任一满足Predicate则返回true；在第一个满足时停止执行</li><li><code>noneMatch(Predicate)</code>：所有都不满足Predicate则返回true；在第一个满足时停止执行</li></ul></li><li>查找<ul><li><code>findFirst()</code>：返回第一个流元素的Optional，如果流为空则返回Optional.empty</li><li><code>findAny()</code>：返回含有任意流元素的Optional，如果流为空则返回Optional.empty(非并行流会选择第一个元素)</li></ul></li><li>信息<ul><li><code>count()</code>：返回流中的元素个数</li><li><code>max(Comparator)</code>：返回根据传入的Comparator所决定的最大元素(数值流无需Comparator)</li><li><code>min(Comparator)</code>：返回根据传入的Comparator所决定的最小元素(数值流无需Comparator)</li><li><code>average()</code>：求取流元素平均值(数值流专有)</li><li><code>sum()</code>：对所有流元素进行求和(数值流专有)</li></ul></li></ol></li><li>Optional：防止从空流中获取元素的中断(用于包装成统一的对象,包括null)<ul><li>便利的解包函数(简化包含对象的检查和执行操作)：<ol><li><code>ifPresent(Consumer)</code>：当值存在时调用Consumer，否则什么也不做</li><li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成otherObject</li><li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用Supplier函数生成一个可替代对象</li><li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用Supplier函数生成一个异常</li></ol></li><li>创建(通过Optional静态方法)<ol><li><code>Optional.empty()</code>：生成一个空Optional</li><li><code>Optional.of(value)</code>：将一个非空值包装到Optional里</li><li><code>Optional.ofNullable(value)</code>：针对一个可能为空的值————为空时自动生成Optional.empty，否则将值包装在Optional中</li></ol></li><li>Optional对象操作(流中)<ol><li><code>filter(Predicate)</code>：对Optional中的内容应用Predicate并将结果返回(如果不满足或者本身已为空则返回Optional.empty)</li><li><code>map(Function)</code>：应用Function于Optional中的内容并返回结果(Optional为空返回Optional.empty)</li><li><code>flatMap(Function)</code>：同map；应用于已生成Optional的映射函数，所以不会将结果封装在Optional中(除非显式封装)</li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/2020/10/05/ProgrammingLanguage/Java/NIO/"/>
      <url>/2020/10/05/ProgrammingLanguage/Java/NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#NIO简介">NIO简介</a></li><li><a href="#缓冲区(Buffer)">缓冲区(Buffer)</a></li><li><a href="#通道(Channel)">通道(Channel)</a></li><li><a href="#选择器(Selector)">选择器(Selector)</a></li><li><a href="#其他">其他</a></li></ul><a id="more"></a><h2 id="NIO简介"><a href="#NIO简介" class="headerlink" title="NIO简介"></a>NIO简介</h2><ul><li><p>NIO简介：Java NIO(New I0)是从Java 1.4版本开始引入的一个新的I0 API，可以替代标准的Java I0 API。NIO与原来的I0有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的I0操作。NIO将以更加高效的方式进行文件的读写操作</p></li><li><p>NIO系统的核心：通道(Channel)和缓冲区(Buffer)。通道表示打开到I0设备(例如：文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接I0设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。<strong>简言之，Channel负责传输，Buffer负责存储</strong></p></li><li><p>NIO与IO的主要区别：</p><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table></li><li><p>阻塞和非阻塞介绍：</p><ol><li>阻塞：传统的I0流都是阻塞式的。也就是说，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行I0操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降</li><li>非阻塞：NIO是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞I0的空闲时间用于在其他通道上执行I0操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</li></ol></li><li><p>NIO主要有三大核心组件：通道(Channel)、缓冲区(Buffer)以及选择器(Selector)</p></li></ul><h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h2><ul><li><p>介绍：</p><ul><li><p>一个用于特定基本数据类型的容器的，在java.nio包中定义，所有缓冲区都是Buffer抽象类的子类。NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p></li><li><p>Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean除外)，有以下Buffer常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer以及DoubleBuffer。上述Buffer类它们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个Bufferd对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为capacity的XxxBuffer对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> XxxBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基本属性(标记、位置、限制、容量遵守以下不变式：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity)：</p><ol><li><strong>容量(capacity)</strong>：表示Buffer最大数据容量，capacity不能为负，并且创建后不能更改</li><li><strong>限制(limit)</strong>：第一个不应该读取或写入的数据的索引，即位于limit后的数据不可读写。limit不能为负，并且不能大于其容量capacity</li><li><strong>位置(position)</strong>：下一个要读取或写入的数据的索引。position不能为负，并且不能大于其限制limit</li><li>标记(mark)与重置(reset)：标记是一个索引，通过Buffer中的mark()方法指定Buffer中一个特定的position，之后可以通过调用reset()方法恢复到这个position<br><img src="%E7%BC%93%E5%86%B2%E5%8C%BA%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="缓冲区基本操作示意图"></li></ol></li><li><p>常用方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>Buffer clear()</strong></td><td><strong>清空缓冲区并返回对缓冲区的引用</strong></td></tr><tr><td><strong>Buffer flip()</strong></td><td><strong>将缓冲区的界限设置为当前位置,并将当前位置重置为0</strong></td></tr><tr><td>int capacity()</td><td>返回Buffer的capacity大小</td></tr><tr><td>boolean hasRemaining()</td><td>判断缓冲区中是否还有元素</td></tr><tr><td>int limit()</td><td>返回Buffer的界限(limit)的位置</td></tr><tr><td>Buffer limit(int n)</td><td>将设置缓冲区界限为n,并返回一个具有新limit的缓冲区对象</td></tr><tr><td>Buffer mark()</td><td>对缓冲区设置标记</td></tr><tr><td>int position()</td><td>返回缓冲区的当前位置position</td></tr><tr><td>Buffer position(int n)</td><td>将设置缓冲区的当前位置为n,并返回修改后的Buffer对象</td></tr><tr><td>int remaining()</td><td>返回position和limit之间的元素个数</td></tr><tr><td>Buffer reset()</td><td>将位置position转到以前设置的mark所在的位置</td></tr><tr><td>Buffer rewind()</td><td>将位置设为为0,取消设置的mark</td></tr></tbody></table></li><li><p>数据操作：Buffer所有子类提供了两个用于数据操作的方法——get()与put()方法</p><ul><li>获取Buffer中的数据<ol><li>get()：读取单个字节</li><li>get(byte[] dst)：批量读取多个字节到dst中</li><li>get(int index)：读取指定索引位置的字节(不会移动position)</li></ol></li><li>放入数据到Buffer中<ol><li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li><li>put(byte[]src)：将src中的字节写入缓冲区的当前位置</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动position)</li></ol></li></ul></li><li><p>直接与非直接缓冲区</p><ul><li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java虚拟机会尽最大努力直接在此缓冲区上执行本机I/0操作。也就是说，在每次调用基础操作系统的一个本机I/0操作之前(或之后)，虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中(或从中间缓冲区中复制内容)</li><li>直接字节缓冲区可以通过调用此类的<strong>allocateDirect()</strong>工厂方法来创建。<strong>此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/0操作影响的大型、持久的缓冲区。-般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们</li><li>直接字节缓冲区还可以通过<strong>FileChannel的map()方法</strong>将文件区域直接映射到内存中来创建。该方法返回<strong>MappedByteBuffer</strong>。Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常</li><li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其<strong>isDirect()</strong>方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理<br><img src="%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="非直接缓冲区示意图"><br><img src="%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="直接缓冲区示意图"></li></ul></li></ul><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><ul><li><p>介绍：由java.nio.channels包定义。Channel表示I0源与目标打开的连接。Channel类似于传统的”流”。只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互</p></li><li><p>主要实现类</p><ol><li>FileChannel：用于读取、写入、映射和操作文件的通道</li><li>DatagramChannel：通过UDP读写网络中的数据通道</li><li>SocketChannel：通过TCP读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个Socke tChannel</li></ol></li><li><p>获取通道：</p><ol><li>对支持通道的对象调用getChannel()方法。支持通道的类包括FileInputStream、FileOutputStream、RandomAccessFile、DatagramSocket、Socket、ServerSocket</li><li>使用Files类的静态方法newByteChannel()获取字节通道、或者通过通道的静态方法open()打开并返回指定通道</li></ol></li><li><p>数据传输：</p><ol><li><p>将Buffer数据写入Channel：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> writeLen = channel.write(buffer);</span><br></pre></td></tr></table></figure></li><li><p>从Channel读取数据到Buffer</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readLen = channel.read(buffer);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>分散与聚集</p><ul><li>分散读取(Scattering Reads)：从Channel中读取的数据”分散”到多个Buffer中<br><strong>注意：按照缓冲区的顺序,从Channel中读取的数据依次将Buffer填满</strong></li><li>聚集写入(Gathering Writes)：将多个Buffer中的数据”聚集”到Channel<br><strong>注意：按照缓冲区的顺序,写入position和limit之间的数据到Channel</strong></li></ul></li><li><p>数据通道相互传输：将数据从源通道传输到其他Channel中</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toChannel.transferFrom(fromChannel, count, position);</span><br><span class="line">fromChannel.transforTo(position, count, toChannel);</span><br></pre></td></tr></table></figure></li><li><p>FileChannel的常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>int read(ByteBuffer dst)</strong></td><td>从Channel中读取数据到ByteBuffer</td></tr><tr><td><strong>long read(ByteBuffer[] dsts)</strong></td><td>将Channel中的数据”分散”到ByteBuffer[]</td></tr><tr><td><strong>int write(ByteBuffer src)</strong></td><td>将ByteBuffer中的数据写入到Channel</td></tr><tr><td><strong>long write(ByteBuffer[] srcs)</strong></td><td>将ByteBuffer[]中的数据”聚集”到Channel</td></tr><tr><td>long position()</td><td>返回此通道的文件位置</td></tr><tr><td>FileChannel position(long p)</td><td>设置此通道的文件位置</td></tr><tr><td>long size()</td><td>返回此通道的文件的当前大小</td></tr><tr><td>FileChannel truncate(long s)</td><td>将此通道的文件截取为给定大小</td></tr><tr><td>void force(boolean metaData)</td><td>强制将所有对此通道的文件更新写入到存储设备中</td></tr></tbody></table></li></ul><h2 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h2><ul><li><p>介绍：选择器(Selector)是SelectableChannle对象的多路复用器，<strong>Selector可以同时监控多个SelectableChannel的I0状况，也就是说，利用Selector可使一个单独的线程管理多个Channel。Selector是非阻塞I0的核心</strong></p></li><li><p>常见方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Set&lt;SelectionKey&gt; keys()</td><td>所有的SelectionKey集合。代表注册在该Selector上的Channel</td></tr><tr><td>selectedKeys()</td><td>被选择的SelectionKey集合。返回此Selector的已选择键集</td></tr><tr><td>int select()</td><td>监控所有注册的Channel,当它们中间有需要处理的I0操作时,该方法返回,并将对应得的SelectionKey加入被选择的SelectionKey集合中,该方法返回这些Channel的数量</td></tr><tr><td>int select(long timeout)</td><td>可以设置超时时长的select()操作</td></tr><tr><td>int selectNow()</td><td>执行一个立即返回的select()操作,该方法不会阻塞线程</td></tr><tr><td>Selector wakeup()</td><td>使一个还未返回的select()方法立即返回</td></tr><tr><td>void close()</td><td>关闭该选择器</td></tr></tbody></table></li><li><p>SelectableChannle继承结构<br><img src="SelectableChannle%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="SelectableChannle继承结构"></p></li><li><p>选择器使用：</p><ul><li>创建Selector：通过调用Selector.open()方法创建一个Selector</li><li>向选择器注册通道：SelectableChannel.register(Selector sel,int ops)<ul><li>当调用register()向选择器注册通道时，选择器对通道的监听事件通过第二个参数ops指定</li><li>可以监听的事件类型(<strong>可使用SelectionKey的四个常量表示</strong>)：<ol><li>读：SelectionKey.OP_READ(1)</li><li>写：SelectionKey.OP_WRITE(4)</li><li>连接：SelectionKey.OP_CONNECT(8)</li><li>接收：SelectionKey.OP_ ACCEPT(16)</li></ol></li><li>若注册时不止监听一个事件，则可以使用”位或”操作符连接</li></ul></li></ul></li><li><p>SelectionKey：</p><ul><li><p>介绍：表示SelectableChannel和Selector之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作</p></li><li><p>常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int interestOps()</td><td>获取感兴趣事件集合</td></tr><tr><td>int readyOps()</td><td>获取通道已经准备就绪的操作的集合</td></tr><tr><td>SelectableChannel channel()</td><td>获取注册通道</td></tr><tr><td>Selector selector()</td><td>返回选择器</td></tr><tr><td>boolean isReadable()</td><td>检测Channal中读事件是否就绪</td></tr><tr><td>boolean isWritable()</td><td>检测Channal中写事件是否就绪</td></tr><tr><td>boolean isConnectable()</td><td>检测Channel中连接是否就绪</td></tr><tr><td>boolean isAcceptable()</td><td>检测Channel中接收是否就绪</td></tr></tbody></table></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>管道(pipe)：NIO管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取<br><img src="%E7%AE%A1%E9%81%93%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="管道数据连接示意图"></p></li><li><p>Path与Paths：</p><ul><li><p>java.nio.file.Path接口代表-一个平台无关的平台路径，描述了目录结构中文件的位置</p></li><li><p>Paths提供get()方法用来获取Path对象：<br>Path get(String first, String … more)：用于将多个字符串串连成路径</p></li><li><p>Path常用方法:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean endsWith(String path)</td><td>判断是否以path路径结束</td></tr><tr><td>boolean startsWith(String path)</td><td>判断是否以path路径开始</td></tr><tr><td>boolean isAbsolute()</td><td>判断是否是绝对路径</td></tr><tr><td>Path getFileName()</td><td>返回与调用Path对象关联的文件名</td></tr><tr><td>Path getName(int idx)</td><td>返回的指定索引位置idx的路径名称</td></tr><tr><td>int getNameCount()</td><td>返回Path根目录后面元素的数量</td></tr><tr><td>Path getParent()</td><td>返回Path对象包含整个路径,不包含Path对象指定的文件路径</td></tr><tr><td>Path getRoot()</td><td>返回调用Path对象的根路径</td></tr><tr><td>Path resolve(Path p)</td><td>将相对路径解析为绝对路径</td></tr><tr><td>Path toAbsolutePath()</td><td>作为绝对路径返回调用Path对象</td></tr><tr><td>String toString()</td><td>返回调用Path对象的字符串表示形式</td></tr></tbody></table></li></ul></li><li><p>Files：</p><ul><li><p>java.nio.file.Files用于操作文件或目录的工具类</p></li><li><p>Files常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Path copy(Path src, Path dest, CopyOption … how)</td><td>文件的复制</td></tr><tr><td>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)</td><td>创建一个目录</td></tr><tr><td>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)</td><td>创建一个文件</td></tr><tr><td>void delete(Path path)</td><td>删除一个文件</td></tr><tr><td>Path move(Path src, Path dest, CopyOption … how)</td><td>将src移动到dest位置</td></tr><tr><td>long size(Path path)</td><td>返回path指定文件的大小</td></tr></tbody></table></li><li><p>Files常用方法(判断)：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean exists(Path path, LinkOption … opts)</td><td>判断文件是否存在</td></tr><tr><td>boolean isDirectory(Path path, LinkOption … opts)</td><td>判断是否是目录</td></tr><tr><td>boolean isExecutable(Path path)</td><td>判断是否是可执行文件</td></tr><tr><td>boolean isHidden(Path path)</td><td>判断是否是隐藏文件</td></tr><tr><td>boolean isReadable(Path path)</td><td>判断文件是否可读</td></tr><tr><td>boolean isWritable(Path path)</td><td>判断文件是否可写</td></tr><tr><td>boolean notExists(Path path, LinkOption … opts)</td><td>判断文件是否不存在</td></tr><tr><td>public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path, Class&lt;A&gt; type, LinkOption … options)</td><td>获取与path指定的文件相关联的属性</td></tr></tbody></table></li><li><p>Files常用方法(操作内容)：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>SeekableByteChannel newByteChannel(Path path, OpenOptin … how)</td><td>获取与指定文件的连接,how指定打开方式</td></tr><tr><td>DirectoryStream newDirectoryStream(Path path)</td><td>打开path指定的目录</td></tr><tr><td>InputStream newInputStream(Path path, OpenOptin … how)</td><td>获取InputStream对象</td></tr><tr><td>OutputStream newOutputStream(Path path, OpenOptin … how)</td><td>获取OutputStream对象</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/09/26/ProgrammingLanguage/Java/JVM/"/>
      <url>/2020/09/26/ProgrammingLanguage/Java/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#JVM体系结构概述">JVM体系结构概述</a></li><li><a href="#堆体系结构概述">堆体系结构概述</a></li><li><a href="#堆参数调优">堆参数调优</a></li></ul><a id="more"></a><h2 id="JVM体系结构概述"><a href="#JVM体系结构概述" class="headerlink" title="JVM体系结构概述"></a>JVM体系结构概述</h2><ul><li><p>JVM位置：运行与操作系统之上(可以认为是一种中间件)，与硬件没有直接的交互<br><img src="JVM%E4%BD%8D%E7%BD%AE.png" alt="JVM位置"></p></li><li><p>JVM结构<br><img src="JVM%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="JVM结构示意图"></p><ol><li><p>类装载器ClassLoader</p><ul><li><p>作用：负责加载class文件，<strong>class文件在文件开头有特定的文件标示</strong>，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定<br><img src="%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类装载器工作示意图"></p></li><li><p>种类：</p><ol><li>虚拟机自带的加载器<ol><li>启动类加载器(Bootstrap) C++($JAVA_HOME/jre/lib/rt.jar)</li><li>扩展类加载器(Extension) Java($JAVA_HOME/jre/lib/ext/*.jar)</li><li>应用程序类加载器(AppClassLoader)，Java中也叫系统类加载器(System Class Loader)，加载当前应用的classpath的所有类</li></ol></li><li>用户自定义加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式<br><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="类加载器继承图"></li></ol></li><li><p>种类案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// Object定义在rt.jar中,采用C++的Bootstrap加载器</span></span><br><span class="line">System.out.println(obj.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">MyObject mObj = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">// MyObject是用户自定义类,采用系统类加载器AppClassLoader</span></span><br><span class="line">System.out.println(mObj.getClass().getClassLoader());</span><br><span class="line"><span class="comment">// sun.misc.Launcher$ExtClassLoader@61bbe9ba</span></span><br><span class="line"><span class="comment">// 系统类加载器的父类即为扩展类加载器ExtClassLoader</span></span><br><span class="line">System.out.println(mObj.getClass().getClassLoader().getParent());</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 扩展类加载器ExtClassLoader的父类即为C++的Bootstrap加载器</span></span><br><span class="line">System.out.println(mObj.getClass().getClassLoader().getParent().getParent());</span><br></pre></td></tr></table></figure></li><li><p>类加载机制(双亲委派)：一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象(也防止用户自定义了系统预先定义的类[包名和类名完全相同]造成的类加载冲突——编译器不报错,运行时报错)</p></li></ul></li><li><p>Execution Engine：执行引擎负责解释命令，提交操作系统执行</p></li><li><p>Native Interface(本地接口)：<br> 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序(Java诞生的时候是C/C++横行的时候,要想立足,必须能够调用C/C++程序)，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies<br> 目前该方法使用得越来越少了，除非是与硬件有关的应用，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信、Web Service等</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">  t1.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 同一个thread不能start()两次</span></span><br><span class="line">  <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">  group.add(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">        group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Native Method Stack：登记native方法，在Execution Engine执行时加载本地方法库</p></li><li><p>PC寄存器(类似汇编)：<br> 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向下一条指令的地址,也即将要执行的指令代码)，由执行引擎读取下一条指令<br> 这块内存区域(空间)很小，几乎可以忽略不记，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令<br> 如果执行的是一个Native方法，那这个计数器是空的<br> 用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OOM：Out Of Memory)错误</p></li><li><p>Method Area(方法区)：<br> 是供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容<br> 上面讲的是规范，在不同虚拟机中实现是不一样的，最典型的就是Java7的永久代(PermGen space)和Java8的元空间(Metaspace)<br> 实例变量存在堆内存中，和方法区无关</p></li><li><p>Stack(栈)：</p><ul><li>介绍：栈也叫栈内存，主管Java程序的运行。在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的</strong>。<strong>8种基本类型的变量、对象的引用变量、实例方法都是在函数的栈内存中分配</strong></li><li>栈存储什么(主要保存3类数据)：<ol><li>本地变量(Local Variables)：输入参数、输出参数以及方法内的变量</li><li>栈操作(Operand Stack)：记录出栈、入栈的操作</li><li>栈帧数据(Frame Data)：包括类文件、方法等</li></ol></li><li>栈运行原理：<br>栈中的数据都是以栈帧(Stack Frame)格式存在，栈帧是一个内存区块、一个数据集、一个有关方法(Method)和运行期数据的数据集<br>当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中；A方法又调用了B方法，于是产生的栈帧F2也被压入栈；B方法又调用了C方法，于是产生的栈帧F3也被压入栈…..方法相继执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……遵循“先进后出”/“后进先出”原则<br><strong>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。<strong>栈的大小和具体JVM的实现有关，通常在256K~756K之间，约等于1Mb左右</strong><br><img src="Java%E6%A0%88%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java栈示意图"></li></ul></li></ol></li><li><p>栈/堆/方法区的交互关系<br>HotSpot(Java8)是使用指针的方式来访问对；Java堆中会存在访问<strong>类元数据</strong>的地址；reference存储的就是对象的地址<br><img src="%E6%A0%88%E5%A0%86%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="栈/堆/方法区的交互关系"></p></li></ul><h2 id="堆体系结构概述"><a href="#堆体系结构概述" class="headerlink" title="堆体系结构概述"></a>堆体系结构概述</h2><ul><li>Heap堆<ul><li>介绍：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行</li><li>组成部分(<strong>逻辑上划分</strong>)：<ol><li>Young Generation Space(新生区 Young/New)</li><li>Tenure Generation Space(老年区 Old/Tenure)</li><li>Permanent Space(永久区 Perm)<br><img src="%E5%A0%86%E5%86%85%E5%AD%98%E9%80%BB%E8%BE%91%E5%88%92%E5%88%86.png" alt="堆内存逻辑划分"></li></ol></li></ul></li><li>GC过程：<ol><li>新生区是类的诞生、成长和消亡的区域，一个类在这里产生、应用、最后被垃圾回收器收集结束生命。新生区又分为两部分：伊甸区(Eden Space)和幸存者区(Survivor pace)，所有的类都是在伊甸区被new创建出来的。幸存区有两个：0区(Survivor 0 Space)和1区(Survivor 1 Space)</li><li>当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC)，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了再移动到老年区</li><li>若老年区也满了，那么这时候将发生Major GC(Full GC)进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常(OutOfMemoryError)</li></ol></li><li>Minor GC过程(复制 -&gt; 清空 -&gt; 互换)：<br><img src="GC%E8%A7%92%E5%BA%A6%E5%A0%86%E7%9A%84%E5%88%86%E7%B1%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="GC角度堆的分类示意图"><ol><li><strong>Eden、Survivor From区复制到Survivor To区，年龄+1</strong>：首先，当Eden区满的时候会触发首次GC——把还活着的对象拷贝到Survivor From区。当Eden区再次触发GC时会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域(如果有对象的年龄已经达到了老年的标准则赋复制老年区)，同时把这些对象的年龄+1</li><li><strong>清空Eden、Survivor From区</strong>：然后，清空Eden和Survivor From区中的对象</li><li><strong>Survivor To区和Survivor From区互换</strong>：最后，Survivor To和Survivor From互换，原Survivor To区成为下一次GC时的Survivor From区。部分对象会在From和To区域中复制来复制去，如此交换15次(由JVM参数MaxTenuringThreshold决定,默认为15)最终如果还是存活，就存入到老年区</li></ol></li><li>方法区(Method Area)<ul><li>介绍：实际而言，方法区(Method Area)和堆一样是各个线程共享的内存区域，它用于存储虚拟机加载的类信息、普通常量、静态常量和编译器编译后的代码等。<strong>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开</strong></li><li>方法区的实现：对于HotSpot虚拟机，很多开发者习惯将方法区称之为永久代(Parmanent Gen)，但严格本质上说两者不同，永久代是方法区的一个实现。jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走(永久带是1.7版本的叫法,1.8则为元空间Metaspace)<br><img src="Java7%E5%A0%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java7堆体系结构示意图"></li><li>Java7永久区(7及之前)：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class、Interface的元数据，也就是说它存储的是运行环境必须的类信息。被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存</li></ul></li></ul><h2 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h2><ul><li><p>Java堆：<br><img src="Java7%E5%A0%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java7堆示意图"><br><img src="Java8%E5%A0%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java8堆示意图"></p><ol><li>在Java8中永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似</li><li>元空间与永久代之间最大的区别：<strong>永久带使用的JVM的堆内存；Java8以后的元空间并不在虚拟机中，而是使用本机物理内存</strong></li><li>默认情况下，元空间的大小仅受本地内存限制。类的元数据放入Native Memory，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制而由系统的实际可用空间来控制</li></ol></li><li><p>堆参数(在VM options中指定)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-Xms</td><td>设置JVM初始内存大小,默认为物理内存的1/64</td></tr><tr><td>-Xmx</td><td>设置JVM最大分配内存,默认为物理内存的1/4</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC处理日志</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回Java虚拟机试图使用的最大内存量</span></span><br><span class="line"><span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="comment">// 返回Java虚拟机中的内存总量</span></span><br><span class="line"><span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">System.out.println(<span class="string">"-Xmx:maxMemory = "</span> + maxMemory + <span class="string">"Byte , "</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">System.out.println(<span class="string">"-Xms:totalMemory = "</span> + totalMemory + <span class="string">"Byte , "</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">// byte[] bytes = new byte[40 * 1024 * 1024];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// VM Options: -Xms8m -Xmx8m -XX:+PrintGCDetails</span></span><br><span class="line">String str = <span class="string">"www.sobxiong.com"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">99999999</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 1508K-&gt;496K(2048K)] 1508K-&gt;535K(7680K), 0.0017728 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 1882K-&gt;505K(2048K)] 1921K-&gt;797K(7680K), 0.0053175 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 2041K-&gt;352K(2048K)] 3331K-&gt;1891K(7680K), 0.0014598 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span></span><br><span class="line"><span class="comment">[Full GC (Ergonomics) [PSYoungGen: 1488K-&gt;0K(2048K)] [ParOldGen: 5531K-&gt;1366K(5632K)] 7019K-&gt;1366K(7680K), [Metaspace: 3036K-&gt;3036K(1056768K)], 0.0054889 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 1074K-&gt;96K(2048K)] 4436K-&gt;3458K(7680K), 0.0015233 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 96K-&gt;96K(2048K)] 3458K-&gt;3458K(7680K), 0.0017007 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment">[Full GC (Allocation Failure) [PSYoungGen: 96K-&gt;0K(2048K)] [ParOldGen: 3362K-&gt;3363K(5632K)] 3458K-&gt;3363K(7680K), [Metaspace: 3055K-&gt;3055K(1056768K)], 0.0047922 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3363K-&gt;3363K(7680K), 0.0009790 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line"><span class="comment">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 3363K-&gt;3344K(5632K)] 3363K-&gt;3344K(7680K), [Metaspace: 3055K-&gt;3055K(1056768K)], 0.0045256 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment">PSYoungGen      total 2048K, used 66K [0x00000007bfd80000, 0x00000007c0000000, 0x00000007c0000000)</span></span><br><span class="line"><span class="comment">  eden space 1536K, 4% used [0x00000007bfd80000,0x00000007bfd90978,0x00000007bff00000)</span></span><br><span class="line"><span class="comment">  from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000)</span></span><br><span class="line"><span class="comment">  to   space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000)</span></span><br><span class="line"><span class="comment">ParOldGen       total 5632K, used 3344K [0x00000007bf800000, 0x00000007bfd80000, 0x00000007bfd80000)</span></span><br><span class="line"><span class="comment">  object space 5632K, 59% used [0x00000007bf800000,0x00000007bfb44040,0x00000007bfd80000)</span></span><br><span class="line"><span class="comment">Metaspace       used 3109K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 338K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">  at java.util.Arrays.copyOf(Arrays.java:3332)</span></span><br><span class="line"><span class="comment">  at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)</span></span><br><span class="line"><span class="comment">  at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674)</span></span><br><span class="line"><span class="comment">  at java.lang.StringBuilder.append(StringBuilder.java:208)</span></span><br><span class="line"><span class="comment">  at com.xiong.jvm.Test2.main(Test2.java:12)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是立刻执行,禁止使用</span></span><br><span class="line"><span class="comment">// System.gc();</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2020/09/18/ProgrammingLanguage/Java/JUC/"/>
      <url>/2020/09/18/ProgrammingLanguage/Java/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#JUC是什么">JUC是什么</a></li><li><a href="#Lock接口">Lock接口</a></li><li><a href="#线程间通信">线程间通信</a></li><li><a href="#线程间定制化调用通信">线程间定制化调用通信</a></li><li><a href="#线程八锁">线程八锁</a></li><li><a href="#线程不安全集合">线程不安全集合</a></li><li><a href="#Callable接口">Callable接口</a></li><li><a href="#JUC辅助类">JUC辅助类</a></li><li><a href="#BlockingQueue阻塞队列">BlockingQueue阻塞队列</a></li><li><a href="#ThreadPool线程池">ThreadPool线程池</a></li><li><a href="#Java8流式计算">Java8流式计算</a></li><li><a href="#Java8分支合并">Java8分支合并</a></li><li><a href="#异步回调">异步回调</a></li><li><a href="#volatile">volatile</a></li><li><a href="#CAS">CAS</a></li><li><a href="#值传递和引用传递">值传递和引用传递</a></li><li><a href="#Java锁的类型">Java锁的类型</a></li><li><a href="#死锁及定位分析">死锁及定位分析</a></li></ul><a id="more"></a><h2 id="JUC是什么"><a href="#JUC是什么" class="headerlink" title="JUC是什么"></a>JUC是什么</h2><ul><li><p>JUC介绍：JDK1.5时Java引入的并发编程工具包——java.util.concurrent</p></li><li><p>基础知识回顾：</p><ul><li><p>进程/线程是什么：</p><ul><li>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元</li><li>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度</li></ul></li><li><p>进程/线程例子：</p><ul><li>进程：QQ.ext、word.exe</li><li>线程：word检查拼写、word容灾备份</li></ul></li><li><p>线程的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW, <span class="comment">// 创建</span></span><br><span class="line">  RUNNABLE, <span class="comment">// 准备就绪(还需等待OS),Thread实例start()后并不是马上运行,只是进入就绪状态,等待OS</span></span><br><span class="line">  BLOCKED, <span class="comment">// 阻塞</span></span><br><span class="line">  WAITING, <span class="comment">// 等待(一直等下去——不见不散)</span></span><br><span class="line">  TIMED_WAITING, <span class="comment">// 等待(有时限的等待——过时不候)</span></span><br><span class="line">  TERMINATED; <span class="comment">// 终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>wait/sleep的区别：</p><ul><li>wait/sleep都可以使当前线程暂停</li><li>wait放开手睡眠，放开手里的锁</li><li>sleep握紧手睡眠，唤醒后手里还有锁</li></ul></li><li><p>并发/并行各自都是什么：</p><ul><li>并发：同一时刻多个线程在访问同一个资源(例子：抢车票)</li><li>并行：多项工作同时执行，之后在汇合(例子：泡脚玩手机)</li></ul></li></ul></li></ul><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><ul><li><p>复习Synchronized：</p><ul><li><p><strong>多线程口诀1、2</strong>：</p><ul><li>高内聚低耦合</li><li>线程、操作、资源类</li></ul></li><li><p>实现步骤：</p><ol><li><p>创建资源类</p></li><li><p>资源类里创建同步方法(代码块)</p></li><li><p>创建线程，访问资源</p></li></ol></li><li><p>卖票实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：三个售票员,卖100张票</span></span><br><span class="line"><span class="comment">* 多线程编程的企业级套路 + 模版</span></span><br><span class="line"><span class="comment">* 1、高内聚低耦合</span></span><br><span class="line"><span class="comment">* 2、线程 操作(对外暴露的调用方法) 资源类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程不能直接继承Thread类,因为Java是单继承,资源宝贵,要使用接口方式</span></span><br><span class="line">    <span class="comment">// 如果方法体简单,可以不用继承Runnable接口,而直接采用匿名内部类/lambda表达式</span></span><br><span class="line">    <span class="comment">// 创建线程要使用两个参数Thread(runnable, name)的方式</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t卖出第"</span> + (number--) + <span class="string">"张票\t,还剩下"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Lock接口：</p><ul><li><p>Lock介绍(摘录自JDK1.8)：Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects —— 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象</p></li><li><p>Lock的常用实现类ReentrantLock(可重入锁)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock使用模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedResource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * synchronized与Lock的区别</span></span><br><span class="line"><span class="comment">  * 1、首先synchronized是java内置关键字,在jvm层面;Lock是个java类</span></span><br><span class="line"><span class="comment">  * 2、synchronized无法判断是否获取锁的状态,Lock可以判断是否获取到锁</span></span><br><span class="line"><span class="comment">  * 3、synchronized会自动释放锁(a:线程执行完同步代码会释放锁;b:线程执行过程中发生异常会释放锁);Lock需在finally中手动释放锁(unlock()方法释放锁),否则容易造成线程死锁</span></span><br><span class="line"><span class="comment">  * 4、用synchronized关键字的两个线程1和线程2,如果当前线程1获得锁,线程2线程等待。如果线程1阻塞,线程2则会一直等待下去;而Lock锁就不一定会等待下去,如果尝试获取不到锁,线程可以不用一直等待就结束了</span></span><br><span class="line"><span class="comment">  * 5.synchronized的锁可重入、不可中断、非公平,而Lock锁可重入、可判断、可公平(默认非公平,二者皆可)</span></span><br><span class="line"><span class="comment">  * 6.Lock锁适合大量同步的代码的同步问题,synchronized锁适合代码少量的同步问题</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">competitionMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// block until condition holds</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lock方式卖票实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t卖出第"</span> + (number--) + <span class="string">"张票\t,还剩下"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul><li><p>题目：两个线程来操作初始值为零的一个变量，实现一个线程对该变量加1,另一个线程对该变量减1。实现交替10个轮次,变量初始值为0</p></li><li><p>线程间通信：</p><ol><li>生产者/消费者模型</li><li>通知等待唤醒机制</li></ol></li><li><p><strong>多线程口诀3</strong>：</p><ol><li>判断</li><li>干活</li><li>通知</li></ol></li><li><p>老版本synchronized实现：</p><ul><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断</span></span><br><span class="line">    <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、干活</span></span><br><span class="line">    number++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t生产,剩余"</span> + number);</span><br><span class="line">    <span class="comment">// 3、通知</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断</span></span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、干活</span></span><br><span class="line">    number--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t消费,剩余"</span> + number);</span><br><span class="line">    <span class="comment">// 3、通知</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：两个线程来操作初始值为零的一个变量,实现一个线程对该变量加1,另一个线程对该变量减1;实现交替10个轮次,变量初始值为0</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cake cake = <span class="keyword">new</span> Cake();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cake.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cake.decrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果：符合要求</p></li><li><p>如果换成4个线程(2消费者,2生产者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只改变main</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Cake cake = <span class="keyword">new</span> Cake();</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ProducerB"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ConsumerB"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果：出现错误，有可能生产出大于1的cake来</p></li><li><p>原因：换成4个线程会导致错误——虚假唤醒，因为在Java多线程判断时，不能用if。错误出在了判断上面：如果突然有一个增加cake的线程进入到if里面了，但突然中断了并交出控制权。等到唤醒后由于是if，不需要再次进行验证，而是直接走下去了，所以进行了错误的增加<br><img src="%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚假唤醒示意图"></p></li><li><p>解决方法：把所有的资源类的increment()和decrement()方法中的if判断变为while判断</p></li></ul></li><li><p><strong>多线程口诀4</strong>：注意多线程之间的虚假唤醒</p></li><li><p>新版本Lock实现：</p><ul><li><p>新老版本对标：</p><ol><li>synchronized - Lock</li><li>wait - await</li><li>notify - signal</li></ol></li><li><p>Lock示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t生产,剩余"</span> + number);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      number++;</span><br><span class="line">      <span class="comment">// 3、通知</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t消费,剩余"</span> + number);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      number--;</span><br><span class="line">      <span class="comment">// 3、通知</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：两个线程来操作初始值为零的一个变量,实现一个线程对该变量加1,另一个线程对该变量减1;实现交替10个轮次,变量初始值为0</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">* 3、多线程交互中,必须要防止多线程的虚假唤醒,也即(判断只能用while,不能用if)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAwaitSignal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cake1 cake = <span class="keyword">new</span> Cake1();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerB"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerB"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程间定制化调用通信"><a href="#线程间定制化调用通信" class="headerlink" title="线程间定制化调用通信"></a>线程间定制化调用通信</h2><ul><li><p>题目：多线程之间按顺序调用，实现A -&gt; B -&gt; C，三个线程启动,要求如下：AAAAA打印5次，BBBBB打印10次，CCCCC打印15次，以上操作进行10轮</p></li><li><p><strong>多线程口诀5</strong>：标志位</p></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1 -&gt; A, 2 -&gt; B, 3 -&gt; C</span></span><br><span class="line">  <span class="comment">// 一把锁lock</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 三把钥匙condition</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionA = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionB = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">        conditionA.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"AAAAA ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">2</span>;</span><br><span class="line">      conditionB.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">        conditionB.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"BBBBB ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">3</span>;</span><br><span class="line">      conditionC.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">        conditionC.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"CCCCC ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">1</span>;</span><br><span class="line">      conditionA.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：多线程之间按顺序调用,实现A -&gt; B -&gt; C,三个线程启动,要求如下：AAAAA打印5次,BBBBB打印10次,CCCCC打印15次,以上操作进行10轮</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">* 3、多线程交互中,必须要防止多线程的虚假唤醒,也即(判断只能用while,不能用if)</span></span><br><span class="line"><span class="comment">* 4、标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOrderAccess</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromA();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromB();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromC();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul><li><p>八锁示例：</p><ul><li><p>情况1(标准访问)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、标准访问,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock8</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况2(其一线程sleep)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、邮件方法暂停4秒,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况3(新增一个普通方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、在2的基础上,新增并使用一个普通方法hello(),请问先打印邮件还是hello? hello</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.hello();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况4(两个对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、两部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况5(改为静态同步方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、两个静态同步方法,同一部手机,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况6(两个对象调用静态同步方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、两个静态同步方法,两部手机,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况7(一个静态同步方法,一个普通同步方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、一个普通同步方法,一个静态同步方法,一部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>情况8(一个静态同步方法,一个普通同步方法,两个对)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8、一个普通同步方法,一个静态同步方法,两部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>八锁分析：</p><ul><li>情况1、2：如果一个对象有多个synchronized方法，某个时刻内只要有一个线程去调用当前对象的一个synchronized方法，那么其它线程只能等待。换句话说，某个时刻内只能有唯一一个线程去访问这些synchronized方法。锁作用的是当前对象this，this被锁定后其它的线程都不能进入到当前对象的其它的synchronized方法(情况1、2都进入了sendEmail()方法,因此不响应sendMessage()方法)</li><li>情况3、4：普通方法和同步锁无关，一个线程调用了synchronized方法，另一个线程可以同时调用普通方法；当换成两个对象后，synchronized锁的是对象实例，而当前有两个实例，锁的就不是同一把锁了，因此sendMessage先打印</li><li>情况5、6：对于静态同步方法，锁是当前类的Class对象，对于同一个Phone类锁是相同的(Phone.class)，因此进入sendEmail()方法后不会响应sendMessage()方法，而是等待sendEmail()方法执行完毕</li><li>情况7、8：对于普通同步方法和静态同步方法，他们锁的对象不同，普通同步方法锁的是当前对象实例(Phone的一个实例对象)，而静态同步方法锁的是当前类的Class对象(Phone.class)。他们锁的对象不同，不会相互影响，因此先打印sendMessage</li></ul></li><li><p><strong>线程八锁总结</strong>：</p><ul><li>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：<ul><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，锁是当前类的Class对象</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ul></li><li>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待已获取锁的方法释放锁后才能获取锁</li><li>其他实例对象的普通同步方法跟当前实例对象的普通同步方法用的是不同的锁(不同的实例对象)，所以无须等待当前实例对象已获取锁的普通同步方法释放锁就可以获取他们自己的锁</li><li>所有静态同步方法用的是同一把锁——类对象本身，普通同步方法的锁和静态同步方法的锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的。但一旦一个静态同步方法获取锁后，其他静态同步方法都必须等待该方法释放锁后才能获取锁(而不管是同一个实例对象的静态同步方法之间，还是不同实例对象的静态同步方法之间，只要它们是同一个类的实例对象)</li></ul></li></ul><h2 id="线程不安全集合"><a href="#线程不安全集合" class="headerlink" title="线程不安全集合"></a>线程不安全集合</h2><ul><li><p>线程不安全的集合</p><ul><li><p>ArrayList</p><ul><li><p>情况1：3个线程同时读写ArrayList(结果：运行基本不报错,但是会出现List中有时内容为null或者集合元素个数不等于3的情况)</p></li><li><p>情况2：30个线程同时读写ArrayList(结果：运行报错——java.util.ConcurrentModificationException并发修改异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> or <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(list);</span><br><span class="line">    &#125;, <span class="string">"list"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出错原因：ArrayList本身就是线程不安全的(为了性能考虑,不加锁性能提升但会出错误)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方案：</p><ol><li><p>改用Vector(线程安全,加了synchronized,加锁数据一致但性能下降;性能较差,不要使用)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">  elementData[elementCount++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Collections工具类<br> 少量数据可以使用，通过在ArrayList外包装一层同步机制<br> <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code></p></li><li><p>CopyOnWriteArrayList(推荐使用)<br> CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)<br> 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器是一种读写分离的思想，读和写不同的容器  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="comment">// copy原始数据</span></span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    <span class="comment">// 引用更新</span></span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>HashSet(HashSet底层就是HashMap)</p><ul><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new HashSet&lt;&gt;()</span></span><br><span class="line">  <span class="comment">// Collections.synchronizedSet(new HashSet&lt;&gt;())</span></span><br><span class="line">  <span class="comment">// new CopyOnWriteArraySet&lt;&gt;()</span></span><br><span class="line">  Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(set);</span><br><span class="line">    &#125;, <span class="string">"set"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方案：</p><ol><li><p>Collections工具类<br> <code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></p></li><li><p>CopyOnWriteArraySet<br> 底层还是CopyOnWriteArrayList</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates an empty set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>HashMap</p><ul><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new HashMap&lt;&gt;()</span></span><br><span class="line">  <span class="comment">// Collections.synchronizedMap(new HashMap&lt;&gt;())</span></span><br><span class="line">  <span class="comment">// new ConcurrentHashMap&lt;&gt;()</span></span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(map);</span><br><span class="line">    &#125;, <span class="string">"map"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方案：</p><ol><li>Collections工具类<br> <code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code></li><li>ConcurrentHashMap</li></ol></li></ul></li></ul></li></ul><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><ul><li><p>获得多线程的方法有几种?</p><ol><li>继承Thread类(不建议使用)</li><li>实现Runnale接口</li><li>实现Callable接口</li><li>从线程池获取</li></ol></li><li><p>Callable是什么：一个JDK1.5推出的线程接口，比Runnable更强大。是一个函数式接口，可用作lambda表达式。能在线程执行完成后返回结果(应用场景一般在于批处理业务,如转账时需要返回结果的状态码,代表本次操作的成功与否)</p></li><li><p>与Runnable的区别：</p><ol><li>是否有返回值</li><li>是否会抛出异常</li><li>落地方法不同(run()/call())</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>怎么使用：</p><ol><li><p><del>直接替换runnable：不可行，Thread的构造方法传参都是Runnable接口，没有Callable接口</del></p></li><li><p>找中间人FutureTask：FutureTask类实现了Runnable接口，并且接收一个Callable接口作为构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"~~~"</span> + Thread.currentThread().getName() + <span class="string">" Come in call() ~~~"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"1024"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 多线程第3种创建多线程的方式</span></span><br><span class="line"><span class="comment">* get()方法一般请放在最后一行,它会阻塞线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="comment">// System.out.println(Thread.currentThread().getName() + "计算中~~~");</span></span><br><span class="line">    <span class="comment">// 使用类似自旋锁的方式判断是否运行完毕</span></span><br><span class="line">    <span class="keyword">while</span> (!futureTask.isDone())&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"计算中~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"计算完成~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">~~~A Come in call() ~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">1024</span><br><span class="line">1024</span><br><span class="line">main计算完成~~~</span><br></pre></td></tr></table></figure><p>说明：多个线程执行一个FutureTask时只会计算一次，结果缓存，因此Come in call()方法只打印一次。如果需要两个线程同时计算任务时，需要定义两个futureTask</p></li></ol></li><li><p>FutureTask/Callable应用场景：在主线程中需要执行比较耗时的操作但又不想阻塞主线程时，可把这些操作交给FutureTask对象在后台完成。当主线程将来需要操作结果时可以通过FutureTask对象获得后台作业的计算结果或者执行状态。一般FutureTask多用于耗时的计算任务，主线程可在完成自己的任务后再去获取结果。仅在计算完成时才能检索结果；如果计算尚未完成，则会阻塞get()方法。get()方法获取结果只有在计算完成时获取，否则会阻塞直到任务转入完成状态，最后返回结果或者抛出异常。一旦计算完成，就不会再重新开始或取消计算，如果再次调用结果方法，会将缓存的结果直接返回</p></li></ul><h2 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h2><ul><li><p>CountDownLatch(减少计数)</p><ul><li><p>概念：让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p></li><li><p>原理：CountDownLatch主要有两个方————countDown()以及await()。当一个或多个线程调用await()方法时，这些线程会阻塞。其它线程调用countDown()方法会将计数器减1(调用countDown()方法的线程不会阻塞)，当计数器的值变为0时，因await()方法阻塞的线程会被唤醒，继续执行</p></li><li><p>例子：</p><ul><li><p>场景：假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后关灯、锁教室门然后走人，因此班长是需要最后一个走的。需要一种方法能够控制班长这个线程最后一个执行，而其它线程是随机执行的</p></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：所有子线程完成后(所有同学离开教室),主线程退出(班长离开教室)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 离开教室~~~"</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 班长关门走人~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规方法无法完成,会有乱序</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" 离开教室~~~"</span>), i + <span class="string">""</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 班长关门走人~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 普通版本</span><br><span class="line">0 离开教室~~~</span><br><span class="line">2 离开教室~~~</span><br><span class="line">3 离开教室~~~</span><br><span class="line">1 离开教室~~~</span><br><span class="line">main 班长关门走人~~~</span><br><span class="line">4 离开教室~~~</span><br><span class="line">5 离开教室~~~</span><br><span class="line"></span><br><span class="line"># CountDownLatch版本</span><br><span class="line">a4055b7f 离开教室~~~</span><br><span class="line">816b8658 离开教室~~~</span><br><span class="line">1876e706 离开教室~~~</span><br><span class="line">9657fae5 离开教室~~~</span><br><span class="line">4833f0f9 离开教室~~~</span><br><span class="line">6d229a84 离开教室~~~</span><br><span class="line">main 班长关门走人~~~</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>CyclicBarrier(循环栅栏)</p><ul><li><p>概念：让一些线程阻塞直到另一些线程完成一系列操作才被唤醒。方式与CountDownLatch相反，做加法，开始为0，加到某个值时才开始执行</p></li><li><p>原理：CyclicBarrier的字面意思是可循环(Cyclic)使用的屏障(Barrier)。它做的事情是让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门；此时所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法</p></li><li><p>例子：</p><ul><li><p>场景：集齐7颗龙珠召唤神龙</p></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：子线程全部完成后再运行指定方法(集齐七棵龙珠召唤神龙)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" 召唤神龙~~~"</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"收集到第"</span> + finalI + <span class="string">"颗龙珠~~~"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cyclicBarrier.await();</span><br><span class="line">          <span class="comment">// 在7个线程中最后一个线程到达await()屏障,之后下面的语句和cyclicBarrier中设定的动作才会被调度执行</span></span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"收集第"</span> + finalI + <span class="string">"颗龙珠完毕~~~"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, i + <span class="string">""</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 收集到第1颗龙珠~~~</span><br><span class="line">2 收集到第2颗龙珠~~~</span><br><span class="line">3 收集到第3颗龙珠~~~</span><br><span class="line">4 收集到第4颗龙珠~~~</span><br><span class="line">5 收集到第5颗龙珠~~~</span><br><span class="line">6 收集到第6颗龙珠~~~</span><br><span class="line">7 收集到第7颗龙珠~~~</span><br><span class="line">7 召唤神龙~~~</span><br><span class="line">7 收集第7颗龙珠完毕~~~</span><br><span class="line">1 收集第1颗龙珠完毕~~~</span><br><span class="line">3 收集第3颗龙珠完毕~~~</span><br><span class="line">2 收集第2颗龙珠完毕~~~</span><br><span class="line">6 收集第6颗龙珠完毕~~~</span><br><span class="line">5 收集第5颗龙珠完毕~~~</span><br><span class="line">4 收集第4颗龙珠完毕~~~</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Semaphore(信号量)</p><ul><li><p>概念：信号量，用于两个目的：</p><ol><li>用于共享资源的互斥使用</li><li>用于并发线程数的控制</li></ol></li><li><p>原理：在信号量上了定义两种操作：acquire()————获取，当一个线程调用acquire()操作时，它要么成功并获取信号量(信号量减1)，要么一直等下去直到有线程释放信号量或超时；release()————释放，会将信号量的值加1，然后唤醒等待的线程</p></li><li><p>例子：</p><ul><li><p>场景：抢车位，假设有6辆车，3个停车位</p></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：只有三个线程，但是希望六个线程都能够运行(有3个空闲车位,共有6辆车,一开始3辆车抢到,之后开走1辆另外的车占1个车位)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟资源类,有3个空车位</span></span><br><span class="line">    <span class="comment">// false表示非公平锁,默认也是非公平锁</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取信号量(车位)</span></span><br><span class="line">          semaphore.acquire();</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到了车位 ~~~"</span>);</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" 离开了车位 ~~~"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放信号量(车位)</span></span><br><span class="line">          semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, i + <span class="string">"号车"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0号车 抢到了车位 ~~~</span><br><span class="line">2号车 抢到了车位 ~~~</span><br><span class="line">1号车 抢到了车位 ~~~</span><br><span class="line">0号车 离开了车位 ~~~</span><br><span class="line">3号车 抢到了车位 ~~~</span><br><span class="line">1号车 离开了车位 ~~~</span><br><span class="line">4号车 抢到了车位 ~~~</span><br><span class="line">2号车 离开了车位 ~~~</span><br><span class="line">5号车 抢到了车位 ~~~</span><br><span class="line">3号车 离开了车位 ~~~</span><br><span class="line">4号车 离开了车位 ~~~</span><br><span class="line">5号车 离开了车位 ~~~</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h2><ul><li><p>阻塞队列介绍：<br>首先是一个队列，大致的数据结构如下图所示：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阻塞队列示意图"></p><ol><li>线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素</li><li><code>当队列是空的，从队列中获取元素的操作将会被阻塞</code></li><li><code>当队列是满的，从队列中添加元素的操作将会被阻塞</code></li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素，或者完全清空使队列变得空闲起来，再进行后续新增</li></ol></li><li><p>阻塞的解释：在多线程领域，所谓的阻塞就是指在某些情况下线程会被挂起，但一旦条件满足，被挂起的线程又会自动被唤起</p></li><li><p>阻塞队列的好处：</p><ol><li>不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，为这一切BlockingQueue都一手包办了</li><li>在concurrent包发布以前，多线程环境下每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给程序开发带来不小的复杂度</li></ol></li><li><p>阻塞队列种类：</p><ul><li>继承图：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="阻塞队列继承图"></li><li>各实现类介绍：<ol><li><strong>ArrayBlockingQueue</strong>：由数组结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界(但大小默认值为integer.MAX_VALUE)的阻塞队列</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列(生产一个,消费一个,不存储元素,不消费不生产)</li><li>LinkedTransferQueue：由链表组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表组成的双向阻塞队列</li></ol></li></ul></li><li><p>阻塞队列核心方法：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png" alt="阻塞队列核心方法"></p><table><thead><tr><th>方法类型</th><th>解释</th></tr></thead><tbody><tr><td><strong>抛出异常</strong></td><td><strong>当阻塞队列满时，再往队列里add插入元素会抛出异常IllegalStateException:Queue full；当阻塞队列空时，再往队列里remove移除元素会抛出异常NoSuchElementException</strong></td></tr><tr><td>特殊值</td><td>插入方法————成功ture，失败false；移除方法————成功返回出队列的元素，队列里没有就返回null</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据成功(元素被消费)或响应中断退出；当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用(元素被生产)</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table></li><li><p>用处</p><ol><li><p>线程池</p></li><li><p>消息中间件</p></li><li><p>生产者消费者模式</p><ul><li><p>需求：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来五轮</p></li><li><p>多线程口诀：</p><ol><li>线程、操作、资源类</li><li>判断、干活、通知</li><li>防止虚假唤醒机制</li></ol></li><li><p>传统版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 循环判断</span></span><br><span class="line">      <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待,不生产</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 干活</span></span><br><span class="line">      num++;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + num);</span><br><span class="line">      <span class="comment">// 通知唤醒</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deIncrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待,不生产</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 干活</span></span><br><span class="line">      num--;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + num);</span><br><span class="line">      <span class="comment">// 通知唤醒</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerTraditionDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          shareData.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          shareData.deIncrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure></li><li><p>阻塞队列版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认开启,进行生产/消费</span></span><br><span class="line">  <span class="comment">// volatile修饰,保证多线程内存可见性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 依赖注入,定义接口,而非实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProduce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String data;</span><br><span class="line">    <span class="keyword">boolean</span> returnValue;</span><br><span class="line">    <span class="comment">// 多线程环境的判断一定要使用while进行,防止出现虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      data = atomicInteger.incrementAndGet() + <span class="string">""</span>;</span><br><span class="line">      returnValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span> (returnValue) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" insert "</span> + data + <span class="string">" succeed~~~"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" insert "</span> + data + <span class="string">" fail~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" myProduce() finish~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result;</span><br><span class="line">    <span class="comment">// 多线程环境的判断一定要使用while进行,防止出现虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty()) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" over 2 seconds"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + result + <span class="string">" succeed~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" myConsume() finish~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumeBlockQueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" produce thread start~~~"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        myResource.myProduce();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"Produce Thread"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" Consume thread start~~~"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        myResource.myConsume();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"Consume Thread"</span>).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      myResource.stop();</span><br><span class="line">      System.out.println(<span class="string">"Main Stop()~~~"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">Produce Thread produce thread start~~~</span><br><span class="line">Consume Thread Consume thread start~~~</span><br><span class="line">Produce Thread insert 1 succeed~~~</span><br><span class="line">Consume Thread get 1 succeed~~~</span><br><span class="line">Produce Thread insert 2 succeed~~~</span><br><span class="line">Consume Thread get 2 succeed~~~</span><br><span class="line">Produce Thread insert 3 succeed~~~</span><br><span class="line">Consume Thread get 3 succeed~~~</span><br><span class="line">Produce Thread insert 4 succeed~~~</span><br><span class="line">Consume Thread get 4 succeed~~~</span><br><span class="line">Produce Thread insert 5 succeed~~~</span><br><span class="line">Consume Thread get 5 succeed~~~</span><br><span class="line">Main Stop()~~~</span><br><span class="line">Produce Thread myProduce() finish~~~</span><br><span class="line">Consume Thread over 2 seconds</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h2 id="ThreadPool线程池"><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h2><ul><li><p>为什么使用线程池：主要特点有线程复用、控制最大并发数、管理线程<br>线程池做的主要工作就是控制运行的线程的数量，处理过程中将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量则排队等候，等其它线程执行完毕，再从队列中取出任务来执行</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗</li><li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ol></li><li><p>线程池如何使用：</p><ul><li>线程池类继承图：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="线程池类继承图"></li><li>获取线程池的几种方式：<ol><li>Executors.newFixedThreadPool(int)：创建一个具有n个固定线程的线程池<ul><li>执行长期的任务，性能较好</li><li>创建一个<strong>定长线程池</strong>，可控制线程数最大并发数，超出的线程会在队列中等待</li><li>corePoolSize和MaxmumPoolSize是相等的，为输入的n；使用的底层阻塞队列是LinkedBlockingQueue</li></ul></li><li>Executors.newSingleThreadExecutor()：创建一个只有1个线程的单线程池<ul><li>一个任务一个任务执行的场景</li><li>创建一个<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li><li>corePoolSize和MaxmumPoolSize都设置为1；使用的底层阻塞队列是<strong>LinkedBlockingQueue</strong></li></ul></li><li>Executors.newCachedThreadPool()：创建一个可扩容的线程池<ul><li>使用执行很多短期异步的小程序或负载较轻的服务器</li><li>创建一个<strong>可缓存线程池</strong>，如果线程长度超过处理需要，可灵活回收空闲线程。如无线程可回收，则新建新线程</li><li>corePoolSize设置为0，maxmumPoolSize设置为Integer.MAX_VALUE；使用的底层阻塞队列是<strong>SynchronousQueue</strong>；来了任务就创建线程运行，如果线程空闲超过传入指定的keepAliveTime时间，就销毁线程</li></ul></li><li>Executors.newScheduledThreadPool(int)：创建周期性执行任务的线程池<ul><li>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li><li>使用的底层阻塞队列为DelayedWorkQueue</li></ul></li></ol></li></ul></li><li><p>Executors创建线程原理：<br><img src="Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86.png" alt="Executors创建线程原理"></p></li><li><p>线程池参数解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">    keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">  <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务就会安排池中的线程去执行请求任务</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达的请求任务放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</li><li>keepAliveTime：多余的空闲线程的存活时间，<ul><li>若当前池中线程数量超过corePoolSize，且当空闲时间达到keepAliveTime时，多余线程会被销毁，直到只剩下corePoolSize个线程为止</li><li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul></li><li>unit：keepAliveTime的时间单位</li><li>workQueue：任务队列，用于存储被提交但尚未被执行的任务(也即上面介绍的阻塞队列)<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，<strong>一般默认即可</strong></li><li>handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时，如何来拒绝请求执行的Runnable的策略</li></ol></li><li><p>线程池底层工作原理：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="线程池底层工作原理"></p><ol><li>在创建了线程池后，开始等待提交过来的任务请求</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ol><li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务<strong>放入队列</strong></li><li>如果这个时候队列满了，且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</li><li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会<strong>启动饱和拒绝策略来执行</strong></li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断：<ol><li>如果当前运行的线程数大于corePoolSize，那么该线程就被停掉</li><li>当线程池的所有任务完成后，<strong>线程池线程数目最终会收缩到corePoolSize</strong></li></ol></li></ol></li><li><p>线程池拒绝策略</p><ul><li>拒绝策略是什么：等待队列已经排满了，再也塞不下新任务了。同时，线程池中也达到了最大线程数，无法继续为新任务服务。这时就需要一种拒绝策略机制合理地处理这个问题</li><li>JDK内置的拒绝策略(内置拒绝策略均实现了RejectedExecutionHandle接口)<ol><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：”调用者运行”调节机制，该策略既不会抛弃任务也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略</li></ol></li></ul></li><li><p>线程池的选用</p><ul><li><p>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多：一个都不用<br><code>如Alibaba Java开发手册规定所示</code><br><img src="Alibaba_Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E8%A7%84%E5%AE%9A.png" alt="Alibaba Java开发手册规定"></p></li><li><p>自定义线程池示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RejectedExecutionException AbortPolicy</span></span><br><span class="line">    <span class="comment">// CallerRunsPolicy()</span></span><br><span class="line">    <span class="comment">// DiscardPolicy()</span></span><br><span class="line">    <span class="comment">// DiscardOldestPolicy()</span></span><br><span class="line">    ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">2L</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟有10个顾客来银行办理业务</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"办理业务~~~"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 线程池必须要关闭,重量资源</span></span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSystemPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1池5个工作线程</span></span><br><span class="line">    <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">// 1池1个工作线程</span></span><br><span class="line">    <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">// 1池N个工作线程</span></span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟有10个顾客来银行办理业务</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"办理业务~~~"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 线程池必须要关闭,重量资源</span></span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程池的合理参数配置<br>生产环境中如何配置corePoolSize和maximumPoolSize大小：根据具体业务来配置，分为CPU密集型和IO密集型</p><ol><li>CPU密集型<br>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行<br>CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)；而在单核CPU上，无论开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些<br>CPU密集型任务配置尽可能少的线程数量：一般为————CPU核数 + 1</li><li>IO密集型<br>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2<br>IO密集型即该任务需要大量的IO操作，即大量的阻塞<br>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上；IO密集型任务中使用多线程可以大大地加速程序的运行，即使在单核CPU上。这种加速主要就是利用了被浪费掉的阻塞时间<br>IO密集时，大部分线程都被阻塞，故需要多配置线程数：参考————CPU核数 / (1 - 阻塞系数)<br>通常阻塞系数在0.8 ~ 0.9左右<br>例如：8核CPU：8 / (1 - 0.9) = 80个线程数</li></ol></li></ul><h2 id="Java8流式计算"><a href="#Java8流式计算" class="headerlink" title="Java8流式计算"></a>Java8流式计算</h2><ul><li><p>函数式接口(只有一个方法(除default和static方法)的接口)：</p><ul><li><p>Lambda表达式口诀：<strong>拷贝小括号，写死右括号，落地大括号</strong></p></li><li><p>Lambda案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Lambda表达式</span></span><br><span class="line"><span class="comment">* 口诀：拷贝小括号(参数),写死右括号,落地大括号</span></span><br><span class="line"><span class="comment">* 注释<span class="doctag">@FunctionalInterface</span>(只有一个方法的接口,函数式接口)</span></span><br><span class="line"><span class="comment">* default方法允许接口有默认实现(jdk1.8),可以有多个</span></span><br><span class="line"><span class="comment">* 静态方法实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpress</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Foo foo = () -&gt; System.out.println(<span class="string">"Hello LambdaExpress"</span>);</span><br><span class="line">    foo.sayHello();</span><br><span class="line"></span><br><span class="line">    Foo1 foo1 = (x, y) -&gt; <span class="number">2</span> * x + y;</span><br><span class="line">    System.out.println(foo1.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(foo1.div(<span class="number">1.0</span>, <span class="number">0.3333</span>));</span><br><span class="line">    System.out.println(Foo1.multiply(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java内置核心四大函数式接口<br><img src="Java%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt="Java内置核心四大函数式接口"></p></li></ul></li><li><p>Stream流</p><ul><li><p>是什么：流(Stream)是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算</p></li><li><p>特点：</p><ol><li>Stream自己不会存储元素</li><li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li><li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行(懒加载)</li></ol></li><li><p>怎么用：</p><ol><li>创建一个Stream：一个数据源(数组、集合)</li><li>中间操作：一个中间操作，处理数据源数据</li><li>终止操作：一个终止操作，执行中间操作链，产生结果</li></ol></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String  userName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment">*      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment">*      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">    User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">    User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">    User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">    User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">    List list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line">    list.stream().filter(p -&gt; p.getId() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      .filter(p -&gt; p.getAge() &gt; <span class="number">24</span>)</span><br><span class="line">      .map(f -&gt; f.getUserName().toUpperCase())</span><br><span class="line">      .sorted((o1, o2) -&gt; o2.compareTo(o1))</span><br><span class="line">      .limit(<span class="number">1</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Java8分支合并"><a href="#Java8分支合并" class="headerlink" title="Java8分支合并"></a>Java8分支合并</h2><ul><li><p>原理(类同MapReduce)：<br>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并</p></li><li><p>相关类：</p><ol><li>ForkJoinPool(分支合并线程池)<br><img src="ForkJoinPool%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ForkJoinPool继承图"></li><li>ForkJoinTask(类似FutureTask)<br><img src="ForkJoinTask%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ForkJoinTask继承图"></li><li>RecursiveTask(递归任务,继承自ForkJoinTask,递归自己)<br><img src="RecursiveTask%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="RecursiveTask继承图"></li></ol></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> begin;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.begin = begin;</span><br><span class="line">      <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end - begin) &lt;= ADJUST_VALUE) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> middle = (end + begin) / <span class="number">2</span>;</span><br><span class="line">      MyTask leftTask = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">      MyTask rightTask = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">      leftTask.fork();</span><br><span class="line">      rightTask.fork();</span><br><span class="line">      result = leftTask.join() + rightTask.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">1023423423L</span>);</span><br><span class="line">    ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    ForkJoinTask&lt;Long&gt; forkJoinTask = threadPool.submit(myTask);</span><br><span class="line">    System.out.println(forkJoinTask.get());</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><ul><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 同步</span></span><br><span class="line">  CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"无返回!"</span>));</span><br><span class="line">  completableFuture.get();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步</span></span><br><span class="line">  CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"有返回!"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步回调</span></span><br><span class="line">  System.out.println(completableFuture2.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：t = "</span> + t);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：u = "</span> + u);</span><br><span class="line">  &#125;).exceptionally(f -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：f = "</span> + f.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4444</span>;</span><br><span class="line">  &#125;).get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li><p>介绍：volatile是Java虚拟机提供的轻量级的同步机制</p><ol><li>保证可见性</li><li><strong>不保证原子性</strong></li><li>禁止指令重排</li></ol></li><li><p>JMM介绍：<br>JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念，<strong>并不真实存在</strong>。它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式<br>JMM关于同步规定：</p><ol><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ol><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间)。工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>。主内存是共享内存区域，所有线程都可访问，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行。首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存</strong>。不能直接操作主内存中的变量，各个线程中的工作内存储存着主内存中的<strong>变量副本拷贝</strong>，因此不同的线程无法访问对方的工作内存，线程间的通讯(传值)必须通过主内存来完成，其简要访问过程如下图所示：<br><img src="%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="线程间通讯访问内存示意图"><br><img src="%E5%9B%BE%E8%A7%A3%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图解主内存工作内存示意图"></p></li><li><p>可见性：通过JMM的介绍，可知各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的。这将导致可能存在一个线程A修改了共享变量X的值，该值还未写回主内存中；此时另外一个线程B又对内存中的共享变量X进行操作，但此时线程A工作内存中的共享变量X对线程B来说并不不可见。这种工作内存与主内存同步延迟现象就造成了可见性问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// volatile int number = 0;</span></span><br><span class="line">  <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证volatile可见性</span></span><br><span class="line"><span class="comment">// 假如int number = 0;number变量之前没有volatile关键字修饰,没有可见性</span></span><br><span class="line"><span class="comment">// 添加了volatile,可解决可见性问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      myData.add();</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t update number"</span>);</span><br><span class="line">    &#125;, <span class="string">"Test"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待,直到number被更新</span></span><br><span class="line">    <span class="keyword">while</span> (myData.number == <span class="number">0</span>) ;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over , number = "</span> + myData.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当number不加volatile关键字时,主内存不更新,一直在循环中</span></span><br><span class="line"><span class="comment">打印:</span></span><br><span class="line"><span class="comment">Test come in</span></span><br><span class="line"><span class="comment">Test update number</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当number加volatile关键字时,主内存可见,循环能正常退出</span></span><br><span class="line"><span class="comment">打印:</span></span><br><span class="line"><span class="comment">Test come in</span></span><br><span class="line"><span class="comment">Test update number</span></span><br><span class="line"><span class="comment">main mission is over , number = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>原子性：操作不可分割，完整性。即某个线程正在做某个具体业务时，中间不可以被加塞或被分割。需整体完整，要么同时成功要么同时失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// AtomicInteger number = new AtomicInteger();</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// public void add() &#123; number.getAndIncrement(); &#125;</span></span><br><span class="line">  <span class="comment">// public synchronized void add() &#123; number++; &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证volatile不保证原子性</span></span><br><span class="line"><span class="comment">// 如何保证原子性：</span></span><br><span class="line"><span class="comment">// 1、加synchronized关键字()</span></span><br><span class="line"><span class="comment">// 2、使用AtomicInteger原子整型类替换int</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123; myData.add(); &#125;</span><br><span class="line">      &#125;, <span class="string">"Thread "</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待20个线程全部即算完成后,主线程继续执行(当还有子线程时,主线程算一个)</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 线程让步,让出CPU执行时间给其他线程</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印最终的结果值</span></span><br><span class="line">    System.out.println(myData.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当add()不加synchronized关键字时</span></span><br><span class="line"><span class="comment">打印小于20000的数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当add()加synchronized关键字时</span></span><br><span class="line"><span class="comment">打印20000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add()方法对应的字节码反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: dup</span><br><span class="line">    2: getfield      #2                  // Field number:I</span><br><span class="line">    <span class="number">5</span>: iconst_1</span><br><span class="line">    <span class="number">6</span>: iadd</span><br><span class="line">    7: putfield      #2                  // Field number:I</span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n++被拆分成三个指令：</span></span><br><span class="line"><span class="comment">1、执行getfield从主内存拿到原始number</span></span><br><span class="line"><span class="comment">2、执行iadd进行加1操作</span></span><br><span class="line"><span class="comment">3、执行putfield把累加后的值写回主内存</span></span><br><span class="line"><span class="comment">可能会出现写覆盖,因此小于20000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>数值丢失的原因：假设线程1和2同时修改各自工作空间的内容，因此可见性，因此需要重新写入主内存。但在线程1写入时，线程2也同时写入，这导致线程1的写入操作被挂起；线程2写完后线程1继续写入，这样线程1写入的值覆盖了线程2写入的值，造成数据丢失</p></li><li><p>有序性：计算机在执行程序时为了提高性能，编译器和处理器常常会做<strong>指令重排</strong>，一般分为以下3种：<br><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code><br>单线程环境里确保程序最终执行结果和代码顺序执行的结果一致<br>处理器在进行重新排序是必须要考虑指令之间的<strong>数据依赖性</strong><br>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的，结果无法预测</p></li><li><p>指令重排案例：</p><ol><li><p>案例一：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">11</span>; <span class="comment">// 语句1</span></span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">12</span>; <span class="comment">// 语句2</span></span><br><span class="line">  x = x + <span class="number">5</span>; <span class="comment">// 语句3</span></span><br><span class="line">  y = x * x; <span class="comment">// 语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 正常单线程情况：1234<br> 多线程环境可能的情况：2134、1324<br> 上述的过程就可以当做是指令的重排，即内部执行顺序和我们的代码顺序不一样。但是指令重排也是有限制的，即不会此情况：4321<br> 因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性。语句4依赖于y以及x的申明，因为存在数据依赖，无法首先执行</p></li><li><p>案例二：</p><p> <code>int a = 0, b = 0, x = 0, y = 0;</code></p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = 0; y = 0;</td><td></td></tr></tbody></table><p> 如果编译器对这段代码进行执行重排优化后，可能出现下列情况：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>x = 2; y = 1;</td><td></td></tr></tbody></table><p> 这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程使用的变量能否保持一致是无法确定的</p></li><li><p>案例三：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResortSeqDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      a = a + <span class="number">5</span>;</span><br><span class="line">      System.out.println(<span class="string">"Value: "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 按照正常的顺序分别调用method01()和method02()，那么最终输出就是a = 6<br> 但如果在多线程环境下，因为method01()和method02()之间不能存在数据依赖的问题，因此原先的顺序可能是</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">a = a + <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"Value:"</span> + a);</span><br></pre></td></tr></table></figure><p> 但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">a = a + <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"Value:"</span> + a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p> 先执行flag = true后，另外一个线程马上调用方法2，满足flag的判断，最终a = a + 5，结果为5，这样出现了数据不一致的问题<br> 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测<br> 这就需要通过volatile来修饰变量，来保证线程安全性</p></li></ol></li><li><p>volatile对指令重排作用总结：<br>volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象<br>内存屏障(Memory Barrier)又称内存栅栏，是一个CPU指令，作用有两个：</p><ol><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)<br>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，即<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本<br><img src="volatile%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile指令重排内存屏障示意图"></li></ol></li><li><p>线程安全保证：</p><ol><li>工作内存与主内存同步延迟现象导致的可见性问题：<ul><li>可通过synchronized或volatile关键字解决，它们都可使一个线程修改后的变量立即对其它线程可见</li></ul></li><li>对于指令重排导致的可见性问题和有序性问题：<ul><li>可以使用volatile关键字解决，volatile关键字的另一个作用就是禁止重排序优化</li></ul></li></ol></li><li><p>volatile的应用：单例模式DCL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version1：普通方式/加synchronized关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t Constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> SingletonDemo(); &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较内存地址(单线程) 正确</span></span><br><span class="line">    System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><br><span class="line">    <span class="comment">// 查看打印信息(多线程) -&gt; 打印多次构造器,错误</span></span><br><span class="line">    <span class="comment">// 改进：getInstance()方法添加关键字synchronized</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(</span><br><span class="line">        () -&gt; SingletonDemo.getInstance(),</span><br><span class="line">        <span class="string">"Thread"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过引入synchronized关键字,能够解决高并发环境下的单例模式问题</span></span><br><span class="line"><span class="comment">但synchronized属于重量级的同步机制,它只允许一个线程同时访问获取实例的方法;为了保证数据一致性而减低了并发性,因此采用的比较少</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// version2：DCL(Double Check Lock:双端检锁机制)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 同步代码段的时候，进行检测</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> SingletonDemo(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的DCL(双端检锁)机制不一定线程安全，原因是由于指令重排的存在；加入volatile可以禁止指令重排<br>原因在于某一个线程在执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化：<br><code>instance = new SingletonDemo();</code><br>可以分为以下步骤(伪代码)<br><code>memory = allocate(); // 1、分配对象内存空间</code><br><code>instance(memory); // 2、初始化对象</code><br><code>instance = memory; // 3、设置instance指向刚分配的内存地址,此时instance != null</code><br>步骤2和步骤3不存在数据依赖关系。而且无论重排前还是重排后程序执行的结果在单线程中并没有改变，因此这种重排优化是允许的<br><code>memory = allocate(); // 1、分配对象内存空间</code><br><code>instance = memory; // 3、设置instance指向刚分配的内存地址,此时instance != null;但对象还没有初始化完</code><br><code>instance(memory); // 2、初始化对象</code><br>当我们执行到重排后的步骤2试图获取instance的时候会得到null，因为对象的初始化还没有完成，而在重排后的步骤3才完成。因此执行单例模式的代码时候，就会重新再创建一个instance实例<br><strong>指令重排只会保证串行语义的执行一致性(单线程),并不会关心多线程间的语义一致性</strong><br>所以当一条线程访问instance不为null时，由于instance实例未必完成初始化,也就造成了线程安全问题。因此需要引入volatile来保证出现指令重排的问题，从而保证单例模式的线程安全性</p></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul><li><p>概念：<br>CAS的全称是Compare-And-Swap(比较并交换)，它是<strong>一条CPU并发原语</strong><br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子性的<br>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现<strong>CAS汇编指令</strong>，这是一种完全<strong>依赖于硬件</strong>的功能，通过它实现了原子操作。CAS是一种系统原语(属于操作系统原语范畴)，由若干条指令组成，用于完成某个功能的一个过程。<strong>原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的</strong></p></li><li><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个AtomicInteger实例,并初始化为5</span></span><br><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 调用CAS方法,企图更新成2019</span></span><br><span class="line"><span class="comment">// 两个参数：前者为5，表示期望值;后者为2019,是要求更新的值</span></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">"\t current data = "</span> + atomicInteger.get());</span><br><span class="line"><span class="comment">// 再次调用CAS方法,企图更新成1024</span></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">"\t current data = "</span> + atomicInteger.get());</span><br></pre></td></tr></table></figure><p>第一次执行CAS方法时，期望值和原本值满足，因此修改成功，返回true和2019；但第二次执行主内存值已修改为2019，不满足期望值，本次写入失败，因此返回了false和2019<br>类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p></li><li><p>CAS底层原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// atomicInteger.getAndIncrement()方法源码</span></span><br><span class="line"><span class="comment">// this：当前atomicInteger对象</span></span><br><span class="line"><span class="comment">// valueOffset：内存偏移量,即内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致意思是通过valueOffset直接利用内存地址获取到值然后进行加1的操作<br>底层又调用了一个unsafe类的getAndAddInt()方法<br>AtomicInteger底层部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Unsafe类：<br> Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(Native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C指针一样直接操作内存。Java中的CAS操作的执行依赖于Unsafe类的方法<br> <code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code><br> <code>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</code></p></li><li><p>变量valueOffset：表示该变量值(Atomic修饰的值)在内存中的偏移地址，Unsafe就是根据内存偏移地址获取数据的</p></li><li><p>变量value用volatile修饰：保证多线程之间内存的可见性</p></li><li><p>具体的unsafe.getAndAddInt()方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// getIntVolatile()和compareAndSwapInt()都是native方法</span></span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 解释：</p><ul><li>参数解释：<ol><li>val1：AtomicInteger对象本身</li><li>var2：值的引用内存地址</li><li>var4：需要增加的int值</li><li>var5：用var1和var2找到的主内存中的真实值——即从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值并拷贝到当前线程的本地内存，然后执行compareAndSwapInt()方法再和主内存的值进行比较——在高并发环境下可能主内存值又被更新。线程不可以直接越过高速缓存直接操作主内存，所以需要执行比较方法，值统一后再执行加1操作——底层原子绑定)</li></ol></li><li>实现思路：操作时需要比较当前线程工作内存中的值和主内存中的值，假设执行compareAndSwapInt()方法返回false，那么就一直执行while循环体的内容，一直刷新主内存中的值到当前线程的工作内存，直到期望的值和真实值一样<ol><li>用该对象当前的值与var5比较</li><li>如果相同，更新为var5 + var4并返回true</li><li>如果不同，继续从主内存中取最新的值然后再比较，重复流程1，直到值相同，更新完成<br>该处没有使用synchronized加锁机制，而使用CAS，这能提高并发性，同样也能实现一致性。这是因为每个线程进来后，进入do while循环体，不断地获取内存中的值，判断是否为最新的值，为最新值后再进行更新操作</li></ol></li><li>具体案例：假设线程A和线程B同时执行getAndInt()方法(分别跑在不同的CPU上)<ol><li>AtomicInteger里面的value原始值为3(即主内存中AtomicInteger的value为3)，根据JMM模型，线程A和线程B各自持有一份值为3的AtomicInteger副本，并分别存储在各自的工作内存中</li><li>线程A通过getIntVolatile()方法拿到最新value值3，此时线程A被挂起(该线程失去CPU执行权)</li><li>线程B此时通过getIntVolatile()方法获取到最新value值，也是3。此时线程B没有被挂起，并执行了compareAndSwapInt()方法，主内存的值也是3，成功修改主内存值为4，线程B退出循环</li><li>此时线程A恢复，执行compareAndSwapInt()方法，比较发现工作内存的值3和主内存中的值4不一致，说明该值已被其它线程抢先一步修改过。因此A线程本次修改失败，再次进入循环体</li><li>线程A重新获取主内存最新的value值，因为变量value被volatile修饰，所以其它线程对它的修改线程A总能够看到，线程A继续执行compareAndSwapInt()方法进行比较并交换直到成功</li></ol></li></ul></li></ol></li><li><p>Unsafe类的CAS思想：自旋(自我旋转,直到成功)</p></li><li><p>底层实现：Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="comment">// 先想办法拿到变量value在内存中的地址</span></span><br><span class="line">  <span class="comment">// 通过Atomic::cmpxchg实现比较替换,其中参数X是即将更新的值,参数e是原内存的值</span></span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure></li><li><p>CAS缺点：</p><ol><li>循环时间长，CPU开销大(因为执行的是do-while语句,如果比较不一致会一直循环;最差的情况就是某个线程一直取到的值和预期值都不一样,导致无限循环)</li><li>只能保证一个共享变量的原子操作<ul><li>当对一个共享变量执行操作时，可以通过CAS方式来保证原子操作</li><li>当对多个共享变量执行操作时，CAS方式就无法保证操作的原子性，此时只能用锁来保证原子性</li></ul></li><li>引出ABA问题</li></ol></li><li><p>ABA问题：</p><ul><li><p>介绍：<br>CAS算法实现的一个重要前提：需要取出内存中某时刻的数据，并在当下时刻比较并交换，在这个时间差上可能会发生数据的变化<br>比如线程1从内存位置V中取出值为A，此时另一线程2也从内存V中取出A，并且线程2进行了一些操作将值更新为B之后又将值更新为A；这时线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功<br><strong>尽管线程1的CAS操作成功，但不代表该过程就是没有问题的</strong></p></li><li><p>原子引用AtomicReference(能操作对象)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>, <span class="number">22</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="string">"lisi"</span>, <span class="number">23</span>);</span><br><span class="line">AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">atomicReference.set(user1);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1, user2) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1, user2) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true User&#123;userName='lisi', age=23&#125;</span></span><br><span class="line"><span class="comment">// false User&#123;userName='lisi', age=23&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>ABA问题的解决(AtomicStampedReference,新增版本号(类似时间戳)标记)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABA问题的模拟</span></span><br><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">&#125;, <span class="string">"ABA A"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// 暂停1秒,保证t1线程完成ABA操作</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">&#125;, <span class="string">"ABA B"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true 101</span></span><br><span class="line"><span class="comment">// true 100</span></span><br><span class="line"><span class="comment">// true 2019</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABA问题的解决AtomicStampedReference</span></span><br><span class="line"><span class="comment">// 新增版本号标记数据版本</span></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 1st: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">  <span class="comment">// 等待线程B获取版本号</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 2nd: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">  atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 3rd: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">&#125;, <span class="string">"ABA Solution A"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 1st: "</span> + stamp);</span><br><span class="line">  <span class="comment">// 等待线程A完成一次ABA操作</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Result = "</span> + atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>) + <span class="string">"\t Current Version = "</span> + atomicStampedReference.getStamp() + <span class="string">"\t Value = "</span> + atomicStampedReference.getReference());</span><br><span class="line">&#125;, <span class="string">"ABA Solution B"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 1st: 1</span></span><br><span class="line"><span class="comment">// ABA Solution B Version 1st: 1</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 2nd: 2</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 3rd: 3</span></span><br><span class="line"><span class="comment">// ABA Solution B Result = false Current Version = 3 Value = 100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>CAS总结：</p><ol><li>CAS是compare and swap的缩写，表示比较当前工作内存中的值和主物理内存中的值；如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</li><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</li></ol></li></ul><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><ul><li><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personName = personName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferValueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    age = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    person.setPersonName(<span class="string">"XXXX"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = <span class="string">"XXX"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TransferValueDemo test = <span class="keyword">new</span> TransferValueDemo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义基本数据类型</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    test.changeValue1(age);</span><br><span class="line">    System.out.println(<span class="string">"age: "</span> + age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化person类</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"SOBXiong"</span>);</span><br><span class="line">    test.changeValue2(person);</span><br><span class="line">    System.out.println(<span class="string">"personName: "</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String</span></span><br><span class="line">    String str = <span class="string">"SOBXiong"</span>;</span><br><span class="line">    test.changeValue3(str);</span><br><span class="line">    System.out.println(<span class="string">"string: "</span> + str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">age: 20</span></span><br><span class="line"><span class="comment">personName: XXXX</span></span><br><span class="line"><span class="comment">string: SOBXiong</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>ChangeValue1()执行过程<br>八种基本数据类型，在栈里面分配内存，属于值传递<br><code>栈管运行，堆管存储</code><br>执行changeValue1()时，int是基本数据类型，所以传递的是int = 20这个值，传递的是一个副本，main方法里面的age并没有改变，因此输出的结果age还是20，属于值传递<br><img src="changeValue1()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue1()执行过程图解"></p></li><li><p>ChangeValue2()执行过程<br>Person是属于对象，作为方法参数时也是值传递，只不过传递的是引用——在堆空间的内存地址。执行changeValue2()时复制了内存地址，两个值都是指向同一个地址<br><img src="changeValue2()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue2()执行过程图解"></p></li><li><p>ChangeValue3()执行过程<br>String不属于基本数据类型，但是为什么执行完成后值未改变？<br>这时因为String的特殊性，当执行String str = “SOBXiong”的时候，JVM会检查常量池中是否已存在”SOBXiong”，如果存在则不会创建，会生成一个引用指向常量池中的”SOBXiong”并把str赋值为引用的值；如果不存在，则会新建”SOBXiong”并把引用指向它并将str赋值为引用的值<br><img src="changeValue3()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue3()执行过程图解"></p></li></ul><h2 id="Java锁的类型"><a href="#Java锁的类型" class="headerlink" title="Java锁的类型"></a>Java锁的类型</h2><ul><li><p>公平锁/非公平锁</p><ul><li>概念：<ol><li>公平锁：多个线程按照申请锁的顺序来获取锁，先来先服务，就是公平的，也即队列</li><li>非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下有可能造成优先级翻转，或者饥饿线程(某个线程一直得不到锁)</li></ol></li><li>如何创建：<ol><li>并发包中ReentrantLock的创建可以指定构造函数的boolean值来得到公平锁/非公平锁，默认是非公平锁，因为非公平锁有吞吐量比公平锁高的优点<br> <code>Lock lock = new ReentrantLock(true);</code></li><li>synchronized也是一种非公平锁</li></ol></li><li>两者区别：<ol><li><strong>公平锁</strong>：很公平。在并发环境中每个线程在获取锁时会先查看此锁维护的等待队列，如果为空或当前线程是等待队列中的第一个，就占用锁，否则就会加入到等待队列中，此后按照FIFO的规则</li><li><strong>非公平锁</strong>：较粗鲁，一上来就直接尝试占有锁，如果尝试失败，再采用类似公平锁的方式</li></ol></li></ul></li><li><p>可重入锁(递归锁)</p><ul><li><p>概念：<br>可重入锁就是递归锁<br>指同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，同一线程在外层方法获取锁时，进入内层方法会自动获取锁<br>也即————<strong>线程可以进入任何一个它已拥有的锁所同步的代码块</strong><br>ReentrantLock/Synchronized是典型的可重入锁</p></li><li><p>作用：可避免死锁</p></li><li><p>可重入锁验证：</p><ul><li><p>案例一：验证Synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendSMS()"</span>);</span><br><span class="line">    <span class="comment">// 在同步方法中调用另外一个同步方法</span></span><br><span class="line">    sendEmail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendEmail()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(phone::sendSMS, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(phone::sendSMS, <span class="string">"t2"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure><p>说明：sendSMS()同步方法调用sendEmail()同步方法，synchronized锁的是对象，假如不是重入锁，那么sendSMS()方法要获取一次锁，sendEmail()又要获取一次锁，就会造成死锁；由于是同一线程，再次获取锁时就是sendSMS()获取的那个锁，没有新锁产生。同时由于synchronized锁的是对象，线程t1得到锁后，线程t2只能等t1运行完sendSMS()同步方法释放完锁</p></li><li><p>案例二：验证ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">        setLock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" set Lock"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">"t3"</span>);</span><br><span class="line">    Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">"t4"</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    t4.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p>说明：与加synchronized锁一样，多次获取锁后，锁是重入的，并不会锁死自己</p></li><li><p>案例三：案例二变形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p>说明：结果与案例二一样，因此不管有几把锁，实际都是同一把锁，用同一把钥匙都能打开</p></li><li><p>案例四：案例三变形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure><p>说明：加锁两次，解锁一次。程序在输出上述两句后阻塞(线程阻塞)，也就是说ReentrantLock申请加锁几次就要解锁几次</p></li><li><p>案例五：案例三变形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread "t3" Exception in thread "t4" java.lang.IllegalMonitorStateException</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">  at com.xiong.interview.Phone.getLock(ReenterLockDemo.java:16)</span><br><span class="line">  at com.xiong.interview.Phone.run(ReenterLockDemo.java:31)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">  at com.xiong.interview.Phone.getLock(ReenterLockDemo.java:16)</span><br><span class="line">  at com.xiong.interview.Phone.run(ReenterLockDemo.java:31)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>说明：加锁次数小于解锁次数，直接抛异常</p></li></ul></li></ul></li><li><p>自旋锁：</p><ul><li><p>概念：SpinLock，指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU资源<br>上文提及的<a href="##CAS">比较并交换(CAS)</a>底层使用的就是自旋</p></li><li><p>手写自旋锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子引用线程</span></span><br><span class="line">  AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123; &#125;</span><br><span class="line">    System.out.println(thread.getName() + <span class="string">" Come in ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(thread.getName() + <span class="string">" Come out ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      spinLockDemo.myLock();</span><br><span class="line">      <span class="comment">// 暂停一会</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      spinLockDemo.myUnlock();</span><br><span class="line">    &#125;,<span class="string">"Thread A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停一会</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      spinLockDemo.myLock();</span><br><span class="line">      spinLockDemo.myUnlock();</span><br><span class="line">    &#125;,<span class="string">"Thread B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread A Come in ~~~</span><br><span class="line">Thread A Come out ~~~</span><br><span class="line">Thread B Come in ~~~</span><br><span class="line">Thread B Come out ~~~</span><br></pre></td></tr></table></figure><p>说明：打印第1句5s后打印后三句话，而且out紧接第一句话。A线程调用myLock()方法自己持有锁5s，线程B进入方法后发现有线程持有锁，因此只能通过自旋等待，A线程调用myUnlock()方法释放锁后，线程B才能继续执行</p></li></ul></li><li><p>独占锁(写锁)/共享锁(读锁)/互斥锁</p><ul><li><p>概念：<br>独占锁：指该锁一次只能被一个线程所持有。ReentrantLock和Synchronized都是独占锁<br>共享锁：指该锁可以被多个线程锁持有<br>ReentrantReadWriteLock其读锁是共享，写锁是独占。写的时候只能一个人写，但是读的时候可以多个人同时读。读锁的共享锁可保证并发读是非常高效的。读写/写写的过程是互斥的</p></li><li><p>为什么会有写锁和读锁：<br>独占锁一次只能一个线程访问，但有一个读写分离的场景，读时想同时进行，原来独占锁的并发性就没这么好了。读锁并不会造成数据不一致的问题，因此可以多个人共享读<br>多个线程同时读一个资源类没有任何问题，为了满足并发，读取共享资源应该可以同时进行。但若有一个线程去写共享资源，就不应该再有其他线程对该资源进行读或写操作</p></li><li><p>案例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写入："</span> + key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写入完成"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读取:"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = map.get(key);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读取完成："</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">    <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; myCache.put(tempInt + <span class="string">""</span>, tempInt + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; myCache.get(tempInt + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>运行结果如下</code></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">3 正在写入：3</span><br><span class="line">2 正在写入：2</span><br><span class="line">1 正在写入：1</span><br><span class="line">4 正在写入：4</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">0 写入完成</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">3 写入完成</span><br><span class="line">2 写入完成</span><br><span class="line">2 读取完成：2</span><br><span class="line">4 写入完成</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">1 读取完成：null</span><br></pre></td></tr></table></figure><ul><li><p>案例说明：在写入时，写线程被其他线程打断，这就造成还没写完就被挂起，其他线程开始写，这可能会造成数据的不一致。写操作需要原子 + 独占，整个过程必须是一个完整的统一体，中间不许被分割、打断。结果的打印顺序与真实顺序有出入，因为也是多线程的，实际读取到null的应该在写入完成之前执行</p></li><li><p>解决方案：加读写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增量部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个读写锁,是一个读写一体的锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写锁加锁</span></span><br><span class="line">  lock.writeLock().lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写入："</span> + key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写入完成"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 写锁释放</span></span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读锁加锁</span></span><br><span class="line">  lock.readLock().lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读取:"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读取完成："</span> + map.get(key));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 读锁释放</span></span><br><span class="line">    lock.readLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">0 写入完成</span><br><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">1 读取完成：1</span><br><span class="line">3 读取完成：3</span><br><span class="line">2 读取完成：2</span><br><span class="line">4 读取完成：4</span><br><span class="line">0 读取完成：0</span><br></pre></td></tr></table></figure></li><li><p>解决方案说明：写锁一次只允许一个线程进入执行写操作，而读锁允许多个线程同时进入执行读取的操作。结果证明写入操作中间不会被打断，而读操作可以同时进入</p></li></ul></li></ul></li></ul><h2 id="死锁及定位分析"><a href="#死锁及定位分析" class="headerlink" title="死锁及定位分析"></a>死锁及定位分析</h2><ul><li><p>死锁概念：死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象。若无外力干涉，那它们都将无法继续推进下去。如果资源充足，进程的资源请求都能得到满足，死锁出现的可能性很低，否则就会因争夺有限的资源而陷入死锁<br><img src="%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="死锁情况示意图"></p></li><li><p>产生原因：</p><ol><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ol></li><li><p>死锁产生的四个必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol></li><li><p>死锁案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object lockA;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object lockB;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(Object lockA, Object lockB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">    <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 自己持有&#123;"</span> + lockA + <span class="string">"&#125; , 尝试获得&#123;"</span> + lockB + <span class="string">'&#125;'</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 自己持有&#123;"</span> + lockB + <span class="string">"&#125; , 尝试获得&#123;"</span> + lockA + <span class="string">'&#125;'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object lockA = <span class="keyword">new</span> Object(), lockB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">new</span> HoldLockThread(lockA, lockB).run(), <span class="string">"Thread A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">new</span> HoldLockThread(lockB, lockA).run(), <span class="string">"Thread B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果如下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread B 自己持有&#123;java.lang.Object@1b77d269&#125; , 尝试获得&#123;java.lang.Object@42f5503f&#125;</span><br><span class="line">Thread A 自己持有&#123;java.lang.Object@42f5503f&#125; , 尝试获得&#123;java.lang.Object@1b77d269&#125;</span><br></pre></td></tr></table></figure><p>说明：打印上述信息后，主线程阻塞，无法结束</p></li><li><p>排查死锁：</p><ol><li><p>使用jps命令定位进程编号：jps -l<br> <img src="jps%E5%AE%9A%E4%BD%8Djava%E8%BF%9B%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="jps定位java进程示意图"></p></li><li><p>使用jstack命令查看堆栈信息：jstack pid</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.251-b08 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #14 daemon prio=9 os_prio=31 tid=0x00007fcd65818000 nid=0x5903 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"DestroyJavaVM" #13 prio=5 os_prio=31 tid=0x00007fcd6607d000 nid=0xe03 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Thread B" #12 prio=5 os_prio=31 tid=0x00007fcd67815000 nid=0x5803 waiting for monitor entry [0x0000700006488000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$2/1595428806.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Thread A" #11 prio=5 os_prio=31 tid=0x00007fcd638b8000 nid=0x5703 waiting for monitor entry [0x0000700006385000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$0(DeadLockDemo.java:33)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$1/2065951873.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Service Thread" #10 daemon prio=9 os_prio=31 tid=0x00007fcd64056800 nid=0xa903 runnable [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread3" #9 daemon prio=9 os_prio=31 tid=0x00007fcd66057800 nid=0x4203 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread2" #8 daemon prio=9 os_prio=31 tid=0x00007fcd65052800 nid=0x4303 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread1" #7 daemon prio=9 os_prio=31 tid=0x00007fcd63843000 nid=0x4403 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #6 daemon prio=9 os_prio=31 tid=0x00007fcd6604e800 nid=0x4603 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Monitor Ctrl-Break" #5 daemon prio=5 os_prio=31 tid=0x00007fcd6780e800 nid=0x3f03 runnable [0x0000700005c70000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">        - locked &lt;0x000000076ac839b8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">        at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">        - locked &lt;0x000000076ac839b8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:61)</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" #4 daemon prio=9 os_prio=31 tid=0x00007fcd6701b000 nid=0x4803 runnable [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=31 tid=0x00007fcd65813800 nid=0x3103 in Object.wait() [0x0000700005964000]</span><br><span class="line">  java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab08ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x000000076ab08ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=31 tid=0x00007fcd66813000 nid=0x2f03 in Object.wait() [0x0000700005861000]</span><br><span class="line">  java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab06c00&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x000000076ab06c00&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=31 tid=0x00007fcd6580f000 nid=0x4f03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" os_prio=31 tid=0x00007fcd6500c800 nid=0x2007 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=31 tid=0x00007fcd6500d000 nid=0x1b03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#2 (ParallelGC)" os_prio=31 tid=0x00007fcd6500e000 nid=0x1d03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#3 (ParallelGC)" os_prio=31 tid=0x00007fcd65012800 nid=0x2a03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#4 (ParallelGC)" os_prio=31 tid=0x00007fcd65013800 nid=0x2c03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#5 (ParallelGC)" os_prio=31 tid=0x00007fcd65014000 nid=0x5303 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#6 (ParallelGC)" os_prio=31 tid=0x00007fcd65014800 nid=0x2e03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#7 (ParallelGC)" os_prio=31 tid=0x00007fcd65015000 nid=0x5103 runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=31 tid=0x00007fcd65053000 nid=0xa803 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 319</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread B":</span><br><span class="line">  waiting to lock monitor 0x00007fcd6504d758 (object 0x000000076ac374a8, a java.lang.Object),</span><br><span class="line">  which is held by "Thread A"</span><br><span class="line">"Thread A":</span><br><span class="line">  waiting to lock monitor 0x00007fcd6504d6a8 (object 0x000000076ac374b8, a java.lang.Object),</span><br><span class="line">  which is held by "Thread B"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread B":</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$2/1595428806.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"Thread A":</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$0(DeadLockDemo.java:33)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$1/2065951873.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p> 说明：查看最后一行，看到<code>Found 1 deadlock</code>，即存在一个死锁，上面的部分信息指示了出现问题的文件和行数</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2020/09/06/Middleware/Nginx/"/>
      <url>/2020/09/06/Middleware/Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li><a href="#Nginx简介">Nginx简介</a></li><li><a href="#Nginx安装">Nginx安装</a></li><li><a href="#Nginx常用的命令和配置文件">Nginx常用的命令和配置文件</a></li><li><a href="#Nginx配置实例-反向代理">Nginx配置实例-反向代理</a></li><li><a href="#Nginx配置实例-负载均衡">Nginx配置实例-负载均衡</a></li><li><a href="#Nginx配置实例-动静分离">Nginx配置实例-动静分离</a></li><li><a href="#Nginx搭建高可用集群">Nginx搭建高可用集群</a></li><li><a href="#Nginx原理简述">Nginx原理简述</a></li></ul><a id="more"></a><h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><ul><li>Nginx概述：是一个高性能的HTTP和反向代理服务器,特点是占有内存少，并发能力强，事实上Nginx的并发能力确实在同类型的网页服务器中表现较好</li><li>Nginx的作用：<ul><li>作为Web服务器：Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php等。但是不支持java。Java程序只能通过与tomcat配合完成</li><li>正向代理：如果把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理(需要设置代理地址)</li><li>反向代理：客户端对代理是无感知的，因为客户端不需要任何配置就可以访问。我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后再返回给客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址</li><li>负载均衡：单个服务器解决不了并发需求，可以增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况变为将请求分发到多个服务器上，将负载分发到不同的服务器。这就是所说的负载均衡</li><li>动静分离：为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</li></ul></li></ul><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><ul><li><p>进入Nginx官网<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a>的download板块下载</p></li><li><p>具体安装Nginx</p><ul><li><p>安装所需的第三方库：pcre、openssl、zlib</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压缩nginx的tar.gz包</span></span><br><span class="line">tar -zxvf nginx-1.18.0.tar.gz -C /opt/module</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录,执行./configure</span></span><br><span class="line">cd /opt/module/nginx-1.18.0</span><br><span class="line">sudo ./configure</span><br><span class="line"><span class="meta">#</span><span class="bash"> make安装</span></span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>测试(注意Linux的防火墙设置)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入/usr/<span class="built_in">local</span>/nginx/sbin目录</span></span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx</span></span><br><span class="line">sudo ./nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入当前虚拟机的地址的80端口,查看是否能看到Welcome to nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://sobxiong.com</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Nginx常用的命令和配置文件"><a href="#Nginx常用的命令和配置文件" class="headerlink" title="Nginx常用的命令和配置文件"></a>Nginx常用的命令和配置文件</h2><ul><li><p>Nginx常用的命令(当前路径:/usr/local/nginx/sbin)</p><ul><li>查看nginx版本号：./nginx -v</li><li>启动命令：./nginx</li><li>关闭命令：./nginx -s stop</li><li>重新加载命令(重新加载配置文件)：./nginx - s reload</li></ul></li><li><p>nginx.conf配置文件</p><ul><li><p>介绍：Nginx默认的配置文件都放在主目录下的conf目录，主配置文件nginx.conf也在其中，后续对nginx的使用基本上都是对此配置文件进行相应的修改</p></li><li><p>配置文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件解释：根据上述文件，可以明显地将nginx.conf配置文件分为三部分</p><ul><li><p><strong>全局块</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Nginx服务器并发处理服务的关键配置,worker_processes值越大,可以支持的并发处理量也越多</span><br><span class="line"># 但是会受到硬件、软件等设备的制约,一般设置为当前计算机的CPU核心数</span><br><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure><p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数、进程pid存放路径、日志存放路径和类型以及配置文件的引入等</p></li><li><p><strong>events块</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    # 每个work process支持的最大连接数为1024</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用的设置包括是否开启对多work process下的网络连接进行序列化、是否允许同时接收多个网络连接、选取哪种事件驱动模型来处理连接请求、每个work process可以同时支持的最大连接数等。这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置</p></li><li><p><strong>http块</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是Nginx服务器配置中修改最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里<br><strong>http块还可以包括http全局块、server块</strong></p><ul><li>http全局块：配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等</li><li>server块：<br>server块和虚拟主机有密切关系。虚拟主机从用户角度看和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本<br>每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机<br>而每个server块也分为全局server块以及可以同时包含多个locaton块<ul><li>全局server块：最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置</li><li>location块：<br>一个server块可以配置多个location块<br>该块的主要作用是基于Nginx服务器接收到的请求字符串(例如server_name/uri-string)，对虚拟主机名称(也可以是IP别名)之外的字符串(例如前面的/uri-string)进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="Nginx配置实例-反向代理"><a href="#Nginx配置实例-反向代理" class="headerlink" title="Nginx配置实例-反向代理"></a>Nginx配置实例-反向代理</h2><ul><li><p>反向代理实例1</p><ul><li><p>最终需求：使用nginx反向代理，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 跳转到虚拟机的8080端口</p></li><li><p>实现步骤：</p><ul><li><p>测试端口8080准备：</p><ul><li>虚拟机安装Tomcat并启动(启动命令bin/startup.sh)</li><li>在mac中通过浏览器访问虚拟机Tomcat主页：<a href="http://172.16.85.201:8080" target="_blank" rel="noopener">http://172.16.85.201:8080</a></li></ul></li><li><p>修改host文件：在mac中修改hosts文件，将 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 映射到虚拟机地址172.16.85.201。此时可以通过 <a href="http://www.123.com:8080" target="_blank" rel="noopener">www.123.com:8080</a> 访问到测试端口</p></li><li><p>修改Nginx配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name 172.16.85.201;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最终测试</li></ul></li></ul></li></ul></li><li><p>反向代理实例2</p><ul><li><p>最终需求：使用Nginx反向代理，根据访问的路径跳转到不同端口的服务中。其中Nginx监听端口为 9001，要求访问<a href="http://172.16.85.201:9001/edu/" target="_blank" rel="noopener">http://172.16.85.201:9001/edu/</a>直接跳转到172.16.85.201:8080，访问<a href="http://172.16.85.201:9001/vod/" target="_blank" rel="noopener">http://172.16.85.201:9001/vod/</a>直接跳转到172.16.85.201:8081</p></li><li><p>实现步骤：</p><ul><li><p>准备两个Tomcat服务器，一个8080端口，一个8081端口；创建文件夹和测试页面(在8080的Tomcat目录下创建edu目录，其内创建一个a.html测试页面;同理在8081的Tomcat目录下创建vod目录，其内创建一个b.html测试页面)</p></li><li><p>修改Nginx配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  9001;</span><br><span class="line">    server_name 172.16.85.201;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;edu&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ &#x2F;vod&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别测试网址&lt;172.16.85.201:9001/edu/a.html&gt;和&lt;172.16.85.201:9001/vod/b.html&gt;，验证结果</p></li></ul></li></ul></li><li><p>Location指令说明</p><ul><li><p>用途：用于匹配URL</p></li><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~] uri &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数说明：</p><ul><li>= ：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求</li><li>~：用于表示uri包含正则表达式，并且区分大小写</li><li>~*：用于表示uri包含正则表达式，并且不区分大小写</li><li>^~：用于不含正则表达式的uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的 location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配</li><li><strong>如果uri包含正则表达式，则必须要有<del>或者</del>*标识</strong></li></ul></li></ul></li></ul><h2 id="Nginx配置实例-负载均衡"><a href="#Nginx配置实例-负载均衡" class="headerlink" title="Nginx配置实例-负载均衡"></a>Nginx配置实例-负载均衡</h2><ul><li><p>负载均衡示例</p><ul><li><p>最终效果：浏览器访问<a href="http://172.16.85.201/edu.a.html" target="_blank" rel="noopener">http://172.16.85.201/edu.a.html</a>，能够将请求负载均衡到8080端口和8081端口</p></li><li><p>准备工作：</p><ul><li>准备一台虚拟机，装上两个Tomcat服务器，端口为8080和8081</li><li>在两个Tomcat服务器的webapps目录中，创建edu文件夹和其中的a.html用于测试</li></ul></li><li><p>在Nginx的配置文件中进行负载均衡的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">  server 172.16.85.201:8080;</span><br><span class="line">  server 172.16.85.201:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  172.16.85.201;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass  http://myserver;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Nginx分配服务器策略</p><ul><li><p>轮询(默认)：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p></li><li><p>weight(权重)：weight代表权重，默认为1，权重越高被分配的客户端越多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">  server 172.16.85.201:8080 weight=10;</span><br><span class="line">  server 172.16.85.201:8081 weight=20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash(适用于session)：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 172.16.85.201:8080;</span><br><span class="line">  server 172.16.85.201:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair(第三方,公平)：按后端服务器的响应时间来分配请求，响应时间短的优先分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">  server 172.16.85.201:8080;</span><br><span class="line">  server 172.16.85.201:8081;</span><br><span class="line">  fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Nginx配置实例-动静分离"><a href="#Nginx配置实例-动静分离" class="headerlink" title="Nginx配置实例-动静分离"></a>Nginx配置实例-动静分离</h2><ul><li><p>基本介绍：Nginx动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和<br>静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种：一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过nginx来分开</p></li><li><p>动静分离示例</p><ul><li><p>准备工作：在虚拟机linux系统的本地文件系统中准备静态资源，用于进行访问</p></li><li><p>Nginx进行动静分离的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  172.16.85.201;</span><br><span class="line"></span><br><span class="line">  location /text/ &#123;</span><br><span class="line">    root    /opt/data/;</span><br><span class="line">    index   index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /image/ &#123;</span><br><span class="line">    root    /opt/data/;</span><br><span class="line">    # 开启该配置后,访问/image/页面会展示当前目录下的文件基本信息列表</span><br><span class="line">    autoindex   on;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Nginx搭建高可用集群"><a href="#Nginx搭建高可用集群" class="headerlink" title="Nginx搭建高可用集群"></a>Nginx搭建高可用集群</h2><ul><li><p>准备工作：</p><ul><li><p>准备两台Linux虚拟机，各自都装上Nginx</p></li><li><p>在两台服务器安装keepalived：yum install keepalived -y</p></li><li><p>修改/etc/keepalived下的keepalived.conf配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">  notification_email &#123;</span><br><span class="line">    acassen@firewall.loc</span><br><span class="line">    failover@firewall.loc</span><br><span class="line">    sysadmin@firewall.loc</span><br><span class="line">  &#125;</span><br><span class="line">  notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">  smtp_server 172.16.85.201</span><br><span class="line">  smtp_connect_timeout 30</span><br><span class="line">  router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">  script "/opt/data/nginx_check.sh"</span><br><span class="line">  #(检测脚本执行的间隔)</span><br><span class="line">  interval 2</span><br><span class="line">  weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  # 备份服务器上将MASTER改为BACKUP</span><br><span class="line">  state MASTER</span><br><span class="line">  # 网卡</span><br><span class="line">  interface ens33</span><br><span class="line">  # 主、备机的virtual_router_id必须相同</span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  # 主、备机取不同的优先级,主机值较大,备份机值较小</span><br><span class="line">  priority 100</span><br><span class="line">  advert_int 1</span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 1111</span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    # VRRP H 虚拟地址</span><br><span class="line">    172.16.85.250</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在/opt/data下添加检测脚本文件nginx_check.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">A=`ps -C nginx –no-header |wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>启动两台Linux虚拟机上的nginx和keepalived</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx(/usr/<span class="built_in">local</span>/nginx/sbin)</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动keepalived服务</span></span><br><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></figure></li><li><p>输入ifconfig可以查看到虚拟ip——172.16.85.250</p></li></ul></li><li><p>测试</p><ul><li>在主机上访问172.16.85.250，nginx主页显示正常</li><li>把主服务器(172.16.85.250)的nginx和keepalived停止</li><li>再次访问172.16.85.250，主页依旧正常</li></ul></li></ul><h2 id="Nginx原理简述"><a href="#Nginx原理简述" class="headerlink" title="Nginx原理简述"></a>Nginx原理简述</h2><ul><li>Nginx主要采用master-worker模式</li><li>一个master和多个worker的好处：<ul><li>可以使用nginx –s reload热部署</li><li>每个worker是独立的进程，如果有其中的一个worker出现问题，其他worker可继续进行争抢，实现请求过程，不会造成服务中断</li></ul></li><li>worker个数：和服务器cpu数相等</li><li>发送请求，占用了多少worker的连接数：2/4</li><li>Nginx有一个master，有四个worker，每个worker支持最大的连接数1024，那么支持的最大并发数是多少?<br>普通的静态访问最大并发数是worker_connections * worker_processes / 2；如果作为反向代理，最大并发数量应该是worker_connections * worker_processes / 4</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Middleware </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
