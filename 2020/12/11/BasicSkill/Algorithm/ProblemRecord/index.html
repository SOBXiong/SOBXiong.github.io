<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>刷题记录 - SOBXiong的博客</title>
  
    <meta name="keywords" content="BasicSkill,LeetCode题解">
  
  
    <meta name="description" content="内容
10正则表达式匹配
218天际线问题
220存在重复元素III
239滑动窗口最大值
241为运算表达式设计优先级
264丑数II
279完全平方数
282给表达式添加运算符
316去除重复字母
321拼接最大数
338比特位计数
354俄罗斯套娃信封问题
395至少有K个重复字符的最长子串
493翻转对
...">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png'></i>
          
          
            SOBXiong
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/12/11/BasicSkill/Algorithm/ProblemRecord/">
      刷题记录
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="http://xiongjc.top" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/hdImg_f757fa7e0fd65077ce52d251fc7a01d815860762755.jpg">
    <p>SOBXiong</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年12月11日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><a href="#10正则表达式匹配">10正则表达式匹配</a></li>
<li><a href="#218天际线问题">218天际线问题</a></li>
<li><a href="#220存在重复元素III">220存在重复元素III</a></li>
<li><a href="#239滑动窗口最大值">239滑动窗口最大值</a></li>
<li><a href="#241为运算表达式设计优先级">241为运算表达式设计优先级</a></li>
<li><a href="#264丑数II">264丑数II</a></li>
<li><a href="#279完全平方数">279完全平方数</a></li>
<li><a href="#282给表达式添加运算符">282给表达式添加运算符</a></li>
<li><a href="#316去除重复字母">316去除重复字母</a></li>
<li><a href="#321拼接最大数">321拼接最大数</a></li>
<li><a href="#338比特位计数">338比特位计数</a></li>
<li><a href="#354俄罗斯套娃信封问题">354俄罗斯套娃信封问题</a></li>
<li><a href="#395至少有K个重复字符的最长子串">395至少有K个重复字符的最长子串</a></li>
<li><a href="#493翻转对">493翻转对</a></li>
<li><a href="#514自由之路">514自由之路</a></li>
<li><a href="#621任务调度器">621任务调度器</a></li>
<li><a href="#659分割数组为连续子序列">659分割数组为连续子序列</a></li>
<li><a href="#803打砖块">803打砖块</a></li>
<li><a href="#947移除最多的同行或同列石头">947移除最多的同行或同列石头</a></li>
<li><a href="#959由斜杠划分区域">959由斜杠划分区域</a></li>
<li><a href="#995K连续位的最小翻转次数">995K连续位的最小翻转次数</a></li>
<li><a href="#1178猜字谜">1178猜字谜</a></li>
<li><a href="#1438绝对差不超过限制的最长连续子数组">1438绝对差不超过限制的最长连续子数组</a></li>
<li><a href="#1489找到最小生成树里的关键边和伪关键边">1489找到最小生成树里的关键边和伪关键边</a></li>
<li><a href="#1631最小体力消耗路径">1631最小体力消耗路径</a></li>
<li><a href="#1776车队II">1776车队II</a></li>
<li><a href="#剑指Offer36二叉搜索树与双向链表">剑指Offer36二叉搜索树与双向链表</a></li>
<li><a href="#剑指Offer37序列化二叉树">剑指Offer37序列化二叉树</a></li>
<li><a href="#剑指Offer39数组中出现次数超过一半的数字">剑指Offer39数组中出现次数超过一半的数字</a></li>
<li><a href="#剑指Offer48最长不含重复字符的子字符串">剑指Offer48最长不含重复字符的子字符串</a></li>
<li><a href="#剑指Offer51数组中的逆序对">剑指Offer51数组中的逆序对</a></li>
<li><a href="#剑指Offer56数组中数字出现的次数I">剑指Offer56数组中数字出现的次数I</a></li>
<li><a href="#剑指Offer56数组中数字出现的次数II">剑指Offer56数组中数字出现的次数II</a></li>
<li><a href="#剑指Offer60n个骰子的点数">剑指Offer60n个骰子的点数</a></li>
<li><a href="#剑指Offer62圆圈中最后剩下的数字">剑指Offer62圆圈中最后剩下的数字</a></li>
</ul>
<a id="more"></a>

<h2 id="10正则表达式匹配"><a href="#10正则表达式匹配" class="headerlink" title="10正则表达式匹配"></a>10正则表达式匹配</h2><ul>
<li><p>问题描述：<br><img src="Question10_p1.png" alt="10正则表达式匹配(1)"><br><img src="Question10_p2.png" alt="10正则表达式匹配(2)"></p>
</li>
<li><p>解法：动态规划</p>
<blockquote>
<p>首先找出动态转移方程，设dp[i][j]表示串s的前i个字符和串p的前j个字符能否匹配<br>那么很容易想到p[j - 1]除了’<em>‘的情况<br>dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’) ———— 都是字母和’.’匹配任意一个字符的情况<br>如果是’</em>‘，情况有些复杂，但只有两种情况：</p>
<ol>
<li>匹配s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配：dp[i][j] = dp[i - 1][j] &amp;&amp; matches(s[i - 1], p[j - 2]) ———— 还有”.*”的组合</li>
<li>不匹配字符，将该组合扔掉，不再进行匹配：dp[i][j] = dp[i][j - 2]</li>
</ol>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len_s = s.<span class="built_in">size</span>(), len_p = p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(len_s + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len_p + <span class="number">1</span>))</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">auto</span> matches = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len_s; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len_p; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配0个</span></span><br><span class="line">        dp[i][j] = dp[i][j] || dp[i][j - <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 匹配一个或多个</span></span><br><span class="line">        <span class="keyword">if</span> (matches(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">          dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matches(i, j)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[len_s][len_p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="218天际线问题"><a href="#218天际线问题" class="headerlink" title="218天际线问题"></a>218天际线问题</h2><ul>
<li><p>问题描述：<br><img src="Question218.png" alt="218天际线问题"></p>
</li>
<li><p>解法1：分治法(归并的思想)<br>每次将问题划分成更小的子问题，当问题分解到单个建筑时进行解决。如果单个建筑的输入信息为[x1, x2, h]，那么返回[[x1, h], [x2, 0]]。分解完后，进入归并Merge阶段。归并的关键是从轮廓看去只能看到不同的高度，归并模拟过程如下：</p>
<blockquote>
<p>假如有以下划分好的结果：<br>skyline1 = {(1, 11),  (3, 13),  (9, 0),  (12, 7),  (16, 0)}<br>skyline2 = {(14, 3),  (19, 18), (22, 3), (23, 13),  (29, 0)}<br>假设i、j分别表示skyline1、skyline2的当前遍历下标，h1、h2分别代表skyline1、skyline2当前的高度<br>首先比较(1, 11)和(14, 3)，由于1 &lt; 14，选取(1, 11)，h1置为当前大小11，hmax = max(h1, h2) = 11，ans结果集加入(1, 11)，i++<br>之后比较(3, 13)和(14, 3)，h1置为当前大小13，hmax = max(h1, h2) = 13，同理ans结果集加入(3, 13)，i++<br>…<br>直到(16, 0)，此时比较(16, 0)和(14, 3)，14 &lt; 3，选取(14, 3)，h2 = 3。而此时h1 = 7，h2 = 3，hmax = max(h1, h2) = 7，因此结果集加入(14, 7)，由于之前的结果集存在(12, 7)，所以(14, 7)不应该加入结果集，j++<br>比较(16, 0)和(19, 18)，此时16 &lt; 19，选取(16, 0)，h1 = 0。此时h1 = 0，h2 = 3，hmax = max(h1, h2) = 3。因此ans结果集加入(16, 3)，至此skyline1全部遍历完，只需将skyline2的剩余部分加入结果集</p>
</blockquote>
<p>代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">divideAndConquer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="comment">// 如果left、right一致,相当于只处理单个建筑</span></span><br><span class="line">  <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">    ans.push_back(&#123;buildings[left][<span class="number">0</span>], buildings[left][<span class="number">2</span>]&#125;);</span><br><span class="line">    ans.push_back(&#123;buildings[left][<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到中间下标</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归分治</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; leftAns = divideAndConquer(buildings, left, mid),</span><br><span class="line">        rightAns = divideAndConquer(buildings, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 定义下标和各自的高度变量</span></span><br><span class="line">    <span class="comment">// 每次都需要更新高度信息</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftAns.<span class="built_in">size</span>() &amp;&amp; j &lt; rightAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="comment">// 记录结果</span></span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 如果起始相同,做了简化</span></span><br><span class="line">      <span class="keyword">if</span> (leftAns[i][<span class="number">0</span>] == rightAns[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        h1 = leftAns[i][<span class="number">1</span>], h2 = rightAns[j][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = leftAns[i][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        i++, j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftAns[i][<span class="number">0</span>] &lt; rightAns[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 起始不同,取起始小的作为当前结果开头,取当前的最大高度为当前结果高度</span></span><br><span class="line">        h1 = leftAns[i][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = leftAns[i][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 起始不同,取起始小的作为当前结果开头,取当前的最大高度为当前结果高度</span></span><br><span class="line">        h2 = rightAns[j][<span class="number">1</span>];</span><br><span class="line">        cur[<span class="number">0</span>] = rightAns[j][<span class="number">0</span>], cur[<span class="number">1</span>] = <span class="built_in">max</span>(h1, h2);</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前结果集为空或当前结果与上次高度不同,加入结果集</span></span><br><span class="line">      <span class="keyword">if</span> (ans.empty() || ans.back()[<span class="number">1</span>] != cur[<span class="number">1</span>]) &#123;</span><br><span class="line">        ans.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次加入剩余的结果</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; leftAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; leftAns.<span class="built_in">size</span>(); ++k) ans.push_back(leftAns[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; rightAns.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; rightAns.<span class="built_in">size</span>(); ++k) ans.push_back(rightAns[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = buildings.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    ans.push_back(&#123;buildings[<span class="number">0</span>][<span class="number">0</span>], buildings[<span class="number">0</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">    ans.push_back(&#123;buildings[<span class="number">0</span>][<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> divideAndConquer(buildings, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：<br>使用从左向右的扫描，如果遇到左端点，将高度入堆，如果遇到右端点，将高度从堆中删除。还需使用last记录上一个转折点的信息，以示例1为例：</p>
<blockquote>
<p>端点排序如下(小技巧：使用正负区别左右端点)：<br>[2, -10], [3, -15], [5, -12], [7, 15], [9, 10], [12, 12], [15, -10], [19, -8], [20, 10], [24, 8]<br>设堆为q(用于存储当前能看到的最大高度,先加入0,用于启动)，结果集为ans，last[0]和last[1]分别保存上一个转折点的下标和高度<br>依次扫描，有：</p>
<ol>
<li>q中加入10{0, 10}，从q中取出最大高度为10 != last[1] = 0，last更新(last={2, 10})，ans中加入[2, 10]，此时and为{[2, 10]}</li>
<li>q中加入15{0, 10, 15}，从q中取出最大高度为15 != last[1] = 10，last更新(last={3, 15})，ans中加入[3, 15]，此时and为{[2, 10], [3, 15]}</li>
<li>q中加入12{0, 10, 12, 15}，从q中取出最大高度为15 = last[1] = 15，last无需更新，此时前面建筑高度挡住了后面建筑的高度且前面建筑未遇到右端点，ans不改动</li>
<li>q中减少15{0, 10, 12}，从q中取出最大高度为12 != last[1] = 15，last更新(last={7, 12})，ans中加入[7, 12]，此时and为{[2, 10], [3, 15], [7, 12]}</li>
<li>q中减少10{0, 12}，从q中取出最大高度为12 = last[1] = 12，last无需更新，ans不改动</li>
<li>q中减少12{0}，从q中取出最大高度为0 != last[1] = 12，last更新(last={12, 0})，ans中加入[12, 0]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0]}</li>
<li>q中加入10{0, 10}，从q中取出最大高度为10 != last[1] = 0，last更新(last={15, 10})，ans中加入[15, 10]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10]}</li>
<li>q中加入8{0, 8, 10}，从q中取出最大高度为10 = last[1] = 10，last无需更新，ans不改动</li>
<li>q中减少10{0, 8}，从q中取出最大高度为8 != last[1] = 10，last更新(last={20, 8})，ans中加入[20, 8]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8]}</li>
<li>q中减少8{0}，从q中中取出最大高度为0 != last[1] = 8，last更新(last={24, 0})，ans中加入[24, 0]，此时and为{[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]}</li>
</ol>
</blockquote>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;buildings)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; all;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;building : buildings) &#123;</span><br><span class="line">    all.insert(&#123;building[<span class="number">0</span>], -building[<span class="number">2</span>]&#125;);</span><br><span class="line">    all.insert(&#123;building[<span class="number">1</span>], building[<span class="number">2</span>]&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">height</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;data : all) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.second &lt; <span class="number">0</span>) <span class="built_in">height</span>.insert(-data.second);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">height</span>.erase(<span class="built_in">height</span>.<span class="built_in">find</span>(data.second));</span><br><span class="line">    <span class="keyword">int</span> maxHeight = *<span class="built_in">height</span>.rbegin();</span><br><span class="line">    <span class="keyword">if</span> (last[<span class="number">1</span>] != maxHeight) &#123;</span><br><span class="line">      last[<span class="number">0</span>] = data.first;</span><br><span class="line">      last[<span class="number">1</span>] = maxHeight;</span><br><span class="line">      ans.emplace_back(last);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="220存在重复元素III"><a href="#220存在重复元素III" class="headerlink" title="220存在重复元素III"></a>220存在重复元素III</h2><ul>
<li><p>题目描述：<br><img src="Question220.png" alt="220存在重复元素III"></p>
</li>
<li><p>解法1：搜索树</p>
<blockquote>
<p>该题暴力解法会超时，考虑一个长度为k的滑动窗口，每次只需要在插入元素前查看是否在当前滑动窗口中是否存在大于等于nums[i] - t并且小于等于nums[i] + t的元素即可，如果存在则返回true<br>否则，插入元素，并维持滑动窗口的大小<br>在c++中set以及multiset都有一个upper_bound()函数用于找到首个大于某值的数，因此可以使用该方式来加快查找速度</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">set</span>.upper_bound((<span class="keyword">long</span>)nums[i] - t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">set</span>.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + t) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>.insert(nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>) <span class="built_in">set</span>.erase(<span class="built_in">set</span>.<span class="built_in">find</span>(nums[i - k]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：桶</p>
<blockquote>
<p>借鉴桶排序的思想，可以把元素根据t+1分割(此时最大相差t)<br>如果同在一个桶内，就相当于满足条件<br>如果不再同一个桶内，那就需要找前一个桶和后一个桶，检验是否绝对值相差t<br>比如t为3，由于除的特性，-1 / 3 = 0，但是应该划分到-1，因此需要特殊求值，类似于getId函数<br>当桶里的所有元素总数等于k+1，那么就需要把最前添加的元素从桶中删除</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num &lt; <span class="number">0</span> ? (num + <span class="number">1</span>) / w - <span class="number">1</span> : num / w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span> || k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">long</span> w = (<span class="keyword">long</span>)t + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> curId = getId(nums[i], w);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>.count(curId)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">map</span>.<span class="built_in">find</span>(curId - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; nums[i] - iter-&gt;second &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    iter = <span class="built_in">map</span>.<span class="built_in">find</span>(curId + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; iter-&gt;second - nums[i] &lt;= t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">map</span>.emplace(curId, nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">size</span>() == k + <span class="number">1</span>) <span class="built_in">map</span>.erase(<span class="built_in">map</span>.<span class="built_in">find</span>(getId(nums[i - k], w)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="239滑动窗口最大值"><a href="#239滑动窗口最大值" class="headerlink" title="239滑动窗口最大值"></a>239滑动窗口最大值</h2><ul>
<li><p>题目描述：<br><img src="Question239.png" alt="239滑动窗口最大值"></p>
</li>
<li><p>解法1：优先队列</p>
<blockquote>
<p>很容易就想到使用大顶堆来实现，但每次都需要删除滑出的数，加入新的数，但大顶堆不支持随机删除，只支持删除顶部元素。因此转而想到使用multiset(多重set)完成，但由于需要较多的删除、添加操作，会导致较低的效率<br>有一种更简单的做法，保留使用堆(priority_queue)的方式，但是延迟删除————即如果当前滑出的数如果是最大数才删除，因为如果滑出的数过小，就是一个耗时的操作，没有必要</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">if</span> (k == len) <span class="keyword">return</span> &#123;*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())&#125;;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; window;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    window.emplace(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  ans.reserve(len - k + <span class="number">1</span>);</span><br><span class="line">  ans.push_back(window.top().first);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">    window.emplace(nums[i], i);</span><br><span class="line">    <span class="keyword">while</span> (window.top().second &lt;= i - k) window.pop();</span><br><span class="line">    ans.push_back(window.top().first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：单调队列</p>
<blockquote>
<p>优先队列方式其实也多增加了无用的数据，因为如果后面的数比前面的数大，其实一个区间内的最大只是由后面的数决定的<br>因此可以采用单调队列的方式，由于可能会有重复值的原因，因此采取记录下标值的方式。总体规律是单调队列中index小的值大，每次如果数值小于等于队尾的值，可以添加到队尾————因为可能会把前面的都熬死；如果大于队尾的值，那么就可以消灭任何小于等于其的数值————因为它寿命大而且可以替代区间内的最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">if</span> (k == len) <span class="keyword">return</span> &#123;*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())&#125;;</span><br><span class="line">  <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dQueue;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dQueue.empty() || nums[dQueue.back()] &gt; nums[i]) dQueue.push_back(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!dQueue.empty() &amp;&amp; nums[dQueue.back()] &lt;= nums[i]) dQueue.pop_back();</span><br><span class="line">      dQueue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(len - k + <span class="number">1</span>);</span><br><span class="line">  ans.push_back(nums[dQueue.front()]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dQueue.front() &lt;= i - k) dQueue.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (dQueue.empty() || nums[dQueue.back()] &gt; nums[i]) dQueue.push_back(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!dQueue.empty() &amp;&amp; nums[dQueue.back()] &lt;= nums[i]) dQueue.pop_back();</span><br><span class="line">      dQueue.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(nums[dQueue.front()]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="241为运算表达式设计优先级"><a href="#241为运算表达式设计优先级" class="headerlink" title="241为运算表达式设计优先级"></a>241为运算表达式设计优先级</h2><ul>
<li><p>题目描述：<br><img src="Question241.png" alt="241为运算表达式设计优先级"></p>
</li>
<li><p>解法1：递归 + 记忆化</p>
<blockquote>
<p>每次都把字符串根据中间的运算符拆分成两半，再递归计算左右部分的数值，再在外部根据左右计算出的数值进行组合得到可能的结果<br>例如：2*3-4*5<br>依次拆分成2以及3-4*5、2*3以及4*5、2*3-4以及5<br>以第一个拆分为例，首先2直接得出<br>接着拆分3-4*5，有3以及4*5、3-4以及5<br>最终3-4*5就有两种结果，-17以及-5<br>最终与2结合，得到-34和-10</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;left, <span class="keyword">const</span> <span class="keyword">int</span> &amp;right, <span class="keyword">const</span> <span class="keyword">char</span> &amp;op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideAndConcur</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;input, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;memo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (memo.<span class="built_in">find</span>(input) != memo.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> len = input.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">bool</span> hasOp = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOperator(input[i])) &#123;</span><br><span class="line">      hasOp = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">string</span> left = input.substr(<span class="number">0</span>, i), right = input.substr(i + <span class="number">1</span>, len - i - <span class="number">1</span>);</span><br><span class="line">      divideAndConcur(left, memo);</span><br><span class="line">      divideAndConcur(right, memo);</span><br><span class="line">      <span class="keyword">auto</span> iter = memo.<span class="built_in">find</span>(input);</span><br><span class="line">      <span class="keyword">if</span> (iter == memo.<span class="built_in">end</span>()) memo.emplace(input, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;l : memo[left]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;r : memo[right]) &#123;</span><br><span class="line">          memo[input].push_back(calculate(l, r, input[i]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!hasOp) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = atoi(input.c_str());</span><br><span class="line">    memo.insert(&#123;input, &#123;data&#125;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">  divideAndConcur(input, memo);</span><br><span class="line">  <span class="keyword">return</span> memo[input];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：动态规划</p>
<blockquote>
<p>动态规划方式十分巧妙，首先把所有的数字和操作符都识别出来并存储<br>例如：2*3-4*5<br>那么数字为2、3、4、5，操作符为*、-、*<br>接着定义dp[i][j]为从第i个到第j个数字所构成的结果<br>按照定义，则初始状态<code>dp[i][i] = nums[i]</code><br>动态转移方程为<code>dp[i][j] = dp[i][s] op[s] dp[s+1][j]</code><br>方程表示dp[i][j]的结果为dp[i][s]集合中元素与dp[s+1][j]集合中元素通过操作符op[s]产生的结果集合</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;left, <span class="keyword">const</span> <span class="keyword">int</span> &amp;right, <span class="keyword">const</span> <span class="keyword">char</span> &amp;op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">      <span class="keyword">return</span> left - right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">      <span class="keyword">return</span> left * right;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ops;</span><br><span class="line">  <span class="keyword">int</span> lastOpIndex = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isOperator(input[i])) &#123;</span><br><span class="line">      ops.push_back(input[i]);</span><br><span class="line">      <span class="built_in">string</span> num = input.substr(lastOpIndex + <span class="number">1</span>, i - lastOpIndex);</span><br><span class="line">      nums.push_back(atoi(num.c_str()));</span><br><span class="line">      lastOpIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一个数字的获取</span></span><br><span class="line">  <span class="built_in">string</span> num = input.substr(lastOpIndex + <span class="number">1</span>, input.<span class="built_in">size</span>() - lastOpIndex);</span><br><span class="line">  nums.push_back(atoi(num.c_str()));</span><br><span class="line">  <span class="comment">// 没有操作符</span></span><br><span class="line">  <span class="keyword">if</span> (lastOpIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">size</span>))</span></span>;</span><br><span class="line">  <span class="comment">// 设置dp[i][i]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">    dp[i][i].push_back(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数字数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> N = <span class="number">2</span>; N &lt;= <span class="built_in">size</span>; ++N) &#123;</span><br><span class="line">    <span class="comment">// 起始下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">// 结束下标</span></span><br><span class="line">      <span class="keyword">int</span> j = i + N - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= <span class="built_in">size</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 迭代的下标</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> s = i; s &lt; j; ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;lNum : dp[i][s]) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;rNum : dp[s + <span class="number">1</span>][j]) &#123;</span><br><span class="line">            dp[i][j].push_back(calculate(lNum, rNum, ops[s]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="264丑数II"><a href="#264丑数II" class="headerlink" title="264丑数II"></a>264丑数II</h2><ul>
<li><p>题目描述：<br><img src="Question264.png" alt="264丑数II"></p>
</li>
<li><p>解法：动态规划</p>
<blockquote>
<p>实际上更容易想到的方法是使用堆排序，把每次得到的数进行排序后，再得到最后的结果，但这种方法有一个巨大的问题————乘数的差距越来越大，后面有很大的数据空隙，很难匹配上，需要求得更多的数来弥合，或者对更多数先求2的乘数<br>还有一种更简单的方式————三指针法，记录当前指向因子分别为2、3和5的指针，之后每次求出这三个指针指向的丑数乘各自因子，取最小值，再更新等于最小值的指针为更大的丑数。这样每次不需要进行额外的计算，而且不用担心排序的问题</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uglyNum</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> index_2 = <span class="number">0</span>, index_3 = <span class="number">0</span>, index_5 = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num_2 = uglyNum[index_2] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = uglyNum[index_3] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> num_5 = uglyNum[index_5] * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> min_num = <span class="built_in">min</span>(num_2, <span class="built_in">min</span>(num_3, num_5));</span><br><span class="line">    uglyNum[++index] = min_num;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_2) index_2++;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_3) index_3++;</span><br><span class="line">    <span class="keyword">if</span> (min_num == num_5) index_5++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uglyNum[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="279完全平方数"><a href="#279完全平方数" class="headerlink" title="279完全平方数"></a>279完全平方数</h2><ul>
<li><p>题目描述：<br><img src="Question279.png" alt="279完全平方数"></p>
</li>
<li><p>解法：动态规划</p>
<blockquote>
<p>如果采用贪心法，每次减去最大的平方数，会导致一部分的错误结果————如12=9+1+1+1，而答案为12=4+4+4；采用动态规划时，可以利用上一次的结果进行迭代求解<br>dp[i] = min{dp[i-k] + 1} (k是平方数且i-k &gt;= 0)</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="282给表达式添加运算符"><a href="#282给表达式添加运算符" class="headerlink" title="282给表达式添加运算符"></a>282给表达式添加运算符</h2><ul>
<li><p>题目描述：<br><img src="Question282.png" alt="282给表达式添加运算符"></p>
</li>
<li><p>解法：回溯法</p>
<blockquote>
<p>由于没有直接的关联，只能使用回溯法遍历整个有效的搜索空间<br>由于’*‘的优先级与’+’与’-‘的优先级不同，最主要是解决该问题<br>比如235，2+3*5，当前的值(5,2+3)和上一次的操作数3<br>恢复结果为(5-3+3*5=17)，因此需要保留当前的结果和上一次的操作数<br>再考虑连乘的情况，5+2*3*5；计算第一个’*‘时，当前值(7)，上次操作数(2)，此时恢复为(7-2+2*3=11)；但在计算第二个’*‘时，当前值(11)，上次操作数(2)，此时的结果无法恢复，所以乘法需要单独计算上一次的操作数————将整个连乘的结果当前上一次的操作数，此时第二次的情况变为当前值(11)，上次操作数(6)，恢复结果(11-6+6*5=35)<br>其次，由于如果每次传递string的值，复制的开销过大，因此可以使用引用传递，每次改变后在恢复回原样以加速(resize()恢复长度)</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;num, <span class="keyword">const</span> <span class="keyword">int</span> &amp;target, <span class="keyword">int</span> curIndex, <span class="keyword">long</span> curNum, <span class="keyword">long</span> lastNum, <span class="built_in">string</span> &amp;curStr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 递归出口,遍历完所有数字字符</span></span><br><span class="line">  <span class="keyword">if</span> (curIndex == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curNum == target) ans.push_back(curStr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历可能的截取数字</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = curIndex; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 截取数字</span></span><br><span class="line">    <span class="built_in">string</span> tempStr = num.substr(curIndex, i - curIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> tempNum = stol(tempStr);</span><br><span class="line">    <span class="comment">// 获取当前串长,用于恢复</span></span><br><span class="line">    <span class="keyword">int</span> len = curStr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (curIndex == <span class="number">0</span>) &#123; <span class="comment">// 刚开始</span></span><br><span class="line">      curStr += tempStr;</span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, tempNum, tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 考虑符号</span></span><br><span class="line">      <span class="comment">// +</span></span><br><span class="line">      curStr += <span class="string">'+'</span> + tempStr;</span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum + tempNum, tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -</span></span><br><span class="line">      curStr += <span class="string">'-'</span> + tempStr;</span><br><span class="line">      <span class="comment">// 将'-'转变为'+',形式统一</span></span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum - tempNum, -tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// *</span></span><br><span class="line">      curStr += <span class="string">'*'</span> + tempStr;</span><br><span class="line">      <span class="comment">// 如果是'*'需要将乘的结果作为更大的当前值(而不是当前值),这用于后面可能接着的'*'</span></span><br><span class="line">      backTrack(num, target, i + <span class="number">1</span>, curNum - lastNum + lastNum * tempNum, lastNum * tempNum, curStr);</span><br><span class="line">      curStr.resize(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不允许以0开头的多位数</span></span><br><span class="line">    <span class="keyword">if</span> (!tempNum) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">addOperators</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">string</span> curStr;</span><br><span class="line">  backTrack(num, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, curStr);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="316去除重复字母"><a href="#316去除重复字母" class="headerlink" title="316去除重复字母"></a>316去除重复字母</h2><ul>
<li><p>题目描述：<br><img src="Question316.png" alt="316去除重复字母"></p>
</li>
<li><p>解法：贪心 + 单调栈</p>
<blockquote>
<p>先统计字母最后出现的下标，这用于确定是否还会碰到<br>接着利用贪心法，遍历字符，如果已有这个字符则跳过<br>否则判断当前栈是否非空，如果非空再判断当前字符是否字典序小于栈顶<br>如果小于栈顶，并且目前处于栈顶的字符后面还能遇到，那么就可以弹出栈顶<br>最终将字符压栈，最终结果就是栈中的顺序<br>可采用二进制移位技巧和利用string代替stack进行优化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lastIndex</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>(), bitmask = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span> ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    lastIndex[s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="comment">// 如果存在一样的字符,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (bitmask &amp; (<span class="number">1</span> &lt;&lt; (s[i] - <span class="string">'a'</span>))) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 非空 栈顶字典序大 以后还能遇到栈顶字符</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.empty() &amp;&amp; ans.back() &gt; s[i] &amp;&amp; lastIndex[ans.back() - <span class="string">'a'</span>] &gt; i) &#123;</span><br><span class="line">      <span class="comment">// 删除字符标记</span></span><br><span class="line">      <span class="keyword">int</span> mask = INT_MAX - (<span class="number">1</span> &lt;&lt; (ans.back() - <span class="string">'a'</span>));</span><br><span class="line">      bitmask &amp;= mask;</span><br><span class="line">      ans.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(s[i]);</span><br><span class="line">    <span class="comment">// 添加字符标记</span></span><br><span class="line">    bitmask |= <span class="number">1</span> &lt;&lt; (s[i] - <span class="string">'a'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="321拼接最大数"><a href="#321拼接最大数" class="headerlink" title="321拼接最大数"></a>321拼接最大数</h2><ul>
<li><p>题目描述：<br><img src="Question321.png" alt="321拼接最大数"></p>
</li>
<li><p>解法：单调栈</p>
<blockquote>
<p>由于结果由两个序列给出，因此将k个数分隔，一部分由m给出，另一部分由n给出<br>这样就可以分别对m和n利用单调栈求出指定长度的最优解<br>接着按照能使结果最优的方式合并得到的两个序列即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">makeSubSequence</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> targetLen)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 特殊情况处理</span></span><br><span class="line">  <span class="keyword">if</span> (!targetLen) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (targetLen == <span class="number">1</span>) <span class="keyword">return</span> &#123; *max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) &#125;;</span><br><span class="line">  <span class="keyword">if</span> (targetLen == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(targetLen);</span><br><span class="line">  <span class="comment">// 单调栈</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 如果非空,并且遍历值大于最后值,并且删除后长度符合targetLen</span></span><br><span class="line">    <span class="keyword">while</span> (!ans.empty() &amp;&amp; ans.back() &lt; nums[i] &amp;&amp; ans.<span class="built_in">size</span>() + nums.<span class="built_in">size</span>() - i &gt; targetLen) ans.pop_back();</span><br><span class="line">    <span class="comment">// 未满则添加</span></span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &lt; targetLen) ans.push_back(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence1, <span class="keyword">int</span> index1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence2, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = subsequence1.<span class="built_in">size</span>(), y = subsequence2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (index1 &lt; x &amp;&amp; index2 &lt; y) &#123;</span><br><span class="line">    <span class="keyword">int</span> difference = subsequence1[index1] - subsequence2[index2];</span><br><span class="line">    <span class="keyword">if</span> (difference != <span class="number">0</span>) <span class="keyword">return</span> difference;</span><br><span class="line">    index1++;</span><br><span class="line">    index2++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果都相同,返回长的</span></span><br><span class="line">  <span class="keyword">return</span> (x - index1) - (y - index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;subsequence2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = subsequence1.<span class="built_in">size</span>(), y = subsequence2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span> subsequence2;</span><br><span class="line">  <span class="keyword">if</span> (!y) <span class="keyword">return</span> subsequence1;</span><br><span class="line">  <span class="keyword">int</span> mergeLength = x + y;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(mergeLength)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mergeLength; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compare(subsequence1, index1, subsequence2, index2) &gt; <span class="number">0</span>) merged[i] = subsequence1[index1++];</span><br><span class="line">    <span class="keyword">else</span> merged[i] = subsequence2[index2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">int</span> len1 = nums1.<span class="built_in">size</span>(), len2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    <span class="comment">// 不满足长度,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &lt; i || len2 &lt; k - i) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l = makeSubSequence(nums1, i);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r = makeSubSequence(nums2, k - i);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merged = merge(l, r);</span><br><span class="line">    <span class="keyword">if</span> (compare(merged, <span class="number">0</span>, ans, <span class="number">0</span>) &gt; <span class="number">0</span>) ans = merged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="338比特位计数"><a href="#338比特位计数" class="headerlink" title="338比特位计数"></a>338比特位计数</h2><ul>
<li><p>题目描述：<br><img src="Question338.png" alt="338比特位计数"></p>
</li>
<li><p>解法：动态规划</p>
<blockquote>
<p>考虑最高位的情况，如果一个数A有n个1的bit位，那么在A的bitSet最高位置1(第一个不是1的置)，那么B就有n+1个1的bit位<br>dp[0] = 0<br>dp[1] = 1(2^0)<br>dp[2] = 1(2^1)<br>dp[3] = dp[1] + 1 = 2<br>dp[4] = 1(2^2)<br>dp[5] = dp[1] + 1 = 2<br>因此找到规律有，2^n数bit位为1的共有一位，而如果满足该条件，则A&amp;(A - 1)为0，每次记录最高位的值，用于找到差<br><code>dp[i] = dp[i - highBitNum] + 1(dp[0] = 0)</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="comment">// 为2^n</span></span><br><span class="line">    <span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      highBit = i;</span><br><span class="line">    &#125;</span><br><span class="line">    bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="354俄罗斯套娃信封问题"><a href="#354俄罗斯套娃信封问题" class="headerlink" title="354俄罗斯套娃信封问题"></a>354俄罗斯套娃信封问题</h2><ul>
<li><p>题目描述：<br><img src="Question354.png" alt="354俄罗斯套娃信封问题"></p>
</li>
<li><p>解法1：朴素动态规划</p>
<blockquote>
<p>由于需要在二维数组上组成一个递增的序列(严格每维大于)，因此需要固定一维(先按第一维升序)<br>如果固定了一个维，那么再看第二维，由于如果第二维降序，那么原题就转化成了求第二维数组的最长递增子序列(如果是升序,那么会因为第一维相同而导致不能确定)<br>接着就可以列出动态转移方程：<br><code>dp[0] = 1</code><br><code>dp[i] = dp[j] + 1 (如果nums[i] &gt; nums[j],0 &lt;= j &lt; i)</code><br>接着返回dp中的最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;envelopes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = envelopes.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">  sort(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[<span class="number">0</span>] != v2[<span class="number">0</span>]) <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>] &gt; v2[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *max_element(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：二分法的动态规划</p>
<blockquote>
<p>设dp表示序列前i个元素组成的最长严格递增子序列，假设dp长度为j，那么dp[j - 1]表示末尾元素的最小值<br>进行遍历时，考虑当前元素num<br>如果num大于dp的末尾元素，那么num可以接在dp之后形成更长的严格递增子序列<br>否则找出dp中比num严格小的最大元素dp[j0]，则dp[j0] &lt; num &lt;= dp[j0 + 1]，那么dp[j0 + 1]可以替换为num————如果不在末尾，可以任意替换，因为不起决定作用；如果在末尾，那么可以减少末尾的值，可能导致后面的dp增长</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = envelopes.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  sort(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[<span class="number">0</span>] != v2[<span class="number">0</span>]) <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">1</span>] &gt; v2[<span class="number">1</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = &#123;envelopes[<span class="number">0</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (num &gt; dp.back()) dp.push_back(num);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = lower_bound(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), num);</span><br><span class="line">      *it = num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="395至少有K个重复字符的最长子串"><a href="#395至少有K个重复字符的最长子串" class="headerlink" title="395至少有K个重复字符的最长子串"></a>395至少有K个重复字符的最长子串</h2><ul>
<li><p>题目描述：<br><img src="Question395.png" alt="395至少有K个重复字符的最长子串"></p>
</li>
<li><p>解法1：分治</p>
<blockquote>
<p>一个思想是找到数目小于K个的字符，然后通过该字符将原字符串进行分割<br>分割后的子字符串再如此，符合条件的递归出口为字符串中每个字符的数目都大于K</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果字符串长度小于k,没有必要继续搜索</span></span><br><span class="line">  <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 统计每个字符的个数</span></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cNums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">    cNums[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找第一个不符合个数的字符</span></span><br><span class="line">  <span class="keyword">char</span> targetLessChar = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cNums[i] &amp;&amp; cNums[i] &lt; k) targetLessChar = i + <span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果找不到,说明每个字母都大于等于K个,直接返回当前字符串长度</span></span><br><span class="line">  <span class="keyword">if</span> (!targetLessChar) <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 记录原始left</span></span><br><span class="line">    <span class="keyword">int</span> beforeLeft = left;</span><br><span class="line">    <span class="comment">// 查找不符合字符的出现位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == targetLessChar) &#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        ans = <span class="built_in">max</span>(dfs(s, left, i - <span class="number">1</span>, k), ans);</span><br><span class="line">        <span class="comment">// left移动</span></span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原始left没有改动,说明这一段没有出现不符合字符,应该直接递归,并退出</span></span><br><span class="line">    <span class="keyword">if</span> (left == beforeLeft) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(dfs(s, left, right, k), ans);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="keyword">return</span> dfs(s, <span class="number">0</span>, len - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：滑动窗口</p>
<blockquote>
<p>可以列举最长子串的字符种类数目，最小为1，最大为26<br>对于给定的字符种类数目，维护滑动窗口的左右边界l/r、滑动窗口内部每个字符出现的次数cNums，当前窗口内小于k数值的字符种类计数器less、窗口内的字符种类数目total<br>每次窗口向右滑动一步，如果当前字符在cNums中为0，那么total自增————表明新出现一种字符，且less自增————表明又有一种字符数目小于k；如果当前字符在cNums中为k-1，那么less自减————表明少了一种数目小于k的字符<br>接着，查看当前total是否大于指定的字符种类数目，如果大于，左边界向右移动，并与向右移动一样对数据做出改变<br>最终如果less为0，说明当前符合，计算当前子符串长度</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 罗列字符种类数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 统计窗口内字符数目</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cNums</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 总共种类、少于k的种类、左边界、有边界</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, less = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">      <span class="keyword">int</span> rIndex = s[r] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="comment">// 如果新出现一种字符</span></span><br><span class="line">      <span class="keyword">if</span> (!cNums[rIndex]) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        less++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 字符数目达到k</span></span><br><span class="line">      <span class="keyword">if</span> (cNums[rIndex] == k - <span class="number">1</span>) &#123;</span><br><span class="line">        less--;</span><br><span class="line">      &#125;</span><br><span class="line">      cNums[rIndex]++;</span><br><span class="line">      <span class="comment">// 种类超过规定</span></span><br><span class="line">      <span class="keyword">while</span> (total &gt; i) &#123;</span><br><span class="line">        <span class="keyword">int</span> lIndex = s[l] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">// 少一种字符</span></span><br><span class="line">        <span class="keyword">if</span> (cNums[lIndex] == <span class="number">1</span>) &#123;</span><br><span class="line">          less--;</span><br><span class="line">          total--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一种字符数目少于k</span></span><br><span class="line">        <span class="keyword">if</span> (cNums[lIndex] == k) &#123;</span><br><span class="line">          less++;</span><br><span class="line">        &#125;</span><br><span class="line">        cNums[lIndex]--;</span><br><span class="line">        l++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 符合条件,更新结果</span></span><br><span class="line">      <span class="keyword">if</span> (!less) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="493翻转对"><a href="#493翻转对" class="headerlink" title="493翻转对"></a>493翻转对</h2><ul>
<li><p>题目描述：<br><img src="Question493.png" alt="493翻转对"></p>
</li>
<li><p>解法：</p>
<blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="514自由之路"><a href="#514自由之路" class="headerlink" title="514自由之路"></a>514自由之路</h2><ul>
<li><p>题目描述：<br><img src="Question514.png" alt="514自由之路"></p>
</li>
<li><p>解题思路：</p>
<ol>
<li>每次转到指定位置后还需要按一次按钮，那么结果还需要加上key的长度</li>
<li>转动到指定位置有两种方向，单考虑转到指定位置的话(不考虑再按一次的触发)；假设curRingIndex表示当前转动前的位置下标，curKeyIndex表示转动到的指定位置的下标：<br> <img src="Question514_p1.png" alt="转动示意图"><ol>
<li><code>l1 = abs(curRingIndex - curKeyIndex)</code></li>
<li><code>l2 = ring.length() - l1</code></li>
</ol>
</li>
<li>每次转动后curKeyIndex变为下一次curRingIndex，即从新指定位置开始转动</li>
<li>截止条件是<code>curKeyIndex = key.length()</code>，即当前所有key的字符都被转到12点方向过</li>
</ol>
</li>
<li><p>解法1：动态规划方式<br>记录每次从当前位置转动到顺序读取到的key字符的位置所花费的转动次数，最终返回到达最后key字符的转动次数的最小值<br><img src="Question514_p2.png" alt="示例的手工动态规划示意图"></p>
<p>动态转移方程如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认dp中元素为INT_MAX</span></span><br><span class="line"><span class="comment">// 得到第一步的转动次数</span></span><br><span class="line">dp[<span class="number">0</span>][i] = (ring[i] == key[<span class="number">0</span>]) ? <span class="built_in">min</span>(i, m - i);</span><br><span class="line"><span class="comment">// 如果dp[i - 1][k]不为INT_MAX,即上一步(第i步)能转动到ring的第k个字符,且为到第k个字符的最小值</span></span><br><span class="line"><span class="comment">// 当前为第i+1步,将要走到第j个字符</span></span><br><span class="line"><span class="comment">// 最小距离为已知的最小值与当前走法的较小值</span></span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][k] + <span class="built_in">min</span>(<span class="built_in">abs</span>(j - k), m - <span class="built_in">abs</span>(j - k)));</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, INT_MAX))</span></span>;</span><br><span class="line">  <span class="comment">// 遍历首字符匹配的下标集合</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[<span class="number">0</span>] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">    <span class="comment">// 走第一步</span></span><br><span class="line">    dp[<span class="number">0</span>][index] = <span class="built_in">min</span>(index, m - index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 遍历下一步字符的下标集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果第i步不可达j,跳过</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 当前走第i+1步的最小步数</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="built_in">min</span>(<span class="built_in">abs</span>(index - j), m - <span class="built_in">abs</span>(index - j));</span><br><span class="line">        <span class="comment">// 记录走i+1步的最小步数</span></span><br><span class="line">        dp[i][index] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + steps, dp[i][index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> *min_element(dp[n - <span class="number">1</span>].<span class="built_in">begin</span>(), dp[n - <span class="number">1</span>].<span class="built_in">end</span>()) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：动态规划方式，使用滚动数组的方式，节省空间</p>
<blockquote>
<p>根据方式一，发现第i+1步只与第i步的位置有关，因此只需保留两个数组用于保存上一步的最小步数和当前步的最小步数即可</p>
</blockquote>
<p>最终代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;int&gt; last(m), current(m, INT_MAX);</span><br><span class="line">  <span class="comment">// 遍历首字符匹配的下标集合</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[<span class="number">0</span>] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">    <span class="comment">// 走第一步</span></span><br><span class="line">    current[index] = <span class="built_in">min</span>(index, m - index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    last = current;</span><br><span class="line">    <span class="built_in">fill</span>(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>(), INT_MAX);</span><br><span class="line">    <span class="comment">// 遍历下一步字符的下标集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果第i步不可达j,跳过</span></span><br><span class="line">        <span class="keyword">if</span> (last[j] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 当前走第i+1步的最小步数</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="built_in">min</span>(<span class="built_in">abs</span>(index - j), m - <span class="built_in">abs</span>(index - j));</span><br><span class="line">        <span class="comment">// 记录走i+1步的最小步数</span></span><br><span class="line">        current[index] = <span class="built_in">min</span>(last[j] + steps, current[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> *min_element(current.<span class="built_in">begin</span>(), current.<span class="built_in">end</span>()) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3：dfs + 记忆化方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = ring.<span class="built_in">size</span>(), n = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">  <span class="comment">// 记录字符下标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    pos[ring[i] - <span class="string">'a'</span>].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录从ring的第i个字符转动到key的第j个字符的最小转动次数</span></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  curRingIndex：当前处于ring转盘的第几个字符</span></span><br><span class="line"><span class="comment">  curKeyIndex：当前需匹配的key的第几个字符</span></span><br><span class="line"><span class="comment">  memo：记录表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;)&gt; dfs = [&amp;, m, pos, key](<span class="keyword">int</span> curRingIndex, <span class="keyword">int</span> curKeyIndex, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;memo) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (curKeyIndex == key.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已记录过,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (memo[curRingIndex][curKeyIndex] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[curRingIndex][curKeyIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录此次转动的最小次数</span></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="comment">// 遍历ring中当前key对应字符的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index : pos[key[curKeyIndex] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">      <span class="keyword">int</span> d1 = <span class="built_in">abs</span>(curRingIndex - index);</span><br><span class="line">      <span class="keyword">int</span> d2 = m - d1;</span><br><span class="line">      <span class="comment">// 此次转动的最小次数</span></span><br><span class="line">      <span class="comment">// 当前转动成功后,curRingIndex自动变为index,curKeyIndex移动到下一个</span></span><br><span class="line">      res = <span class="built_in">min</span>(res, <span class="built_in">min</span>(d1, d2) + dfs(index, curKeyIndex + <span class="number">1</span>, memo));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新记录表</span></span><br><span class="line">    memo[curRingIndex][curKeyIndex] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 每次移动到指定位置还需要转动一次触发,因此要+n</span></span><br><span class="line">  <span class="keyword">return</span> n + dfs(<span class="number">0</span>, <span class="number">0</span>, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="621任务调度器"><a href="#621任务调度器" class="headerlink" title="621任务调度器"></a>621任务调度器</h2><ul>
<li><p>题目描述：<br><img src="Question621_p1.png" alt="621任务调度器(1)"><br><img src="Question621_p2.png" alt="621任务调度器(2)"></p>
</li>
<li><p>解法1：模拟</p>
<blockquote>
<p>首先就容易想到的就是采用模拟的方式，首先应该每次优先考虑做次数多的工作(因为冷却的存在,替换着做比不替换更好)<br>因此首先要统计每种工作的次数；接着每次要找到未在冷却期间的剩余次数最多的那个工作，此时时间自增1<br>如果找不到未在冷却期间的工作，那么需要跳跃到最小的下一个可继续工作时间，因此需要记录每种工作下一次可以立马执行的时间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = tasks.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 两种特殊情况</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; taskNums;</span><br><span class="line">  <span class="comment">// 记录次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;task : tasks) &#123;</span><br><span class="line">    taskNums[task]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> taskTypes = taskNums.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;pair&lt;int, int&gt;&gt; taskInfo(taskTypes);</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化下一次可以执行的时间以及次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;taskNum : taskNums) &#123;</span><br><span class="line">    taskInfo[index].first = <span class="number">1</span>;</span><br><span class="line">    taskInfo[index++].second = taskNum.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> curTime = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (len) &#123;</span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    <span class="keyword">int</span> minTime = INT_MAX, maxTaskNum = <span class="number">0</span>, targetIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskTypes; ++i) &#123;</span><br><span class="line">      <span class="comment">// 记录还能继续执行的最小下一次执行时间</span></span><br><span class="line">      <span class="keyword">if</span> (taskInfo[i].second) minTime = <span class="built_in">min</span>(minTime, taskInfo[i].first);</span><br><span class="line">      <span class="comment">// 找到能够执行的且剩余次数最多的工作</span></span><br><span class="line">      <span class="keyword">if</span> (taskInfo[i].first &lt;= curTime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxTaskNum &lt; taskInfo[i].second) &#123;</span><br><span class="line">          maxTaskNum = taskInfo[i].second;</span><br><span class="line">          targetIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">    <span class="keyword">if</span> (maxTaskNum) &#123;</span><br><span class="line">      taskInfo[targetIndex].second--;</span><br><span class="line">      taskInfo[targetIndex].first = curTime + n + <span class="number">1</span>;</span><br><span class="line">      curTime++;</span><br><span class="line">      len--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跳跃</span></span><br><span class="line">      curTime = minTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curTime - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：桶思想</p>
<blockquote>
<p>考虑桶的思想，考虑数目最多的任务，他们之间至少需要设置冷却时间+1个时间(桶大小)，因此如果在任务较少的情况下，其实影响最大的部分在于数目最多的任务<br>举例如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>/</td>
</tr>
</tbody></table>
<p>此时结果为(最多任务数目 - 1) * 桶大小 + 最多任务数目种类</p>
<p>再考虑到任务多的情况下，举例如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>E</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>D</td>
<td>/</td>
</tr>
</tbody></table>
<p>如果任务数目较多，则可通过扩展桶大小实现。那么其实最多时间也就是任务的数目(taskNums)，而与任务性质与否无关<br>因此结论是结果为两个例子结果取最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单个桶内的承载的数目</span></span><br><span class="line">  <span class="keyword">int</span> bucketNum = n + <span class="number">1</span>, len = tasks.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">taskNums</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 统计同种任务数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;task : tasks) &#123;</span><br><span class="line">    taskNums[task - <span class="string">'A'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(taskNums.<span class="built_in">begin</span>(), taskNums.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 统计数目最多的任务数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;taskNum : taskNums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (taskNum == taskNums[<span class="number">0</span>]) maxCount++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(len, maxCount + (taskNums[<span class="number">0</span>] - <span class="number">1</span>) * bucketNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="659分割数组为连续子序列"><a href="#659分割数组为连续子序列" class="headerlink" title="659分割数组为连续子序列"></a>659分割数组为连续子序列</h2><ul>
<li><p>题目描述：<br><img src="Question659.png" alt="659分割数组为连续子序列"></p>
</li>
<li><p>解法1：堆</p>
<blockquote>
<p>由于有最小长度为3的限制，因此每次需要将数字增加到长度最短的那个子序列中<br>考虑最小堆，堆中每个元素代表子序列长度，而与之关联的是一个子序列最后一个元素，因为原序列是递增的，如果连续只会比子序列的最后一个元素大，因此无需考虑更大的元素。因此只需要遍历一次原序列，并更新映射关系(可以连续/不可以连续情况)即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 建立&lt;子序列最后一个元素, 子序列大小堆&gt;的映射</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; um;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="comment">// 如果没有找到映射</span></span><br><span class="line">    <span class="keyword">if</span> (um.<span class="built_in">find</span>(num) == um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      um[num] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到之前的元素,可以连续</span></span><br><span class="line">    <span class="keyword">if</span> (um.<span class="built_in">find</span>(num - <span class="number">1</span>) != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 获取之前的长度</span></span><br><span class="line">      <span class="keyword">int</span> preMinLen = um[num - <span class="number">1</span>].top();</span><br><span class="line">      <span class="comment">// 删除之前的元素</span></span><br><span class="line">      um[num - <span class="number">1</span>].pop();</span><br><span class="line">      <span class="keyword">if</span> (um[num - <span class="number">1</span>].empty()) &#123;</span><br><span class="line">        um.erase(num - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新当前长度</span></span><br><span class="line">      um[num].push(preMinLen + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新增</span></span><br><span class="line">      um[num].push(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;kv : um) &#123;</span><br><span class="line">    <span class="comment">// 检验子序列长度</span></span><br><span class="line">    <span class="keyword">if</span> (kv.second.top() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：贪心法</p>
<blockquote>
<p>将x加入已有的以x-1结尾的子序列更优，因为前者可以将已有子序列的长度增加1；而新建一个长度为1的子序列不满足题目要求分割的子序列长度不小于3，因此应尽量避免新建短的子序列<br>而在解法1中，每次只做了一次操作，其实可以根据上面的思路，每次如果找到以x-1结尾的子序列则合并，否则尝试建立一个长度为3的子序列，如果不能做到，那么说明输入不满足</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x出现次数map、x为结尾的子序列map数目</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numOccur, numEnd;</span><br><span class="line">  <span class="comment">// 记录各元素出现次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    numOccur[num]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="comment">// 如果元素用完,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!numOccur[num]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 优先考虑能够合并</span></span><br><span class="line">    <span class="keyword">if</span> (numOccur[num] &amp;&amp; numEnd[num - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 更新map</span></span><br><span class="line">      numOccur[num]--;</span><br><span class="line">      numEnd[num - <span class="number">1</span>]--;</span><br><span class="line">      numEnd[num]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOccur[num] &amp;&amp; numOccur[num + <span class="number">1</span>] &amp;&amp; numOccur[num + <span class="number">2</span>]) &#123; <span class="comment">// 一次性建立3个元素的子序列</span></span><br><span class="line">      <span class="comment">// 更新map</span></span><br><span class="line">      numOccur[num]--;</span><br><span class="line">      numOccur[num + <span class="number">1</span>]--;</span><br><span class="line">      numOccur[num + <span class="number">2</span>]--;</span><br><span class="line">      numEnd[num + <span class="number">2</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="803打砖块"><a href="#803打砖块" class="headerlink" title="803打砖块"></a>803打砖块</h2><ul>
<li><p>题目描述：<br><img src="Question803_p1.png" alt="803打砖块"></p>
</li>
<li><p>举例说明：<br><img src="Question803_p2.png" alt="示例图示"></p>
<blockquote>
<p>假设敲打前如上图所示，那么所有都不会掉落，因为都系在[0, 0]这个砖块上。如果此时打掉[1, 2]这个砖块，砖块[2, 2]和[3, 2]都与[0, 0]失去间接连接，因此会一起掉落<br>很容易想到这是一道连通性的问题，但又因为只需要需求连通的个数，可以快速地想到使用并查集进行求解。但如果初始阶段进行一次并查集的初始化，再一个一个打掉砖块，那么每次读需要完全重新初始化并查集，打掉的那块并不会对起到任何提示作用。这里可以使用并查集的删除重整算法(没有较好的资料)，但另一种考虑是逆向思维，从最后一步开始倒推重建整个网格<br>比如当前的示例图，右图只有3块稳定，加上[1, 2]砖块后变成左图，共有6块稳定。因此增加(反之这一步打掉砖块附带掉落了)6 - 3 - 1 = 2块</p>
</blockquote>
</li>
<li><p>小技巧(trick)：由于当前为二维表格，可能并查集内容很稀疏，可采用map代替传统的定长数组，再者可通过转化二维为一维简化记录内容(t = i * m + j————m行n列)</p>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, int&gt; find_root(int x, unordered_map&lt;int, pair&lt;int, int&gt;&gt; &amp;union_set) &#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = union_set.<span class="built_in">find</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (iter == union_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    union_set.insert(&#123;x, &#123;x, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;x, <span class="number">1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x != iter-&gt;second.first) &#123;</span><br><span class="line">    <span class="keyword">auto</span> root = find_root(iter-&gt;second.first, union_set);</span><br><span class="line">    iter-&gt;second.first = root.first;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_element</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;union_set)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> x_root = find_root(x, union_set), y_root = find_root(y, union_set);</span><br><span class="line">  <span class="keyword">if</span> (x_root.first == y_root.first) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (x_root.first == <span class="number">-1</span>) &#123;</span><br><span class="line">    union_set[y_root.first].first = x_root.first;</span><br><span class="line">    union_set[x_root.first].second += y_root.second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    union_set[x_root.first].first = y_root.first;</span><br><span class="line">    union_set[y_root.first].second += x_root.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> direction[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hitBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;hits)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; union_set;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; new_grid = grid;</span><br><span class="line">  union_set.insert(&#123;<span class="number">-1</span>, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;);</span><br><span class="line">  <span class="keyword">int</span> m = new_grid.<span class="built_in">size</span>(), n = new_grid[<span class="number">0</span>].<span class="built_in">size</span>(), hit_size = hits.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(hit_size)</span></span>;</span><br><span class="line">  <span class="comment">// 重置砖块</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;hit : hits) &#123;</span><br><span class="line">    new_grid[hit[<span class="number">0</span>]][hit[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化并查集</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = i * n + j;</span><br><span class="line">      <span class="keyword">if</span> (new_grid[i][j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i) union_element(index, <span class="number">-1</span>, union_set);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (new_grid[i - <span class="number">1</span>][j]) union_element(index, (i - <span class="number">1</span>) * n + j, union_set);</span><br><span class="line">          <span class="keyword">if</span> (j &amp;&amp; new_grid[i][j - <span class="number">1</span>]) union_element(index, i * n + j - <span class="number">1</span>, union_set);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倒序添加砖块</span></span><br><span class="line">  <span class="keyword">int</span> hang_num;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hit_size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    hang_num = union_set[<span class="number">-1</span>].second;</span><br><span class="line">    <span class="keyword">int</span> x = hits[i][<span class="number">0</span>], y = hits[i][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 可能打下的原本没有的砖块,跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!grid[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> index = x * n + y;</span><br><span class="line">    <span class="keyword">if</span> (!x) union_element(index, <span class="number">-1</span>, union_set);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> next_x = x + direction[j], next_y = y + direction[j + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= m || next_y &lt; <span class="number">0</span> || next_y &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_grid[next_x][next_y]) &#123;</span><br><span class="line">        union_element(index, next_x * n + next_y, union_set);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_grid[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可能连不上,最小为0</span></span><br><span class="line">    ans[i] = <span class="built_in">max</span>(union_set[<span class="number">-1</span>].second - hang_num - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="947移除最多的同行或同列石头"><a href="#947移除最多的同行或同列石头" class="headerlink" title="947移除最多的同行或同列石头"></a>947移除最多的同行或同列石头</h2><ul>
<li><p>题目描述：<br><img src="Question947_p1.png" alt="947移除最多的同行或同列石头"></p>
</li>
<li><p>举例：<br><img src="Question947_p2.png" alt="示例图示"><br>说明：由于同行或同列是可以移除的，可以把同行同列的石头连起来，就形成了一个无向图。根据观察，可得到只要是一个无向连通图，那么可以移除到只剩一个石头，那么原题目就变成了求连通子图的个数。如果只需求连通子图的个数而无需求是怎样连通的，可以采用并查集————将连通的石头挂载到一个节点上</p>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;union_set, <span class="keyword">int</span> &amp;connection_component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = union_set.<span class="built_in">find</span>(x);</span><br><span class="line">  <span class="comment">// 没有找到当前节点,相当于初始化</span></span><br><span class="line">  <span class="keyword">if</span> (iter == union_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 连通子图+1</span></span><br><span class="line">    connection_component++;</span><br><span class="line">    <span class="comment">// 默认父节点为自身</span></span><br><span class="line">    union_set.emplace(x, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;second == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 路径压缩,找到根节点</span></span><br><span class="line">      union_set[x] = find_root(iter-&gt;second, union_set, connection_component);</span><br><span class="line">      <span class="keyword">return</span> union_set[x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_element</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;union_set, <span class="keyword">int</span> &amp;connection_component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> xRoot = find_root(x, union_set, connection_component), yRoot = find_root(y, union_set, connection_component);</span><br><span class="line">  <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span>;</span><br><span class="line">  union_set[xRoot] = yRoot;</span><br><span class="line">  connection_component--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;stones)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; union_set;</span><br><span class="line">  <span class="keyword">int</span> connection_component = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stone : stones) &#123;</span><br><span class="line">    union_element(stone[<span class="number">0</span>] + <span class="number">1001</span>, stone[<span class="number">1</span>], union_set, connection_component);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stones.<span class="built_in">size</span>() - connection_component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于同行同列都算连通,因此可以把连通的行列都链接到一起,只需要挂载到单个x或y上即可。由于题目要求0 &lt;= xi,yi &lt;= 10000,因此x+10001即可与y完全隔开</p>
</blockquote>
</li>
</ul>
<h2 id="959由斜杠划分区域"><a href="#959由斜杠划分区域" class="headerlink" title="959由斜杠划分区域"></a>959由斜杠划分区域</h2><ul>
<li><p>题目描述：<br><img src="Question959_p1.png" alt="959由斜杠划分区域(1)"><br><img src="Question959_p2.png" alt="959由斜杠划分区域(2)"></p>
</li>
<li><p>解法：并查集</p>
<blockquote>
<p>这是一个连通性的问题，只需要求得不连通区域的个数即可，可以使用并查集来解决<br>但使用’/‘和’&#39;分割区域中，单元格并不是最小的单位，而需要把单元格划分成个小的单位<br><img src="Question959_p3.png" alt="单元格划分示意"><br>如此，每个单元格被划分成4个更小的块，原题就变成了求块的连通区域的个数<br>其次，合并相邻单元格时，只需要考虑两个方向(向右和向下,这样顺序遍历时是全覆盖的)；然而并不是所有块都需要合并，只有块2需要与向下方向的其他块合并，块1需要和向右方向的其他块合并</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> setNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet, weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum = num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;unionSet.resize(num), <span class="keyword">this</span>-&gt;weight.resize(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;unionSet[i] = i;</span><br><span class="line">      <span class="keyword">this</span>-&gt;weight[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unionSet[x] == x ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 按秩合并</span></span><br><span class="line">    <span class="keyword">if</span> (weight[xRoot] &gt; weight[yRoot]) swap(xRoot, yRoot);</span><br><span class="line">    unionSet[xRoot] = yRoot;</span><br><span class="line">    weight[yRoot] += weight[xRoot];</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = grid.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">' '</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> chunk_size = len * len &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(chunk_size)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = (i * len + j) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// '/'的情况</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">3</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, index + <span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">'\\'</span>) &#123; <span class="comment">// '\'的情况</span></span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">1</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, index + <span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// ' '的情况</span></span><br><span class="line">        unionSet.unionElements(index, index + <span class="number">1</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, index + <span class="number">2</span>);</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, index + <span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向下合并</span></span><br><span class="line">      <span class="keyword">if</span> (i != len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = ((i + <span class="number">1</span>) * len + j) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        unionSet.unionElements(index + <span class="number">2</span>, nextIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向右合并</span></span><br><span class="line">      <span class="keyword">if</span> (j != len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex = (i * len + j + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        unionSet.unionElements(index + <span class="number">1</span>, nextIndex + <span class="number">3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unionSet.setNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="995K连续位的最小翻转次数"><a href="#995K连续位的最小翻转次数" class="headerlink" title="995K连续位的最小翻转次数"></a>995K连续位的最小翻转次数</h2><ul>
<li><p>题目描述：<br><img src="Question995.png" alt="995K连续位的最小翻转次数"></p>
</li>
<li><p>前提条件：对若干个K位翻转操作，改变先后顺序不影响最终翻转效果。因此可以通过自左向右执行翻转，由于翻转是唯一的，如果最终数组元素均为1即是最少的翻转次数。如果自左向右每次遇到一个0就把接下来的K位翻转，会导致超时，因此做了许多不必要的操作</p>
</li>
<li><p>解法1：差分数组</p>
<blockquote>
<p>维护一个差分数组diff，其中diff[i]表示两个相邻元素A[i-1]和A[i]的翻转次数差<br>通过累加差分数组可以得到当前位置需要翻转的次数，用revCnt表示<br>遍历到A[i]时，若A[i] + revCnt为偶数，则实际值为0，翻转区间[i, i + K - 1]，可直接将revCnt增加1，diff[i + K]减少1<br>若i + K &gt; n则无法执行翻转操作，返回-1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    revCnt += diff[i];</span><br><span class="line">    <span class="keyword">if</span> ((A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ++ans;</span><br><span class="line">      ++revCnt;</span><br><span class="line">      --diff[i + K];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：滑动窗口</p>
<blockquote>
<p>位置i的状态与前面K-1个元素翻转的次数(奇偶)有关<br>可使用队列模拟滑动窗口，此处滑动窗口含义是前面K-1个元素中以哪些位置起始的子区间进行了翻转<br>从左至右滑动，若位置i需要翻转，则将该位置存储到队尾。遍历到新位置j(j &lt; i + K)时，队列中元素个数代表i被之前K-1个是元素翻转的次数</p>
<ul>
<li>若size为偶，A[i] = 0，则需要翻转</li>
<li>若size为奇，A[i] = 1，则需要翻转<br>因此queue.size() % 2 == A[i]时，元素需要翻转<br>当i + K &gt; N时，说明元素剩余不足，返回-1</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;a : A) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!a) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() + K == i) q.pop();</span><br><span class="line">      <span class="keyword">if</span> (q.<span class="built_in">size</span>() % <span class="number">2</span> == A[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + K &gt; <span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans++;</span><br><span class="line">        q.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1178猜字谜"><a href="#1178猜字谜" class="headerlink" title="1178猜字谜"></a>1178猜字谜</h2><ul>
<li><p>题目描述：<br><img src="Question1178.png" alt="1178猜字谜"></p>
</li>
<li><p>解法1：hash表 + 移位</p>
<blockquote>
<p>由于只需要求单词中的字母是否都在谜面中，因此不需要细致的统计，应该统计具有相同字母的单词个数并进行归类计算<br>因此，首先需要将具有相同字母的单词个数统计出来，由于题目提示谜底为7位不同的字符，因此如果单词个数大于7可快速省略；而且由于都为小写字母，因此可以采用一个26位的bit位表示(int足以)<br>接着，如果接着遍历单词的数组与谜面进行一一匹配还是效率太低，应该遍历谜面，从hash表中找出是否存在，再累加；因此，需要罗列出谜底要求的bitSet子集</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算bitSet中1的个数(低26位)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">oneNumsInBits</span><span class="params">(<span class="keyword">int</span> <span class="built_in">bitSet</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bitSet</span> &amp; (<span class="number">1</span> &lt;&lt; i)) ans++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;puzzles)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">bitSet</span>;</span><br><span class="line">  <span class="comment">// 记录拥有相同字符单词个数</span></span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bitSetNums;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span> : words) &#123;</span><br><span class="line">    <span class="built_in">bitSet</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> &amp;c : <span class="keyword">word</span>) &#123;</span><br><span class="line">      <span class="built_in">bitSet</span> |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">      <span class="comment">// 大于puzzle7个字符</span></span><br><span class="line">      <span class="keyword">if</span> (oneNumsInBits(<span class="built_in">bitSet</span>) &gt; <span class="number">7</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bitSetNums[<span class="built_in">bitSet</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">  ans.reserve(puzzles.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> &amp;puzzle : puzzles) &#123;</span><br><span class="line">    <span class="keyword">int</span> mask, curAns = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历可能余下6位可能的取值,罗列子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); ++i) &#123;</span><br><span class="line">      mask = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">          mask |= <span class="number">1</span> &lt;&lt; (puzzle[j + <span class="number">1</span>] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 加上第一位</span></span><br><span class="line">      mask |= <span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">if</span> (bitSetNums.<span class="built_in">find</span>(mask) != bitSetNums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        curAns += bitSetNums[mask];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(curAns);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：字典树<br>#TODO</p>
</li>
</ul>
<h2 id="1438绝对差不超过限制的最长连续子数组"><a href="#1438绝对差不超过限制的最长连续子数组" class="headerlink" title="1438绝对差不超过限制的最长连续子数组"></a>1438绝对差不超过限制的最长连续子数组</h2><ul>
<li><p>题目描述：<br><img src="Question1438.png" alt="1438绝对差不超过限制的最长连续子数组"></p>
</li>
<li><p>解法：滑动窗口 + 单调队列</p>
<blockquote>
<p>滑动窗口 + multiset方式很容易想到，每次新插入数据rIndex，如果头尾相差在limit内则更新结果，否则删除lIndex<br>这样多做了许多工作，因为很多中间值多余了，只需要抓住最大值和最小值<br>因此可以采用两个单调队列，一个记录最小值(单调增)，一个记录最大值(单调减)，因为后续可能会浮出水面<br>而后每次查找最大值和最小值只需要查看队头元素即可，如果队头元素之差在limit之外，那么就需要遍历lIndex把可能的最大值或最小值去除复原之差在limit之内</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 单调递减</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>&gt; maxQueue;</span><br><span class="line">  <span class="comment">// 单调递增</span></span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minQueue;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; maxQueue.top() &lt; nums[r]) maxQueue.pop();</span><br><span class="line">    <span class="keyword">while</span> (!minQueue.empty() &amp;&amp; minQueue.top() &gt; nums[r]) minQueue.pop();</span><br><span class="line">    maxQueue.push(nums[r]);</span><br><span class="line">    minQueue.push(nums[r++]);</span><br><span class="line">    <span class="keyword">if</span> (maxQueue.top() - minQueue.top() &lt;= limit) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!maxQueue.empty() &amp;&amp; !minQueue.empty() &amp;&amp; maxQueue.top() - minQueue.top() &gt; limit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == maxQueue.top()) maxQueue.pop();</span><br><span class="line">        <span class="keyword">if</span> (nums[l++] == minQueue.top()) minQueue.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1489找到最小生成树里的关键边和伪关键边"><a href="#1489找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489找到最小生成树里的关键边和伪关键边"></a>1489找到最小生成树里的关键边和伪关键边</h2><ul>
<li><p>题目描述：<br><img src="Question1489_p1.png" alt="1489找到最小生成树里的关键边和伪关键边(1)"><br><img src="Question1489_p2.png" alt="1489找到最小生成树里的关键边和伪关键边(2)"></p>
</li>
<li><p>解法：并查集</p>
<blockquote>
<p>首先通过归并具有最小距离的最小生成树生成算法(Kruskal算法)，这样就能得到最小生成树的总权值，在归并过程中可使用并查集进行处理连通性问题<br>接着遍历测试除去一条指定边后的情况：如果一条边是关键边，那么加上这条边后，不能连通(连通数目大于1)或者当前的总权值大于先前的最小权值(连通并且严格大于)<br>最后遍历测试使用一条指定边后的情况：如果一条边是伪关键边，那么使用这条边后，能够连通(此处无需判断,如果不能连通就是关键边)而且与最小权值一样</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 连通数目</span></span><br><span class="line">  <span class="keyword">int</span> setNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setNum = num;</span><br><span class="line">    unionSet.reserve(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">      unionSet.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == unionSet[x] ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 联合节点,返回是否需要联合</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">unionElement</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    unionSet[xRoot] = yRoot;</span><br><span class="line">    setNum--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findCriticalAndPseudoCriticalEdges</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = edges.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 设置编号,用于最后的返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    edges[i].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据距离从小到大排序</span></span><br><span class="line">  sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">2</span>] &lt; v2[<span class="number">2</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> min_value = <span class="number">0</span>;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="comment">// 依次加入并查集,得到最小权值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unionSet.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">      min_value += edge[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="function">UnionSet <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> temp_value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键边判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;edge = edges[j];</span><br><span class="line">      <span class="keyword">if</span> (temp.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">        temp_value += edge[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.setNum &gt; <span class="number">1</span> || (temp.setNum == <span class="number">1</span> &amp;&amp; min_value &lt; temp_value)) &#123;</span><br><span class="line">      ans[<span class="number">0</span>].push_back(edges[i][<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伪关键边判断</span></span><br><span class="line">    temp = UnionSet(n);</span><br><span class="line">    temp.unionElement(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">    temp_value = edges[i][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;edge = edges[j];</span><br><span class="line">      <span class="keyword">if</span> (temp.unionElement(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">        temp_value += edge[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp_value == min_value) ans[<span class="number">1</span>].push_back(edges[i][<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1631最小体力消耗路径"><a href="#1631最小体力消耗路径" class="headerlink" title="1631最小体力消耗路径"></a>1631最小体力消耗路径</h2><ul>
<li><p>题目描述：<br><img src="Question1631_p1.png" alt="1631最小体力消耗路径(1)"><br><img src="Question1631_p2.png" alt="1631最小体力消耗路径(2)"><br><img src="Question1631_p3.png" alt="1631最小体力消耗路径(3)"></p>
</li>
<li><p>解法：并查集</p>
<blockquote>
<p>原题可以转换成一个连通性问题————如果从左上角到右上角<br>首先通过构造格子间的过渡连接(from, to, cost)可以得到连接对，再通过对这些连接对的排序，把cost较大的移动到最后，那么每次必定从连接对中合并较小代价的连接。在每次连接后都判断当前操作是否能使左上角和右下角连通，而最后的一次成功的操作必定是cost最大的连接，因为是按升序排列的<br>本题中cost为数值的高度差的绝对值，还可通过对行列进行映射到唯一的id(i * row + j)方便编码</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> cellNum;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; unionSet, parent;</span><br><span class="line"></span><br><span class="line">  UnionSet(<span class="keyword">int</span> cellNum) : cellNum(cellNum) &#123;</span><br><span class="line">    unionSet.resize(cellNum);</span><br><span class="line">    parent.resize(cellNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cellNum; ++i) &#123;</span><br><span class="line">      unionSet[i] = i;</span><br><span class="line">      parent[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == unionSet[x] ? x : unionSet[x] = findRoot(unionSet[x]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRoot(x) == findRoot(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xRoot = findRoot(x), yRoot = findRoot(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 按秩合并</span></span><br><span class="line">    <span class="keyword">if</span> (parent[xRoot] &gt; parent[yRoot]) swap(xRoot, yRoot);</span><br><span class="line">    unionSet[xRoot] = unionSet[yRoot];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;heights)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> row = heights.<span class="built_in">size</span>(), col = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (row == col &amp;&amp; row == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cellDis;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">      <span class="comment">// 加入下连接</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; row - <span class="number">1</span>) cellDis.emplace_back(i * col + j, (i + <span class="number">1</span>) * col + j, <span class="built_in">abs</span>(heights[i][j] - heights[i + <span class="number">1</span>][j]));</span><br><span class="line">      <span class="comment">// 加入右连接</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; col - <span class="number">1</span>) cellDis.emplace_back(i * col + j, i * col + j + <span class="number">1</span>, <span class="built_in">abs</span>(heights[i][j] - heights[i][j + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(cellDis.<span class="built_in">begin</span>(), cellDis.<span class="built_in">end</span>(), [](<span class="keyword">const</span> tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t1, <span class="keyword">const</span> tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t1) &lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, <span class="built_in">size</span> = row * col;</span><br><span class="line">  <span class="function">UnionSet <span class="title">unionSet</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : cellDis) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unionSet.unionElements(<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(c), <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(c))) &#123;</span><br><span class="line">      ans = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(c);</span><br><span class="line">      <span class="keyword">if</span> (unionSet.isConnected(<span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1776车队II"><a href="#1776车队II" class="headerlink" title="1776车队II"></a>1776车队II</h2><ul>
<li><p>题目描述：<br><img src="Question1776.png" alt="1776车队II"></p>
</li>
<li><p>解法：单调栈</p>
<blockquote>
<p>由于题目隐含一些条件：如果可以合并，左边的都将以右边的车的速度移动，因为如果左边的车能够追上右边的车，那么一定会同化成右边的车速；不管已经行动了多少，能追上的时间都是相对的距离 / 相对的时间<br>可从右向左遍历并维护一个单调栈，单调栈的规律是序号递减，速度递增，这样才可以追上；而且合并之后不再计算与前车相遇时间，必须在前车合并前前车前追上<br>首先入栈right元素(初值为len-1)，而后查看后面元素是否能够追上栈顶元素：如果已经合并那么需要计算在合并前是否能追上；否则查看速度是否大于栈顶元素(如果大于,一定能追上)；然后依次递减right值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">getCollisionTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cars)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = cars.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">-1.0</span>&#125;;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">      <span class="comment">// 追不上栈顶</span></span><br><span class="line">      <span class="keyword">if</span> (cars[s.top()][<span class="number">1</span>] &gt;= cars[i][<span class="number">1</span>]) s.pop();</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 能追上栈顶</span></span><br><span class="line">        <span class="comment">// 没有消失</span></span><br><span class="line">        <span class="keyword">if</span> (ans[s.top()] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 查看能否在合并前碰到,计算能跟上的距离</span></span><br><span class="line">        <span class="keyword">double</span> relativeDis = ans[s.top()] * (cars[i][<span class="number">1</span>] - cars[s.top()][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 碰得到</span></span><br><span class="line">        <span class="keyword">if</span> (relativeDis &gt; cars[s.top()][<span class="number">0</span>] - cars[i][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 碰不到</span></span><br><span class="line">        <span class="keyword">else</span> s.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> t = (cars[s.top()][<span class="number">0</span>] - cars[i][<span class="number">0</span>]) * <span class="number">1.0</span> / (cars[i][<span class="number">1</span>] - cars[s.top()][<span class="number">1</span>]);</span><br><span class="line">      ans[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer36二叉搜索树与双向链表"><a href="#剑指Offer36二叉搜索树与双向链表" class="headerlink" title="剑指Offer36二叉搜索树与双向链表"></a>剑指Offer36二叉搜索树与双向链表</h2><ul>
<li><p>题目描述：<br><img src="Question_offer36_p1.png" alt="剑指Offer36二叉搜索树与双向链表(1)"><br><img src="Question_offer36_p2.png" alt="剑指Offer36二叉搜索树与双向链表(2)"></p>
</li>
<li><p>解法：递归</p>
<blockquote>
<p>由于是二叉搜索树，因此中序遍历就是一个递增序列，又要求原地算法，因此使用递归的中序遍历<br>由图示的例子，中序遍历后的序列为12345，如果每次得到之前遍历的节点pre，那么每次就能够设置两个指针(当前遍历节点cur)————<code>pre-&gt;right = cur;cur-&gt;left = pre;</code>，那么只需要一次遍历即可得到除首位链接好的双向链表<br>又由于头节点head在遍历过程中pre一定为空，因此可以在递归算法中记录head值，还需要一个全局的pre指针<br><strong>不能使用Node*在函数中传递————在函数中传的是值，指针不能改变，只能改变指针指向的数据，可使用指针的指针或者全局变量</strong></p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node *pre = <span class="literal">nullptr</span>, *head = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left) preOrderTraverse(node-&gt;left);</span><br><span class="line">  <span class="keyword">if</span> (pre) &#123;</span><br><span class="line">    pre-&gt;right = node;</span><br><span class="line">    node-&gt;left = pre;</span><br><span class="line">  &#125; <span class="keyword">else</span> head = node;</span><br><span class="line">  pre = node;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;right) preOrderTraverse(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">treeToDoublyList</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  preOrderTraverse(root);</span><br><span class="line">  head-&gt;left = pre;</span><br><span class="line">  pre-&gt;right = head;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer37序列化二叉树"><a href="#剑指Offer37序列化二叉树" class="headerlink" title="剑指Offer37序列化二叉树"></a>剑指Offer37序列化二叉树</h2><ul>
<li><p>题目描述：<br><img src="Question_offer37_p1.png" alt="剑指Offer37序列化二叉树"></p>
</li>
<li><p>解法：层次遍历</p>
<blockquote>
<p>由于先序、中序、后序遍历中的任何一种都无法确定一颗二叉树，因此可以通过采用层次遍历的方式，根据隐形的个数条件确定唯一的二叉树<br>首先是serialize()序列化方法，很容易通过队列得到结果，最后通过消除末尾多余的”null,”和’,’最后添加上结束符’]’<br>最重要的是deserialize()反序列化方法，首先通过字符串切割的方式得到所有的数据并存放入集合，接着由于不是满二叉树的情况，因此不能直接通过父元素与子元素的映射得到(有空隙,如下图所示)。需要设置两个指针来确定具体的映射关系<br><img src="Question_offer37_p2.png" alt="空隙的例子"></p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">"[null]"</span>;</span><br><span class="line">  <span class="built_in">string</span> ans = <span class="string">"["</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">  q.push(root);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    TreeNode *front = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">if</span> (front) &#123;</span><br><span class="line">      ans.append(to_string(front-&gt;val)).push_back(<span class="string">','</span>);</span><br><span class="line">      q.push(front-&gt;left);</span><br><span class="line">      q.push(front-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> ans.append(<span class="string">"null,"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除末尾的"null,"</span></span><br><span class="line">  <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &gt; <span class="number">5</span> &amp;&amp; ans.substr(ans.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">"null,"</span>) &#123;</span><br><span class="line">    ans.erase(ans.<span class="built_in">size</span>() - <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去除末尾的','</span></span><br><span class="line">  ans.pop_back();</span><br><span class="line">  ans.push_back(<span class="string">']'</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data == <span class="string">"[null]"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;TreeNode *&gt; ans;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果是"null,"或"null]"</span></span><br><span class="line">    <span class="keyword">if</span> (data[start] == <span class="string">'n'</span>) &#123;</span><br><span class="line">      ans.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">      start += <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 找后一个','的位置</span></span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">end</span> = data.<span class="built_in">find</span>(<span class="string">","</span>, start);</span><br><span class="line">      <span class="comment">// 遍历到最后</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">end</span> == <span class="built_in">string</span>::npos) <span class="built_in">end</span> = data.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">int</span> value = stoi(data.substr(start, <span class="built_in">end</span> - start));</span><br><span class="line">      ans.push_back(<span class="keyword">new</span> TreeNode(value));</span><br><span class="line">      start = <span class="built_in">end</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 父元素和子元素的指针,从0开始</span></span><br><span class="line">  <span class="keyword">int</span> parent = <span class="number">0</span>, child = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (child &lt; ans.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ans[parent]) &#123;</span><br><span class="line">      ans[parent]-&gt;left = ans[child++];</span><br><span class="line">      <span class="comment">// 右为null,且不计入的情况</span></span><br><span class="line">      <span class="keyword">if</span> (child &lt; ans.<span class="built_in">size</span>()) ans[parent]-&gt;right = ans[child++];</span><br><span class="line">    &#125;</span><br><span class="line">    parent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer39数组中出现次数超过一半的数字"><a href="#剑指Offer39数组中出现次数超过一半的数字" class="headerlink" title="剑指Offer39数组中出现次数超过一半的数字"></a>剑指Offer39数组中出现次数超过一半的数字</h2><ul>
<li><p>题目描述：<br><img src="Question_offer39.png" alt="剑指Offer39数组中出现次数超过一半的数字"></p>
</li>
<li><p>解法：摩尔投票法</p>
<blockquote>
<p>若记众数(超过一半的数)的票数为+1，非众数的票数为-1，则必有所有数字的票数和大于0<br>摩尔投票法在众数存在情况下一定指示众数，否则需要验证</p>
</blockquote>
</li>
<li><p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> majority = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!count) majority = num;</span><br><span class="line">    count += (num == majority) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer48最长不含重复字符的子字符串"><a href="#剑指Offer48最长不含重复字符的子字符串" class="headerlink" title="剑指Offer48最长不含重复字符的子字符串"></a>剑指Offer48最长不含重复字符的子字符串</h2><ul>
<li><p>题目描述：<br><img src="Question_offer48.png" alt="剑指Offer48最长不含重复字符的子字符串"></p>
</li>
<li><p>解法：滑动窗口</p>
<blockquote>
<p>采用滑动窗口的方式，比如”dvdf”的例子，设置滑动窗口的当前边界left和right(初始全为0)以及一个存储字符最近遇到下标的集合(由于可见字符只有0～127共128个,因此可以设置为长度为128的向量,并赋初值-1)<br>首先扫描当前right下标的字符’d’，由于’d’未扫描过，因此right++，记录’d’最近下标为0，ans更新为1<br>接着扫描’v’，由于’v’未扫描过，因此right++，记录’v’最近下标为1，ans更新为2<br>接着扫描’d’，由于’d’扫描过且最近下标为0，因此需要将left移动到最近下标+1处————即下标为1，此时left=1，right++，记录’d’最近下标为2，ans不更新<br>再接着扫描’f’，由于’f’未扫描过，因此right++，记录’f’最近下标为3，ans更新为3<br>最后right越界，返回ans</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chars[s[right]] &gt;= left) &#123;</span><br><span class="line">      left = chars[s[right]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chars[s[right]] = right;</span><br><span class="line">    right++;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, right - left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer51数组中的逆序对"><a href="#剑指Offer51数组中的逆序对" class="headerlink" title="剑指Offer51数组中的逆序对"></a>剑指Offer51数组中的逆序对</h2><ul>
<li><p>题目描述：<br><img src="Question_offer51.png" alt="剑指Offer51数组中的逆序对"></p>
</li>
<li><p>解法1：分治法(归并排序)</p>
<blockquote>
<p>假设有两个已排序的序列等待归并计算逆序对个数，分别为L = {8, 12, 16, 22, 100}和R = {9, 26, 55, 64, 91}，使用两个指针lPtr、rPtr分别指向当前待L和R的头部<br>首先8 &lt;= 9，不存在逆序，将8放入答案数组中，lPtr++<br>…<br>这样最终得到逆序对个数即为归并L和R的逆序对的个数加上L和R别分的逆序对个数，就可以把原问题拆分成规模较小的子问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (right == left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">      swap(nums[left], nums[right]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftN = reversePairs(nums, left, mid, temp), rightN = reversePairs(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">    <span class="comment">// 如果前后总体已有序,提前退出,没有逆序对</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> leftN + rightN;</span><br><span class="line">    <span class="keyword">int</span> curN = <span class="number">0</span>, lPtr = left, rPtr = mid + <span class="number">1</span>, index = left;</span><br><span class="line">    <span class="keyword">while</span> (lPtr &lt;= mid &amp;&amp; rPtr &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[lPtr] &lt;= nums[rPtr]) &#123;</span><br><span class="line">        curN += rPtr - mid - <span class="number">1</span>;</span><br><span class="line">        temp[index++] = nums[lPtr++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[index++] = nums[rPtr++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lPtr &lt;= mid) &#123;</span><br><span class="line">      curN += right - mid;</span><br><span class="line">      temp[index++] = nums[lPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rPtr &lt;= right) &#123;</span><br><span class="line">      temp[index++] = nums[rPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">      nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftN + curN + rightN;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> reversePairs(nums, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：树状数组<br>#TODO</p>
</li>
</ul>
<h2 id="剑指Offer56数组中数字出现的次数I"><a href="#剑指Offer56数组中数字出现的次数I" class="headerlink" title="剑指Offer56数组中数字出现的次数I"></a>剑指Offer56数组中数字出现的次数I</h2><ul>
<li><p>问题描述：<br><img src="Question_offer56I.png" alt="剑指Offer56数组中数字出现的次数I"></p>
</li>
<li><p>解法：异或分组</p>
<blockquote>
<p>由于异或运算有一种性质：A异或A为0，因此通过对所有数字进行异或，能得到两个单数S1、S2的异或结果res<br>接着通过得到res的最高位div(其后全0)，由于最高位div只能由一个数提供(S1或S2)，因此可通过div与S1、S2的和，查看是否满足最高位为div，由此可将S1、S2分成两个数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    res ^= num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取得最高的不同位</span></span><br><span class="line">  <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((div &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">    div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过是否满足最高位区分单数</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (div &amp; num) &#123;</span><br><span class="line">      a ^= num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      b ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer56数组中数字出现的次数II"><a href="#剑指Offer56数组中数字出现的次数II" class="headerlink" title="剑指Offer56数组中数字出现的次数II"></a>剑指Offer56数组中数字出现的次数II</h2><ul>
<li><p>问题描述：<br><img src="Question_offer56II.png" alt="剑指Offer56数组中数字出现的次数II"></p>
</li>
<li><p>解决思路：</p>
<blockquote>
<p>由于其他数字都出现了三次，如果采用map的话，效率太低<br>考虑比特位集合，由于int可以转化为32个bit位，如果每个数都出现三次，那么各个位同样也出现了三次，那么只需要统计出各个位的数目，在取余就可以得到0或1，就可以复原出唯一的数</p>
</blockquote>
</li>
<li><p>解法1：遍历统计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计比特位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">bitSet</span>, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) <span class="built_in">bitSet</span>[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bitSet</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 遍历统计</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    calculateBit(<span class="built_in">bitSet</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 还原唯一数的比特位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bitSet</span>[i] % <span class="number">3</span>) ans += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：状态转换图</p>
<blockquote>
<p>由于次数由0变为1，再变为2，最终回到0，可以联想到状态转换(数字逻辑电路)<br>由于0 -&gt; 1 -&gt; 2 -&gt; 0需要两个bit位才能承载，因此扩展为00 -&gt; 01 -&gt; 10 -&gt; 00<br>有转换图</p>
<table>
<thead>
<tr>
<th>n</th>
<th>two(before)</th>
<th>one(before)</th>
<th>two(after)</th>
<th>one(after)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>如果n输入位0，那么bit位无需变化；若为1，则需要相应的变化<br>当two为0，n为0时，one = one；n为1时，one = ~one，因此此时<code>one = one ^ n</code><br>当two为1，n为0时，one = 0；n为1时，one = 0，因此此时<code>one = 0</code><br>综合得到<code>one = (~two &amp; (one ^ n)) | 0</code>即<code>one = one ^ n &amp; ~two</code><br>同理，当one为0，n为0时，two = two；n为1时，two = ~two，因此此时<code>two = two ^ n</code><br>当one为1，n为0时，two = 0；n为1时，two = 0，因此此时<code>two = 0</code><br>因此，one与two一样的表达式<code>two = two ^ n &amp; (~one)</code><br>由于每个位都具有独立性，因为int与一个bit一样同样遵循上述规律<br>结果时one为1，因此最后的结果由00 -&gt; 01，而one就是最终的结果</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">    one = one ^ num &amp; (~two);</span><br><span class="line">    two = two ^ num &amp; (~one);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer60n个骰子的点数"><a href="#剑指Offer60n个骰子的点数" class="headerlink" title="剑指Offer60n个骰子的点数"></a>剑指Offer60n个骰子的点数</h2><ul>
<li><p>题目描述：<br><img src="Question_offer60.png" alt="剑指Offer60n个骰子的点数"></p>
</li>
<li><p>解法：动态规划</p>
<blockquote>
<p>考虑骰子的变动，从n-1个骰子到n个骰子肯定存在联系，因此可能会有动态转移方程<br>假设前一次的骰子的各个点数出现的次数为dp[n - 1][j] (j点)<br>那么dp[n][j] = sum{dp[n - 1][j - t]} (1 &lt;= t &lt;= 6)<br>也即是此次n个骰子要想产生j点，那么可以从n-1个骰子不超过j点的次数(t)加当前确定的次数(j - t)的总和</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算概率</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">getProbability</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = v.<span class="built_in">size</span>(), sum = <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    ans[i] = v[i] * <span class="number">1.0</span> / sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>].resize(<span class="number">6</span>);</span><br><span class="line">  <span class="comment">// 初始化为1个骰子的情况</span></span><br><span class="line">  <span class="built_in">fill</span>(dp[<span class="number">0</span>].<span class="built_in">begin</span>(), dp[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 从n个1到n个6</span></span><br><span class="line">    dp[i].resize(<span class="number">5</span> * (i + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dp[i - <span class="number">1</span>].<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">        <span class="comment">// 化简(不考虑真实点数,考虑偏移)</span></span><br><span class="line">        dp[i][j + k] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getProbability(dp[n - <span class="number">1</span>], n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指Offer62圆圈中最后剩下的数字"><a href="#剑指Offer62圆圈中最后剩下的数字" class="headerlink" title="剑指Offer62圆圈中最后剩下的数字"></a>剑指Offer62圆圈中最后剩下的数字</h2><ul>
<li><p>题目描述：<br><img src="Question_offer62.png" alt="剑指Offer62圆圈中最后剩下的数字"></p>
</li>
<li><p>解法1：数学 + 递归</p>
<blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：数学 + 动态规划</p>
<blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://sobxiong.github.io/2020/12/11/BasicSkill/Algorithm/ProblemRecord/>https://sobxiong.github.io/2020/12/11/BasicSkill/Algorithm/ProblemRecord/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-03-06T21:21:45+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2021年3月6日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/BasicSkill/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>BasicSkill</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/LeetCode%E9%A2%98%E8%A7%A3/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>LeetCode题解</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sobxiong.github.io/2020/12/11/BasicSkill/Algorithm/ProblemRecord/&title=刷题记录 - SOBXiong的博客&summary=内容
10正则表达式匹配
218天际线问题
220存在重复元素III
239滑动窗口最大值
241为运算表达式设计优先级
264丑数II
279完全平方数
282给表达式添加运算符
316去除重复字母
321拼接最大数
338比特位计数
354俄罗斯套娃信封问题
395至少有K个重复字符的最长子串
493翻转对
514自由之路
621任务调度器
659分割数组为连续子序列
803打砖块
947移除最多的同行或同列石头
959由斜杠划分区域
995K连续位的最小翻转次数
1178猜字谜
1438绝对差不超过限制的最长连续子数组
1489找到最小生成树里的关键边和伪关键边
1631最小体力消耗路径
1776车队II
剑指Offer36二叉搜索树与双向链表
剑指Offer37序列化二叉树
剑指Offer39数组中出现次数超过一半的数字
剑指Offer48最长不含重复字符的子字符串
剑指Offer51数组中的逆序对
剑指Offer56数组中数字出现的次数I
剑指Offer56数组中数字出现的次数II
剑指Offer60n个骰子的点数
剑指Offer62圆圈中最后剩下的数字
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sobxiong.github.io/2020/12/11/BasicSkill/Algorithm/ProblemRecord/&title=刷题记录 - SOBXiong的博客&summary=内容
10正则表达式匹配
218天际线问题
220存在重复元素III
239滑动窗口最大值
241为运算表达式设计优先级
264丑数II
279完全平方数
282给表达式添加运算符
316去除重复字母
321拼接最大数
338比特位计数
354俄罗斯套娃信封问题
395至少有K个重复字符的最长子串
493翻转对
514自由之路
621任务调度器
659分割数组为连续子序列
803打砖块
947移除最多的同行或同列石头
959由斜杠划分区域
995K连续位的最小翻转次数
1178猜字谜
1438绝对差不超过限制的最长连续子数组
1489找到最小生成树里的关键边和伪关键边
1631最小体力消耗路径
1776车队II
剑指Offer36二叉搜索树与双向链表
剑指Offer37序列化二叉树
剑指Offer39数组中出现次数超过一半的数字
剑指Offer48最长不含重复字符的子字符串
剑指Offer51数组中的逆序对
剑指Offer56数组中数字出现的次数I
剑指Offer56数组中数字出现的次数II
剑指Offer60n个骰子的点数
剑指Offer62圆圈中最后剩下的数字
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sobxiong.github.io/2020/12/11/BasicSkill/Algorithm/ProblemRecord/&title=刷题记录 - SOBXiong的博客&summary=内容
10正则表达式匹配
218天际线问题
220存在重复元素III
239滑动窗口最大值
241为运算表达式设计优先级
264丑数II
279完全平方数
282给表达式添加运算符
316去除重复字母
321拼接最大数
338比特位计数
354俄罗斯套娃信封问题
395至少有K个重复字符的最长子串
493翻转对
514自由之路
621任务调度器
659分割数组为连续子序列
803打砖块
947移除最多的同行或同列石头
959由斜杠划分区域
995K连续位的最小翻转次数
1178猜字谜
1438绝对差不超过限制的最长连续子数组
1489找到最小生成树里的关键边和伪关键边
1631最小体力消耗路径
1776车队II
剑指Offer36二叉搜索树与双向链表
剑指Offer37序列化二叉树
剑指Offer39数组中出现次数超过一半的数字
剑指Offer48最长不含重复字符的子字符串
剑指Offer51数组中的逆序对
剑指Offer56数组中数字出现的次数I
剑指Offer56数组中数字出现的次数II
剑指Offer60n个骰子的点数
剑指Offer62圆圈中最后剩下的数字
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/12/12/Middleware/Redis/Redis%E5%9F%BA%E7%A1%80/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Redis基础</p>
                <p class='content'>内容
Redis介绍
Redis持久化
Redis事务
Redis消息发布订阅
Redis主从复制
Redis常用配置



Redis介绍
NoSQL简介：NoSQL(Not Only SQL...</p>
              </a>
            
            
              <a class='next' href='/2020/12/08/Middleware/MySQL/MySQL%E5%9F%BA%E7%A1%80/'>
                <p class='title'>MySQL基础<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>内容
SQL语句
表约束和范式
多表查询和子查询
事务
存储引擎
其他



SQL语句
SQL概述

什么是SQL：SQL(Structured Query Language)是”结构化查询语...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '刷题记录',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10正则表达式匹配"><span class="toc-text">10正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#218天际线问题"><span class="toc-text">218天际线问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#220存在重复元素III"><span class="toc-text">220存在重复元素III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239滑动窗口最大值"><span class="toc-text">239滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#241为运算表达式设计优先级"><span class="toc-text">241为运算表达式设计优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#264丑数II"><span class="toc-text">264丑数II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279完全平方数"><span class="toc-text">279完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#282给表达式添加运算符"><span class="toc-text">282给表达式添加运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#316去除重复字母"><span class="toc-text">316去除重复字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#321拼接最大数"><span class="toc-text">321拼接最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#338比特位计数"><span class="toc-text">338比特位计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#354俄罗斯套娃信封问题"><span class="toc-text">354俄罗斯套娃信封问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#395至少有K个重复字符的最长子串"><span class="toc-text">395至少有K个重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#493翻转对"><span class="toc-text">493翻转对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#514自由之路"><span class="toc-text">514自由之路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#621任务调度器"><span class="toc-text">621任务调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#659分割数组为连续子序列"><span class="toc-text">659分割数组为连续子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#803打砖块"><span class="toc-text">803打砖块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#947移除最多的同行或同列石头"><span class="toc-text">947移除最多的同行或同列石头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#959由斜杠划分区域"><span class="toc-text">959由斜杠划分区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#995K连续位的最小翻转次数"><span class="toc-text">995K连续位的最小翻转次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1178猜字谜"><span class="toc-text">1178猜字谜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1438绝对差不超过限制的最长连续子数组"><span class="toc-text">1438绝对差不超过限制的最长连续子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1489找到最小生成树里的关键边和伪关键边"><span class="toc-text">1489找到最小生成树里的关键边和伪关键边</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1631最小体力消耗路径"><span class="toc-text">1631最小体力消耗路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1776车队II"><span class="toc-text">1776车队II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer36二叉搜索树与双向链表"><span class="toc-text">剑指Offer36二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer37序列化二叉树"><span class="toc-text">剑指Offer37序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer39数组中出现次数超过一半的数字"><span class="toc-text">剑指Offer39数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer48最长不含重复字符的子字符串"><span class="toc-text">剑指Offer48最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer51数组中的逆序对"><span class="toc-text">剑指Offer51数组中的逆序对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer56数组中数字出现的次数I"><span class="toc-text">剑指Offer56数组中数字出现的次数I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer56数组中数字出现的次数II"><span class="toc-text">剑指Offer56数组中数字出现的次数II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer60n个骰子的点数"><span class="toc-text">剑指Offer60n个骰子的点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#剑指Offer62圆圈中最后剩下的数字"><span class="toc-text">剑指Offer62圆圈中最后剩下的数字</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:1942991710@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/SOBXiong"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="http://xiongjc.top" target="_blank" rel="noopener">Copyright © 2017-2020 SOBXiong</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
