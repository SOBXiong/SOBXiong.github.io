<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>设计模式 - SOBXiong的博客</title>
  
    <meta name="keywords" content="BasicSkill">
  
  
    <meta name="description" content="内容
七大原则
UML类图
设计模式概述
单例模式
工厂模式
原型模式
建造者模式
适配器模式
桥接模式
装饰者模式
组合模式
外观模式
享元模式
代理模式
模板方法模式
命令模式
访问者模式
迭代器模式
观察者模式
中介者模式
备忘录模式
解释器模式
状态模式
策略模式
职责链模式
">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png'></i>
          
          
            SOBXiong
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/10/09/BasicSkill/DesignPattern/">
      设计模式
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="http://xiongjc.top" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/hdImg_f757fa7e0fd65077ce52d251fc7a01d815860762755.jpg">
    <p>SOBXiong</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年10月9日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><a href="#七大原则">七大原则</a></li>
<li><a href="#UML类图">UML类图</a></li>
<li><a href="#设计模式概述">设计模式概述</a></li>
<li><a href="#单例模式">单例模式</a></li>
<li><a href="#工厂模式">工厂模式</a></li>
<li><a href="#原型模式">原型模式</a></li>
<li><a href="#建造者模式">建造者模式</a></li>
<li><a href="#适配器模式(待完善)">适配器模式</a></li>
<li><a href="#桥接模式">桥接模式</a></li>
<li><a href="#装饰者模式">装饰者模式</a></li>
<li><a href="#组合模式">组合模式</a></li>
<li><a href="#外观模式">外观模式</a></li>
<li><a href="#享元模式">享元模式</a></li>
<li><a href="#代理模式">代理模式</a></li>
<li><a href="#模板方法模式">模板方法模式</a></li>
<li><a href="#命令模式">命令模式</a></li>
<li><a href="#访问者模式">访问者模式</a></li>
<li><a href="#迭代器模式">迭代器模式</a></li>
<li><a href="#观察者模式">观察者模式</a></li>
<li><a href="#中介者模式">中介者模式</a></li>
<li><a href="#备忘录模式">备忘录模式</a></li>
<li><a href="#解释器模式">解释器模式</a></li>
<li><a href="#状态模式">状态模式</a></li>
<li><a href="#策略模式">策略模式</a></li>
<li><a href="#职责链模式">职责链模式</a></li>
</ul>
<a id="more"></a>

<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><ul>
<li><p>设计模式目的：编写软件过程中，程序员面临着来自耦合性、内聚性、可维护性、可扩展性、重用性和灵活性等多方面的挑战，设计模式是为了让程序(软件)具有更好的</p>
<ol>
<li>代码重用性(相同功能的代码,不用多次编写)</li>
<li>可读性(编程规范性,便于其他程序员的阅读和理解)</li>
<li>可扩展性(当需要增加新的功能时非常的方便,也称为可维护性)</li>
<li>可靠性(当我们增加新的功能后对原来的功能没有影响)</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ol>
</li>
<li><p>设计模式原则其实就是程序员在编程时应当遵守的原则，也是各种设计模式的基础</p>
</li>
<li><p>设计原则核心思想：</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不和不需要变化的代码混在一起</li>
<li>面向接口编程，而不是面向实现编程</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
</li>
<li><p>七大原则：</p>
<ol>
<li>单一职责原则：<strong>一个类和方法只做一件事，一个类应该也只有一个引起它修改的原因</strong></li>
<li>接口隔离原则：<strong>客户端不应依赖它不需要的接口</strong></li>
<li>依赖倒转(倒置)原则：<strong>细节依赖抽象，下层依赖上层</strong></li>
<li>里氏替换原则：<strong>子类应该可以完全替换父类。在使用继承时只扩展新功能而不破坏父类原有的功能</strong></li>
<li>开闭原则：<strong>一个软件实体如类、模块和函数应该对修改封闭，对扩展开放</strong></li>
<li>迪米特原则：<strong>最小知道原则，一个类不应知道自己操作的类的细节</strong></li>
<li>合成复用原则</li>
</ol>
</li>
<li><p>单一职责原则</p>
<ul>
<li><p>基本介绍：对类来说一个类应该只负责一项职责。如类A负责两个不同职责——职责1和2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1和A2</p>
</li>
<li><p>案例分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始方案</span></span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案1</span></span><br><span class="line"><span class="comment">// 1、遵守单一职责原则</span></span><br><span class="line"><span class="comment">// 2、但是这样做的改动很大,将类分解同时修改客户端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"公路运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"天空运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">"水中运行"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">roadVehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案2</span></span><br><span class="line"><span class="comment">// 1、没有对原来的类做大的修改,只是增加方法</span></span><br><span class="line"><span class="comment">// 2、虽然没有在类这个级别上遵守单一职责原则,但在方法级别上仍然是遵守单一职责</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在天空上运行...."</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123; System.out.println(vehicle + <span class="string">" 在水中行...."</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">vehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">vehicle.runAir(<span class="string">"飞机"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节</p>
<ol>
<li>降低类的复杂度，一个类只负责一项职责(尽量)</li>
<li>提高类的可读性、可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，我们应当遵守单一职责原则。只有逻辑足够简单时才可以在代码级违反单一职责原则；只有类中方法数量足够少时才可以在方法级别保持单一职责原则</li>
</ol>
</li>
</ul>
</li>
<li><p>接口隔离原则</p>
<ul>
<li><p>基本介绍：客户端不应该依赖它不需要的接口(<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>)</p>
</li>
<li><p>案例分析：<br><img src="%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D.png" alt="接口隔离案例介绍"></p>
<ul>
<li><p>改进措施：将接口Interface1拆分为独立的几个接口，类A和C分别与它们需要的接口建立依赖关系(也就是采用接口隔离原则)</p>
</li>
<li><p>改进结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">interface1</span>, <span class="title">interface2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">interface1</span>, <span class="title">interface3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>依赖倒转原则</p>
<ul>
<li><p>基本介绍：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></li>
<li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong></li>
<li>设计理念：相对于细节的多变，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中抽象指的是接口或抽象类，细节是具体的实现类</li>
<li><strong>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</strong></li>
</ol>
</li>
<li><p>案例分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="comment">// 如果我们getInfo需要微信、短信等消息</span></span><br><span class="line"><span class="comment">// 则新增类同时Person类也要增加相应的接收方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123; System.out.println(email.getInfo());&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进方案：引入一个抽象的接口IReceiver表示接收者</span></span><br><span class="line"><span class="comment">// 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">// Email、WeiXin等属于接收者的范围,各自实现IReceiver接口,遵循了依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增接收者不需要对Person类进行改动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 改为对接口IReceiver的依赖</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123; System.out.println(receiver.getInfo());&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">person.receive(<span class="keyword">new</span> WeiXin());</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖关系传递的三种方式：</p>
<ol>
<li><p>接口依赖</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemote</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">closeTv</span><span class="params">(ITv tv)</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> <span class="keyword">implements</span> <span class="title">IRemote</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeTv</span><span class="params">(ITv tv)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Mate30Pro close tv~~~"</span>);</span><br><span class="line">    tv.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法传递</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITv tv;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mate30Pro</span><span class="params">(ITv tv)</span> </span>&#123; <span class="keyword">this</span>.tv = tv;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.tv.close();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setter方式传递</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITv</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTv</span> <span class="keyword">implements</span> <span class="title">ITv</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Close Huawei TV~~~"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mate30Pro</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITv tv;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setTv</span><span class="params">(ITv tv)</span> </span>&#123; <span class="keyword">this</span>.tv = tv;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.tv.close();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>注意事项和细节：</p>
<ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li>
<li><strong>变量的声明类型尽量是抽象类或接口</strong>，这样变量引用和实际对象间存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
</li>
</ul>
</li>
<li><p>里氏替换原则</p>
<ul>
<li>OO(Object Oriented,面向对象)继承性的思考和说明：<ol>
<li>继承包含这一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约。虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。如使用继承会给程序带来侵入性、程序的可移植性降低、增加对象间的耦合性；如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及子类的功能都有可能产生错误</li>
<li>问题提出：在编程中，如何正确的使用继承?——遵循里氏替换原则</li>
</ol>
</li>
<li>基本介绍：<ol>
<li>里氏替换原则(Liskov Substitution Principle)在1988年由麻省理工学院的以为姓里的女士提出</li>
<li>如果每个类型为T1的对象o1都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<strong>换句话说，所有引用基类的地方必须都能透明地使用其子类的对象</strong></li>
<li>在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不重写父类的方法</strong></li>
<li>里氏替换原则告诉我们继承实际上让两个类耦合性增强了，在适当的情况下，可通过<strong>聚合、组合和依赖</strong>来解决问题</li>
</ol>
</li>
</ul>
</li>
<li><p>开闭原则</p>
<ul>
<li><p>基本介绍：</p>
<ol>
<li>开闭原则(Open Closed Principle)是编程中<strong>最基础、最重要</strong>的设计原则</li>
<li>一个软件实体如类、模块和函数应该<strong>对扩展开放(对提供方)，对修改关闭(对使用方)</strong>。用抽象构建框架，用实现扩展细节</li>
<li>当软件需要变化时，<strong>尽量通过扩展</strong>软件实体的行为来实现变化，<strong>而不是通过修改</strong>已有的代码来实现变化</li>
<li>编程中设计模式和其他原则的基础就是开闭原则</li>
</ol>
</li>
<li><p>案例分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.type == <span class="number">1</span>) drawRectangle(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s.type == <span class="number">2</span>) drawCircle(s);</span><br><span class="line">    <span class="comment">// 新增三角形</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s.type == <span class="number">3</span>) drawTriangle(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Rectangle"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Circle"</span>);&#125;</span><br><span class="line">  <span class="comment">// 新增三角形</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123; System.out.println(<span class="string">"Draw Triangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; <span class="keyword">int</span> type;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Rectangle() &#123; <span class="keyword">super</span>.type = <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Circle() &#123; <span class="keyword">super</span>.type = <span class="number">2</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Triangle() &#123; <span class="keyword">super</span>.type = <span class="number">3</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123; s.draw();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Rectangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Circle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Triangle"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一样的调用方式</span></span><br><span class="line">GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>迪米特法则</p>
<ul>
<li>基本介绍：<ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫<strong>最少知识原则，即一个类对自己依赖的类知道的越少越好</strong>。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多：依赖、关联、组合和聚合等。其中称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li>
</ol>
</li>
<li>注意事项和细节：<ol>
<li>迪米特法则的核心是降低类之间的耦合</li>
<li>注意：迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系</li>
</ol>
</li>
</ul>
</li>
<li><p>合成复用原则(Composite Reuse Principle)：尽量使用合成/聚合的方式，而不是使用继承</p>
</li>
</ul>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><ul>
<li>UML基本介绍：<ol>
<li>UML——Unified modeling language(统一建模语言)是一种用于软件系统分析和设计的语言工具，用于帮助软件开发人员进行思考和记录思路的结果</li>
<li>UML本身是一套符号的规定，就像数学符号和化学符号一样。这些符号用于描述软件模型中的各个元素和它们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</li>
</ol>
</li>
<li>UML图分类：<ol>
<li>用例图(use case)</li>
<li>静态结构图：类图(描述类与类之间的关系,是UML图中最核心的)、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图(时序图与协作图)、状态图、活动图</li>
</ol>
</li>
<li>UML类图基本介绍：<ol>
<li>用于描述系统中的<strong>类(对象)本身的组成和类(对象)之间的各种静态关系</strong></li>
<li>类之间的关系：<strong>依赖、泛化(继承)、实现、关联、聚合与组合</strong></li>
</ol>
</li>
<li>类之间的关系：<ol>
<li>依赖关系(Dependence)：<ul>
<li>基本介绍：<strong>只要是在类中用到了对方，那么他们之间就存在依赖关系</strong>。如果没有对方，连编绎都通过不了</li>
<li>具体体现：<ol>
<li>类的成员属性</li>
<li>类的成员方法的返回类型</li>
<li>类的成员方法接收的参数类型</li>
<li>类的成员方法中使用到</li>
<li>存在继承、实现等多态关系</li>
</ol>
</li>
</ul>
</li>
<li>泛化关系(Generalization)：<strong>泛化关系实际上就是继承关系</strong>，是依赖关系的特例</li>
<li>实现关系(Implementation)：<strong>实现关系实际上就是实现(接口)关系</strong>，是依赖关系的特例</li>
<li>关联关系(Association)：<ul>
<li>基本介绍：关联关系实际上就是<strong>类与类之间的联系</strong>，是依赖关系的特例(引用数)</li>
<li>性质：<ol>
<li>具有<strong>导航性</strong>：即双向或单向关系</li>
<li>具有多重性：如”1”(表示有且仅有一个)、”0…”(表示0个或者多个)、”0,1”(表示0个或1个),”n…m”(表示n到m个),”m…”(表示至少m个)</li>
</ol>
</li>
</ul>
</li>
<li>聚合关系(Aggregation)：<strong>表示的是整体和部分的关系，整体与部分可以分开</strong>。聚合关系是关联关系的特例，所以具有关联的导航性与多重性</li>
<li>组合关系(Composition)：也是整体与部分的关系，但是整体与部分不可以分开(逻辑或者代码层面上)</li>
</ol>
</li>
</ul>
<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><ul>
<li>基本介绍：<ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。设计模式不是代码，而是某类问题的通用解决方案，设计模式(Design pattern)代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验总结出来的</li>
<li>设计模式的本质：提高软件的维护性、通用性和扩展性，降低软件的复杂度</li>
<li>设计模式并不局限于某种语言，Java，PHP，C++都有设计模式</li>
</ol>
</li>
<li>类型：<ol>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</li>
<li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)</li>
</ol>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>介绍：保证一个类只有一个实例，哪怕多线程同时访问，并提供一个全局访问此实例的方法</p>
</li>
<li><p>典型场景：</p>
<ol>
<li>数据库连接池</li>
<li>Spring中的单例Bean</li>
</ol>
</li>
<li><p>单例设计模式的八种实现方式</p>
<ol>
<li><p><strong>饿汉式(静态常量)</strong></p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、构造器私有化(防止外部new)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、类内创建对象(静态常量)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">// 3、向外暴露静态公共方法,返回单例instance</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>优点：写法较简单，在类装载的时候就完成了实例化。避免了线程同步问题</li>
<li>缺点：在类装载时就完成了实例化，没有达到Lazy Loading(懒加载)的效果。如果从始至终未使用过这个实例，则会造成内存的浪费</li>
<li>该方式基于类加载机制避免了多线程的同步问题，instance在类装载时就实例化。虽然导致类装载的原因有很多种，在单例模式中大多数时候都是调用getInstance()方法。但不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化instance就没有达到Lazy Loading的效果</li>
<li>结论：该单例模式可用，但可能造成内存浪费(一般可忽略)</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>饿汉式(静态代码块)</strong></p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、在静态代码块中,创建单例对象</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4、提供一个公有静态方法,返回实例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>该方式和方式一类似，过将类实例化的过程放在静态代码块中。在类装载时执行静态代码块中的代码，初始化类的实例。优缺点同方式一</li>
<li>结论：该单例模式可用，但可能造成内存浪费(一般可忽略)</li>
</ol>
</li>
</ul>
</li>
<li><p>懒汉式(线程不安全)</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>起到了Lazy Loading的效果，但只能在单线程下使用</li>
<li>在多线程下，当一个线程进入了if判断语句块，还未来得及往下执行；同时另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li>
<li>结论：在实际开发中，不使用这种方式</li>
</ol>
</li>
</ul>
</li>
<li><p>懒汉式(线程安全,同步方法)</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例(声明为同步方法,解决线程安全问题)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> Singleton();&#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>解决了线程安全问题</li>
<li>效率太低了，每个线程在想获得该类的实例时执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return即可。方法进行同步效率太低</li>
<li>结论：在实际开发中，不推荐使用这种方式</li>
</ol>
</li>
</ul>
</li>
<li><p>懒汉式(线程不安全,同步代码块)</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,当调用该方法时才去创建instance实例(加入synchronized同步代码块,还存在线程安全问题)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>还存在线程安全问题(都进入到判断后,未开始同步,会实例化两次)</li>
<li>结论：在实际开发中，不使用这种方式</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>双重检查(Double-Check)</strong></p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态变量实例(volatile声明,内存可见)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,设置双重检查,解决线程安全问题,同时解决懒加载问题,保证了效率,推荐使用</span></span><br><span class="line">  <span class="comment">// 几乎解决了线程安全问题</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> Singleton();&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>Double-Check概念是多线程开发中常使用到的。进行了两次if检查，这几乎可以保证线程安全</li>
<li>实例化代码只执行一次，再次访问时直接返回实例化对象。也避免反复进行方法同步</li>
<li>线程安全、延迟加载、效率较高</li>
<li>结论：在实际开发中推荐使用该方式</li>
</ol>
</li>
</ul>
</li>
<li><p>静态内部类</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 2、声明静态内部类,该类中有一个静态常量Singleton</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3、提供一个公有静态方法,直接返回静态内部类中的静态常量INSTANCE</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>该方式在Singleton类被装载时并不会立即实例化，而是在首次调用getInstance()方法时装载SingletonInstance类，从而完成Singleton的实例化</li>
<li>类的静态属性只会在第一次加载类的时候初始化，在这里JVM帮助我们保证了线程的安全性。在类进行初始化时其他线程是无法进入的</li>
<li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li>
<li>结论：推荐使用</li>
</ol>
</li>
</ul>
</li>
<li><p>枚举</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、声明枚举类</span></span><br><span class="line"><span class="keyword">enum</span> Singletion&#123;</span><br><span class="line">  <span class="comment">// 2、声明一个实例</span></span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="comment">// 测试方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"ok~"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</li>
<li>在有继承的场景下不适用</li>
<li>结论：推荐使用(Effective Java作者推荐)</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>源码中的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime.class</span></span><br><span class="line"><span class="comment">// 采用饿汉式创建,因为其他地方需要用到,不会产生内存浪费</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currentRuntime;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式注意事项和细节说明：</p>
<ol>
<li>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源。对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，要使用相应的获取对象的方法(通常是getInstance())，而不是使用new创建</li>
<li>单例模式使用的场景：<strong>需要频繁地进行创建和销毁的对象</strong>、创建对象耗时过多或耗费资源过多(即<strong>重量级对象</strong>)但又经常用到的对象、<strong>工具类对象</strong>、频繁访问数据库或文件的对象(比如<strong>数据源、session工厂</strong>等)</li>
</ol>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li><p>问题背景：在平时编程中，构建对象最常用的方式是new一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每new一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式</p>
</li>
<li><p>简单工厂模式</p>
<ul>
<li><p>基本介绍：让一个工厂类继承构建所有对象的职责(将构建工作封装到一个工厂类中)</p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是对传统方式做了一层简单的封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用处代码修改较小,大多只需在工厂类中修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果某个构造方式相当复杂,可以大大减少代码重复</span></span><br><span class="line">    <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"apple"</span>: <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"huawei"</span>: &#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Mate()</span><br><span class="line">        <span class="comment">// 具体设置工作...</span></span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No other brands now~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">PhoneFactory factory = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line"><span class="comment">// 直接new需要知道mate和iphone的具体构造细节</span></span><br><span class="line">Phone mate = factory.create(<span class="string">"huawei"</span>);</span><br><span class="line">Phone iphone = factory.create(<span class="string">"apple"</span>);</span><br><span class="line">mate.takePhoto();</span><br><span class="line">iphone.takePhoto();</span><br></pre></td></tr></table></figure>
</li>
<li><p>弊端：</p>
<ol>
<li>如果需生产的产品过多会导致工厂类过于庞大，承担过多的职责，变成超级类。每个产品生产过程的修改都需要修改工厂类(不止一个引起修改的原因)。违背了单一职责原则</li>
<li>当要生产新的产品时，必须在工厂类中添加新的判断分支。而开闭原则告诉我们：类应该对修改封闭。即添加新功能时最好只需增加新的类，而不是修改既有的类</li>
</ol>
</li>
</ul>
</li>
<li><p>工厂方式模式：</p>
<ul>
<li><p>由来：为了解决简单工厂的两处弊端</p>
</li>
<li><p>基本介绍：<strong>定义一个创建对象的抽象方法，由子类决定要实例化的类</strong>。工厂方法模式<strong>将对象的实例化推迟到子类</strong></p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、产品种类增加时不会变成超级工厂,工厂类会变多,保持灵活</span></span><br><span class="line"><span class="comment">2、改变只需改变对应工厂的方法</span></span><br><span class="line"><span class="comment">3、新增产品,无需修改已有的工厂,只需添加新工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 注意：factory接口必须声明慎重,更改接口需要更改所有的工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Mate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">PhoneFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">Phone iphone = appleFactory.create();</span><br><span class="line">PhoneFactory huaweiFactory = <span class="keyword">new</span> HuaweiFactory();</span><br><span class="line">Phone mate = huaweiFactory.create();</span><br><span class="line">iphone.takePhoto();</span><br><span class="line">mate.takePhoto();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>抽象工厂模式：</p>
<ul>
<li><p>基本介绍：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。简单来说工厂方法是创建出<strong>一种</strong>产品，抽象工厂则是创建<strong>一类</strong>产品</p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TerminalFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Phone <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Pad <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Watch <span class="title">ceate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">TerminalFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Phone <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pad <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IPad();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Watch <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Watch();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>源码中的应用(简单工厂)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Calendar.getInstance();</span><br><span class="line"><span class="comment">// Calendar.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone, Locale aLocale)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">    String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">    <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结：</p>
<ol>
<li>工厂模式的意义：将实例化对象的代码提取出来放到一个类中统一管理和维护，达到解耦的目的，从而提高项目的扩展和维护性</li>
<li>设计模式的依赖抽象原则：<ol>
<li>创建对象实例时尽量不要直接new，而是封装到工厂的方法中</li>
<li>尽量不要让类继承具体类，而是继承抽象类或者是实现接口</li>
<li>尽量不要覆盖基类中已经实现的方法</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><ul>
<li><p>传统方式</p>
<ul>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以买周董同款奶茶为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea jZhouMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">jZhouMilkTea.type = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">jZhouMilkTea.isCold = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假复制(和周董喝的是同一杯奶茶)</span></span><br><span class="line">MilkTea xiongMilkTea = jZhouMilkTea;</span><br><span class="line"><span class="comment">// 真复制</span></span><br><span class="line">MilkTea xiongMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">xiongMilkTea.type = jZhouMilkTea.type;</span><br><span class="line">xiongMilkTea.isCold = jZhouMilkTea.isCold;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点：</p>
<ol>
<li>优点：比较好理解，简单易操作</li>
<li>如果对象的属性较多或需要复制的数量较多，那么会造成大量的重复</li>
<li>如果对象改变，使用复制的代码也需进行较大的改动</li>
</ol>
</li>
</ul>
</li>
<li><p>原型模式</p>
<ul>
<li><p>基本介绍：</p>
<ol>
<li>原型模式(Prototype)指<strong>用原型实例指定创建对象的细节，通过拷贝原型创建新的对象</strong></li>
<li>原型模式是一种创建型设计模式，允许通过一个对象再创建另外一个可定制的对象而无需知道如何创建的细节</li>
<li>Java中原生支持——Object的clone()方法</li>
</ol>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java自带的clone()方法是浅拷贝,只有基本类型的属性会被拷贝,类类型几乎都是传递引用(String等除外)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isCold;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MilkTea <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (MilkTea) <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea jZhouMilkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line">jZhouMilkTea.type = <span class="string">"珍珠奶茶"</span>;</span><br><span class="line">jZhouMilkTea.isCold = <span class="keyword">true</span>;</span><br><span class="line">MilkTea xiongMilkTea = jZhouMilkTea.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节：</p>
<ol>
<li>创建新的对象比较复杂时可以利用原型模式简化对象的创建过程，同时也能够提高效率</li>
<li>不用重新初始化对象，而是动态地获得对象运行时的状态</li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
</ol>
</li>
<li><p>源码中的应用：Java中的Object的clone()方法，采用C++ Cloneable接口，否则运行时出错</p>
</li>
</ul>
</li>
<li><p>浅拷贝和深拷贝：</p>
<ul>
<li><p>浅拷贝介绍：</p>
<ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递(将该属性值复制一份给新的对象)</li>
<li>对于数据类型是引用数据类型的成员变量(某个数组、某个类的对象等)，那么浅拷贝会进行引用传递(实际也是值拷贝,引用值拷贝)，即只是将该成员变量的引用值(内存地址)复制一份给新的对象。因此实际上两个对象的该成员变量都指向同一个实例。在该情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li>
<li>Java Object的clone()方法默认就是浅拷贝</li>
</ul>
</li>
<li><p>深拷贝介绍：</p>
<ul>
<li>复制对象的所有基本数据类型的成员变量值</li>
<li>为所有引用数据类型的成员变量申请存储空间，复制每个引用数据类型成员变量所引用的对象(该对象可达的所有对象)。即<strong>对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝</strong></li>
<li>在Java中可通过以下两种方式实现深拷贝：<ol>
<li>自定义类中实现cloneable接口重写clone()方法</li>
<li>通过对象序列化</li>
</ol>
</li>
</ul>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> Test test;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    obj = <span class="keyword">super</span>.clone();</span><br><span class="line">    DeepCloneObject deepObj = (DeepCloneObject) obj;</span><br><span class="line">    deepObj.test = (Test) test.clone();</span><br><span class="line">    <span class="keyword">return</span> deepObj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="keyword">try</span> (ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">         oos.write(<span class="keyword">this</span>);</span><br><span class="line">         ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">         ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis)) &#123;</span><br><span class="line">      <span class="comment">// 反序列化</span></span><br><span class="line">      DeepCloneObject deepObj = (DeepCloneObject) ois.readObject();</span><br><span class="line">      <span class="keyword">return</span> deepObj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul>
<li><p>基本介绍：</p>
<ul>
<li>建造者模式(Builder Pattern)是一种对象构建模式。<strong>将一个复杂的构建与其表示想分离，使同样的构建过程可以创建不同的表示</strong></li>
<li>传统的建造者模式采用”建造者-指挥者”方式</li>
<li>现在的建造者模式主要用来链式调用生成不同的配置</li>
</ul>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilkTea</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addIce;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MilkTea</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...getter/setter</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MilkTea milkTea = <span class="keyword">new</span> MilkTea();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      milkTea.setName(<span class="string">"珍珠奶茶"</span>);</span><br><span class="line">      milkTea.setPrice(<span class="number">12.5</span>d);</span><br><span class="line">      milkTea.setAddIce(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      milkTea.setName(name);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">      milkTea.setPrice(price);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addIce</span><span class="params">(<span class="keyword">boolean</span> addIce)</span> </span>&#123;</span><br><span class="line">      milkTea.setAddIce(addIce);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MilkTea <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> milkTea;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MilkTea milkTea = <span class="keyword">new</span> MilkTea.Builder().setName(<span class="string">"波霸奶茶"</span>).addIce(<span class="keyword">true</span>).build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码中的应用：OkHttp、Retrofit等</p>
</li>
</ul>
<h2 id="适配器模式-待完善"><a href="#适配器模式-待完善" class="headerlink" title="适配器模式(待完善)"></a>适配器模式(待完善)</h2><ul>
<li>基本介绍：适配器模式(Adapter Pattern)是结构型模式，将某个类的接口转换成客户端期望的另一个接口表示，目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li>
<li>具体介绍：<ul>
<li>类适配器模式：<ul>
<li>基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src到dst的适配</li>
<li>注意事项和细节：<ol>
<li>Java是单继承机制，类适配器需要继承src类。这就要求dst必须是接口，有一定局限性</li>
<li>src类的方法在Adapter中都会暴露出来，增加了使用的成本</li>
<li>由于继承了src类，可根据需求重写src类的方法，使得Adapter的灵活性增强</li>
</ol>
</li>
</ul>
</li>
<li>对象适配器模式：<ul>
<li>基本介绍：<ol>
<li>基本思路和类适配器模式相同，Adapter类不继承src类，而持有src类的实例以解决兼容性的问题——即持有src类对象，实现dst类接口，完成src到dst的适配</li>
<li>根据”合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系</li>
<li>对象适配器模式是适配器模式常用的一种</li>
</ol>
</li>
<li>注意事项和细节：<ol>
<li>对象适配器和类适配器算是同一种思想，只不过实现方式不同</li>
<li>根据合成复用原则，使用组合替代继承。解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口</li>
<li>使用成本更低，更灵活</li>
</ol>
</li>
</ul>
</li>
<li>接口适配器模式：<ol>
<li>一些书籍称为缺省适配器模式</li>
<li>核心思想：当无需实现接口提供的全部方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空实现)。则该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li>
<li>适用于一个接口不使用其所有的方法的情况</li>
</ol>
</li>
</ul>
</li>
<li>源码中的应用：通过jdbc访问SQLServer(jdbc-odbc)</li>
</ul>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul>
<li><p>基本介绍：</p>
<ol>
<li>桥接模式(Bridge Pattern)是一种结构型设计模式，指将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变</li>
<li>桥接模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而保持各部分的独立性以及应对他们的功能扩展</li>
</ol>
</li>
<li><p>传统模式：</p>
<ul>
<li><p>需求1：绘三种图案：矩形、圆形和三角形</p>
</li>
<li><p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依据OOP思想,三个具体实现类一个抽象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Rectangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Circle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw Triangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需求2：在1的基础上添加颜色选择，每种颜色都需有四种不同颜色</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>复用形状，将具体形状定义为父类，每种不同颜色的图形继承其形状父类，共12个类</p>
</li>
<li><p>复用颜色，将每种颜色定义为父类，每种不同颜色的图形继承其颜色父类，共12个类</p>
</li>
<li><p>采用桥接模式，<strong>将形状与颜色分离，根据需要对颜色和形状组合</strong>，不会产生类爆炸问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"red"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Yellow Blue Green...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectange</span> <span class="keyword">implements</span> <span class="title">Shape</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span></span>&#123; <span class="keyword">this</span>.color = color; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Draw "</span> + color.getColor() + <span class="string">"Triangle~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>注意事项和细节：</p>
<ol>
<li>实现了抽象和实现部分的分离，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统</li>
<li><strong>桥接模式替代多层继承方案，可以减少子类的个数</strong>，降低系统的管理和维护成本</li>
<li>桥接模式<strong>要求正确识别出系统中两个独立变化的维度(抽象、和实现)</strong>，其使用范围有一定的局限</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</li>
</ol>
</li>
</ul>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul>
<li><p>基本介绍：</p>
<ul>
<li>装饰者模式<strong>动态地将新功能附加到对象上</strong>。在对象功能扩展方面比继承更有弹性，体现了开闭原则(OCP)</li>
<li>主要作用：<ol>
<li>增强一个类原有的功能</li>
<li>为一个类添加新的功能</li>
</ol>
</li>
</ul>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">implements</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"Milk~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceDecorator</span> <span class="keyword">implements</span> <span class="title">Condiment</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condiment origin;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IceDecorator</span><span class="params">(Condiment condiment)</span></span>&#123; origin = condiment; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCondiment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Add Ice~~~"</span>);</span><br><span class="line">    origin.getCondiment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condiment condiment = <span class="keyword">new</span> IceDecorator(<span class="keyword">new</span> Milk());</span><br><span class="line">Condiment.getCondiment();</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码中的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterInputStream.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.in = in;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><ul>
<li><p>基本介绍：组合模式(Composite Pattern)又叫部分整体模式，属于结构型模式。用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象来表示部分以及整体层次</p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFile</span> <span class="keyword">extends</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"ConcreteFile name: "</span> + name + <span class="string">" , createTime: "</span> + createTime); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;File&gt; childFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(File file)</span></span>&#123; childFiles.add(file);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Folder name: "</span> + name + <span class="string">" , createTime: "</span> + createTime);</span><br><span class="line">    <span class="keyword">for</span> (File file : childFiles) &#123; file.printInfo(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节：</p>
<ol>
<li>能简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题</li>
<li>具有较强的扩展性，当要更改组合对象时只需要调整内部的层次关系，客户端不用做出任何改动</li>
<li>方便创建出复杂的层次结构。客户端不用理会组合里的组成细节，易添加节点从而创建出复杂的树形结构</li>
<li>需要<strong>遍历组织机构或处理的对象具有树形结构时</strong>，非常适合使用组合模式</li>
<li>要求较高的抽象性，如果<strong>非叶节点和叶节点有很多差异性</strong>的话，比如很多方法和属性都不一样，不适合使用组合模式</li>
</ol>
</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ul>
<li>基本介绍：外观模式(Facade Pattern)又名门面模式。外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使得子系统更易使用<br><img src="%E5%9B%BE%E8%A7%A3%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt="图解外观模式"></li>
<li>注意事项和细节：<ol>
<li>外观模式对外屏蔽了子系统的细节，降低了客户端使用子系统的复杂性；使客户端与子系统解耦，子系统内部的模块更易维护和扩展</li>
<li>当系统需进行分层设计时可考虑使用Facade模式</li>
<li>维护一个遗留的大型系统时，可能该系统已变得非常难以维护和扩展。此时可考虑为新系统开发一个Facade类来提供遗留系统较清晰简单的接口，让新系统与Facade类交互，提高复用性</li>
<li>合理地使用外观模式可以更好地划分访问层次，不能过多或不合理地使用外观模式。使用外观模式好还是直接调用模块好取决于问题复杂度和实际情况。要以让系统有层次和利于维护为目的</li>
</ol>
</li>
</ul>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ul>
<li><p>基本介绍：</p>
<ol>
<li>通过运用共享技术有效地支持大量细粒度的对象</li>
<li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，需要时可以直接使用，避免重新创建；如果没有线程再创建</li>
<li>能够解决对象重复创建销毁的资源耗费。当系统中有大量相似对象需要缓冲池时，不需总是创建新对象，而是从缓冲池里拿</li>
<li>经典的应用场景就是池技术——String常量池、数据库连接池、缓冲池等；享元模式是池技术的重要实现方式</li>
</ol>
</li>
<li><p>内部状态和外部状态</p>
<ol>
<li>享元模式提出了两个要求：细粒度和共享对象。这就涉及到内部状态和外部状态了，即将对象的信息分为两个部分——内部状态和外部状态</li>
<li><strong>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</strong></li>
<li><strong>外部状态指对象得以依赖的一个标记，是随环境改变而改变、不可共享的状态</strong></li>
</ol>
</li>
<li><p>源码中的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试案例</span></span><br><span class="line"><span class="comment">// 第二次把127全替换为200</span></span><br><span class="line">Integer[] integers = <span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">  Integer.valueOf(<span class="number">127</span>), <span class="keyword">new</span> Integer(<span class="number">127</span>),</span><br><span class="line">  Integer.valueOf(<span class="number">127</span>), <span class="keyword">new</span> Integer(<span class="number">127</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; integers.length; j++) &#123;</span><br><span class="line">    System.out.println(String.format(<span class="string">"i%d.equals(i%d)[%s], i%d == i%d[%s]"</span>,</span><br><span class="line">      i, j, integers[i].equals(integers[j]),</span><br><span class="line">      i, j, integers[i] == integers[j]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一次结果：</span></span><br><span class="line"><span class="comment">  i0.equals(i1)[true], i0 == i1[false]</span></span><br><span class="line"><span class="comment">  i0.equals(i2)[true], i0 == i2[true]</span></span><br><span class="line"><span class="comment">  i0.equals(i3)[true], i0 == i3[false]</span></span><br><span class="line"><span class="comment">  i1.equals(i2)[true], i1 == i2[false]</span></span><br><span class="line"><span class="comment">  i1.equals(i3)[true], i1 == i3[false]</span></span><br><span class="line"><span class="comment">  i2.equals(i3)[true], i2 == i3[false]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 如果i在[low, high]区间,在cache中获取,否则返回新创建的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">      <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 内部缓存,使用享元模式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最低-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">// 最高127,但可以通过VM设置</span></span><br><span class="line">      <span class="comment">// high value may be configured by property</span></span><br><span class="line">      <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">      String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">      <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">          i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">          <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">          h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">          <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      high = h;</span><br><span class="line"></span><br><span class="line">      cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> j = low;</span><br><span class="line">      <span class="comment">// 在静态初始化时把[-128, 127]全加入缓存</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">      <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节</p>
<ol>
<li>“享”表示共享，”元”表示对象</li>
<li>系统中有大量对象且这些对象消耗大量内存并且对象的状态大部分可以外部化时，可考虑选用享元模式</li>
<li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。大多用HashMap/HashTable存储</li>
<li>大大减少了对象的创建开销，降低了程序内存的占用，提高效率</li>
<li>提高了系统的复杂度，需剥离出内部状态和外部状态。外部状态具有固化特性，不随内部状态的改变而改变。此为使用享元模式需要注意的地方</li>
<li>要注意划分内部状态和外部状态，并且通常需要一个工厂类加以控制</li>
</ol>
</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p>基本介绍：</p>
<ol>
<li>代理模式：为一个对象提供一个替身以控制对该对象的访问。通过代理对象访问目标对象的好处是——可在目标对象实现的基础上，增强额外的功能操作——即扩展目标对象的功能</li>
<li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li>
<li>代理模式有不同的形式，主要有三种：<strong>静态代理</strong>、<strong>JDK代理</strong>(又名接口代理,底层采用asm)和<strong>Cglib代理</strong>(可在内存动态地创建对象,无需实现接口,属于动态代理的范畴,底层采用asm)</li>
</ol>
</li>
<li><p>静态代理</p>
<ul>
<li><p>基本介绍：静态代理在使用时需要定义接口或父类，被代理对象(即目标对象)与代理对象一起实现相同的接口或是继承相同父类(形如装饰模式,但重在控制)</p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> <span class="keyword">implements</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITestDao</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ITestDao target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestDaoProxy</span><span class="params">(ITestDao target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Enter TestDaoProxy test()~~~"</span>);</span><br><span class="line">    target.test();</span><br><span class="line">    System.out.println(<span class="string">"Leave TestDaoProxy test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ITestDao testDao = <span class="keyword">new</span> TestDao();</span><br><span class="line">TestDaoProxy testDaoProxy = <span class="keyword">new</span> TestDaoProxy(testDao);</span><br><span class="line">testDaoProxy.test();</span><br></pre></td></tr></table></figure>
</li>
<li><p>优缺点总结：</p>
<ol>
<li>优点：在不修改目标对象功能前提下能通过代理对象对目标功能进行扩展</li>
<li>缺点：因代理对象需要与目标对象实现一样的接口，因此会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护</li>
</ol>
</li>
</ul>
</li>
<li><p>JDK代理：</p>
<ul>
<li><p>基本介绍：</p>
<ol>
<li>代理对象不需要实现接口，但目标对象要实现接口，否则不能用动态代理</li>
<li>代理对象的生成是利用JDK的API，动态地在内存中构建代理对象</li>
</ol>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testWithParam</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> <span class="keyword">implements</span> <span class="title">ITestDao</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao test()~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithParam</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"TestDao testWithParam("</span> + value + <span class="string">")~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 维护一个目标对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ClassLoader loader：指定当前目标对象使用的类加载,获取加载器的方法是固定的</span></span><br><span class="line">    <span class="comment">// Class&lt;?&gt;[] interfaces：目标对象实现的接口类型,使用泛型方式确定类型</span></span><br><span class="line">    <span class="comment">// InvocationHandler h：事件处理,执行目标对象方法时会触发事件处理器方法,会把当前目标对象方法作为参数传入</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">      target.getClass().getClassLoader(),</span><br><span class="line">      target.getClass().getInterfaces(),</span><br><span class="line">      (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Jdk Proxy start~~~"</span>);</span><br><span class="line">        <span class="comment">// 反射机制调用目标对象方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"Jdk Proxy end~~~"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给目标对象创建代理对象</span></span><br><span class="line">ITestDao proxyInstance = (ITestDao)<span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> TestDao()).getProxyInstance();</span><br><span class="line">proxyInstance.test();</span><br><span class="line">System.out.println(proxyInstance.testWithParam(<span class="string">"Hello Proxy"</span>));</span><br><span class="line">System.out.println(proxyInstance);</span><br><span class="line">System.out.println(proxyInstance.getClass());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Cglib代理</p>
<ul>
<li><p>基本介绍：</p>
<ol>
<li>静态代理和JDK代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个<strong>单独的对象且并没有实现任何的接口</strong>，这时候可使用目标对象子类来实现代理——Cglib代理</li>
<li>Cglib代理也叫作<strong>子类代理</strong>，它在内存中构建一个子类对象从而实现对目标对象功能的扩展，一些资料也将Cglib代理归属到动态代理</li>
<li>Cglib是一个强大的高性能的代码生成包，它可在运行期扩展java类与实现java接口。它广泛地被许多AOP框架使用，如Spring AOP，用于实现方法拦截</li>
<li>在AOP编程中如何选择代理模式：<ol>
<li>目标对象需要实现接口，用JDK代理</li>
<li>目标对象不需要实现接口，用Cglib代理</li>
</ol>
</li>
<li>Cglib包的底层是<strong>通过使用字节码处理框架ASM来转换字节码并生成新的类</strong></li>
</ol>
</li>
<li><p>注意事项：</p>
<ol>
<li>需要引入cglib的jar文件(Spring中集成了Cglib的使用)</li>
<li>注意代理的类不能为final，否则报错——java.lang.IllegalArgumentException</li>
<li>目标对象的方法如果为final/static方法，那么就不会被拦截——即不会执行目标对象额外的业务方法</li>
</ol>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"TestDao test()~~~"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 维护一个目标对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123; <span class="keyword">this</span>.target = target; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建一个工具类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 2、设置父类</span></span><br><span class="line">    enhancer.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 3、设置回调函数</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 4、创建子类对象即代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写intercept方法,会调用目标对象的方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Cglib Proxy start~~~"</span>);</span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">"Cglib Proxy end~~~"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestDao proxyInstance = (TestDao) <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> TestDao()).getProxyInstance();</span><br><span class="line">proxyInstance.test();</span><br><span class="line">System.out.println(proxyInstance);</span><br><span class="line">System.out.println(proxyInstance.getClass());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>几种常见的代理模式(常见变体)</p>
<ol>
<li>缓存代理：如当请求图片文件等资源时，先到缓存代理取，如果取不到资源再到公网或者数据库取，然后缓存</li>
<li>远程代理：通过远程对象的本地代表可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li>
<li>同步代理：主要使用在多线程编程中完成多线程间同步工作</li>
</ol>
</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul>
<li>基本介绍：<ol>
<li>模板方法模式(Template Method Pattern)又叫模板模式，属于行为型模式。在一个抽象类公开定义执行方法的模板。子类可按需重写方法实现，但调用将以抽象类中定义的方式进行</li>
<li>模板方法模式定义一个操作中算法的骨架，而将一些步骤延迟到子类，这使得子类可以不改变一个算法的结构就可以重定义算法的某些特定步骤</li>
</ol>
</li>
<li>注意事项和细节：<ol>
<li>基本思想：算法只存在于一个地方也就是在父类中，容易修改。需要修改算法时只需修改父类的模板方法或已经实现的某些步骤，子类就会继承这些修改</li>
<li>实现了代码复用的最大化。父类的模板方法和已实现的某些步骤会被子类继承直接使用</li>
<li>既统一了算法也提供了很大的灵活性。父类的模板方法确保算法结构保持不变，同时由子类提供部分步骤的实现</li>
<li>模式的不足之处：每一个不同的实现都需要一个子类实现，这会导致类的个数增加，使得系统更加庞大</li>
<li>不希望子类覆写的方法(模版方法)用final修饰；要求子类必须覆写的方法用abstract修饰</li>
<li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤且这一系列的步骤基本相同，但其个别步骤在实现时可能不同。这种情况下通常考虑用模板方法模式来处理</li>
</ol>
</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul>
<li><p>基本介绍：命令模式(Command Pattern)将一个请求封装为一个对象，可参数化请求对象，支持对请求排队、记录和撤销的操作</p>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOpenCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Light light;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightOpenCommand</span><span class="params">(Light light)</span> </span>&#123; <span class="keyword">this</span>.light = light;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn on~~~"</span>);</span><br><span class="line">    light.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn off~~~"</span>);</span><br><span class="line">    light.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightCloseCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Light light;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LightCloseCommand</span><span class="params">(Light light)</span> </span>&#123; <span class="keyword">this</span>.light = light; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn off~~~"</span>);</span><br><span class="line">    light.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor light turn on~~~"</span>);</span><br><span class="line">    light.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelevisionOpenCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Television television;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TelevisionOpenCommand</span><span class="params">(Television television)</span> </span>&#123; <span class="keyword">this</span>.television = television; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn on~~~"</span>);</span><br><span class="line">    television.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn off~~~"</span>);</span><br><span class="line">    television.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelevisionCloseCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  Television television;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TelevisionCloseCommand</span><span class="params">(Television television)</span> </span>&#123; <span class="keyword">this</span>.television = television; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn off~~~"</span>);</span><br><span class="line">    television.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Monitor television turn on~~~"</span>);</span><br><span class="line">    television.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">  List&lt;ICommand&gt; iCommands;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MicroCommand</span><span class="params">(List&lt;ICommand&gt; iCommands)</span> </span>&#123; <span class="keyword">this</span>.iCommands = iCommands;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MicroCommand execute~~~"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ICommand iCommand : iCommands) &#123; iCommand.execute(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MicroCommand undo~~~"</span>);</span><br><span class="line">    <span class="keyword">for</span> (ICommand iCommand : iCommands) &#123; iCommand.undo(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light light = <span class="keyword">new</span> Light();</span><br><span class="line">ICommand lightOpenCommand = <span class="keyword">new</span> LightOpenCommand(light);</span><br><span class="line">ICommand lightCloseCommand = <span class="keyword">new</span> LightCloseCommand(light);</span><br><span class="line"></span><br><span class="line">Television television = <span class="keyword">new</span> Television();</span><br><span class="line">ICommand televisionOpenCommand = <span class="keyword">new</span> TelevisionOpenCommand(television);</span><br><span class="line">ICommand televisionCloseCommand = <span class="keyword">new</span> TelevisionCloseCommand(television);</span><br><span class="line"></span><br><span class="line">ICommand microCommand = <span class="keyword">new</span> MicroCommand(Arrays.asList(lightCloseCommand, lightOpenCommand, televisionOpenCommand, televisionCloseCommand));</span><br><span class="line"></span><br><span class="line">lightOpenCommand.execute();</span><br><span class="line">lightOpenCommand.undo();</span><br><span class="line">lightCloseCommand.execute();</span><br><span class="line">lightCloseCommand.undo();</span><br><span class="line"></span><br><span class="line">televisionOpenCommand.execute();</span><br><span class="line">televisionOpenCommand.undo();</span><br><span class="line">televisionCloseCommand.execute();</span><br><span class="line">televisionCloseCommand.undo();</span><br><span class="line"></span><br><span class="line">microCommand.execute();</span><br><span class="line">microCommand.undo();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节：</p>
<ol>
<li>容易设计一个命令队列。只要把命令对象放到列队就可以多线程地执行命令</li>
<li>容易实现请求的撤销和重做</li>
<li>可能导致某些系统有过多的具体命令类，增加了系统的复杂度</li>
<li><strong>空命令也是一种设计模式，它省去了判空的操作</strong></li>
<li>经典应用场景：界面的一个按钮都是一条命令、模拟CMD(DOS命令)、订单的撤销/恢复、触发-反馈机制</li>
</ol>
</li>
</ul>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><ul>
<li><p>基本介绍：</p>
<ol>
<li><strong>访问者模式(Visitor Pattern)封装一些作用于某种数据结构各元素的操作，使得可在不改变数据结构的前提下定义作用于这些元素的新操作</strong></li>
<li>核心思想：<strong>将数据结构与数据操作分离</strong>，解决数据结构和操作耦合性问题</li>
<li>基本工作原理：在被访问的类中加一个对外提供访问的接口(accept)</li>
<li>主要应用场景：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需避免这些操作”污染”这些对象的类</li>
</ol>
</li>
<li><p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chip</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Visitor visitor)</span></span>&#123; visitor.accept(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMD</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Design"</span>);</span><br><span class="line">    chip.setValue(<span class="number">4000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSMC</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Original Entrusted Manufacture"</span>);</span><br><span class="line">    chip.setValue(<span class="number">4500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TMALL</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Chip chip)</span> </span>&#123;</span><br><span class="line">    chip.setName(<span class="string">"Ryzen 9 5950X Sell"</span>);</span><br><span class="line">    chip.setValue(<span class="number">5500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Chip chip = <span class="keyword">new</span> Chip();</span><br><span class="line">List&lt;Visitor&gt; capitalists = Arrays.asList(<span class="keyword">new</span> AMD(), <span class="keyword">new</span> TSMC(), <span class="keyword">new</span> TMALL());</span><br><span class="line"><span class="keyword">for</span> (Visitor capitalist : capitalists) &#123;</span><br><span class="line">  chip.visit(capitalist);</span><br><span class="line">  logger.info(<span class="string">"Visit By &#123;&#125; , Chip -&gt; &#123;&#125; , &#123;&#125;"</span>, capitalist.getClass().getSimpleName(), chip.getName(), chip.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项和细节：</p>
<ul>
<li>优点：<ol>
<li>符合单一职责原则、使程序具有优秀的扩展性、灵活性非常高</li>
<li>可对功能进行统一，可应用于报表、UI、拦截器与过滤器等场景，适用于数据结构相对稳定的系统</li>
</ol>
</li>
<li>缺点<ol>
<li>具体元素对访问者公布细节，即访问者关注了其他类的内部细节，违背了迪米特法则且具体元素变更比较困难</li>
<li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li>
</ol>
</li>
<li>总结：如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就比较合适</li>
</ul>
</li>
</ul>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><ul>
<li>基本介绍：迭代器模式(Iterator Pattern)属于行为型模式，它<strong>提供一种方法访问一个容器对象中各个元素，而又无需暴露该对象的内部细节</strong></li>
<li>源码中的应用：JDK(Collection.class, Iterator.class)</li>
<li>注意事项和细节：<ul>
<li>优点<ol>
<li>提供一个统一的方法遍历对象</li>
<li>隐藏了对象内部细节</li>
<li>隐藏了一种设计思想：一个类应只有一个引起变化的原因(单一责任原则)。剥离迭代器，<strong>把管理对象集合和遍历对象集合的责任分开</strong></li>
<li>当要展示一组相似对象或遍历一组相同对象时，适合使用迭代器模式</li>
</ol>
</li>
<li>缺点：当遍历细节不同时，会生成多个具体迭代器类</li>
</ul>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li>基本介绍：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li>
<li>源码中的应用：JDK中的Observable和Observer类</li>
</ul>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><ul>
<li>基本介绍：中介者模式(Mediator Pattern)属于行为型模式，<strong>定义一个中介对象来封装一系列对象之间的交互</strong>。使原来有对象的耦合松散，且可以独立地改变它们之间的交互</li>
<li>注意事项和细节：<ol>
<li>多个类相互耦合会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦</li>
<li>减少类间依赖，降低了耦合，符合迪米特原则</li>
<li>中介者承担了较多的责任，需要处理所有类之间的协调工作，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，中介者对象本身会变得过于复杂</li>
</ol>
</li>
</ul>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ul>
<li>基本介绍：备忘录模式(Memento Pattern)属于行为型模式，在<strong>不破坏封装性的条件下，通过备忘录对象存储另一个对象内部状态的快照，在将来合适时把这个对象还原到存储时的状态</strong></li>
<li>注意事项和细节：<ol>
<li>为用户提供了一种可以恢复状态的机制，可使用户能比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户无需关心状态的保存细节</li>
<li>消耗资源：如果类的成员变量过多，势必会占用比较大的资源，且每一次保存都会消耗一定的内存</li>
<li>适用的应用场景：<ol>
<li>打游戏时的存档</li>
<li>Windows里的Ctrl + z</li>
<li>浏览器中的后退</li>
<li>数据库的事务管理</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><ul>
<li>基本介绍：<ol>
<li>在编译原理中，一个表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里词法分析器和语法分析器都可以看做是解释器</li>
<li>解释器模式(Interpreter Pattern)：<strong>给定一门语言(表达式)，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子(表达式)</strong></li>
<li>将不可拆分的最小单元称之为终结表达式，可被拆分的表达式称之为非终结表达式</li>
</ol>
</li>
<li>注意事项和细节：<ol>
<li>应用场景：编译器、运算表达式计算、正则表达式、机器人等</li>
<li>可能带来的问题：解释器模式会引起类膨胀；解释器模式通常采用递归，这将会导致调试复杂、运行效率降低</li>
</ol>
</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ul>
<li>基本介绍：<ol>
<li>状态模式(State Pattern)主要用来解决对象在多种状态转换时需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</li>
<li>当一个<strong>对象的内在状态改变时允许改变其行为</strong>，这个对象看起来像是改变了其类</li>
</ol>
</li>
<li>注意事项和细节：<ol>
<li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li>
<li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错</li>
<li>符合”开闭原则”，容易增删状态</li>
<li>会产生很多类。每个状态都需要一个对应的类，当状态过多时会产生很多类，加大维护难度</li>
<li>应用场景：当一个事件或者对象有多种状态，状态之间会相互转换，对不同的状态要求有不同的行为时可考虑状态模式</li>
</ol>
</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul>
<li>基本介绍：定义了一系列算法，并将每一个算法封装起来，且使它们可以相互替换。策略模式让算法独立于使用它的客户而独立变化。简单来说，即<strong>殊途同归</strong>——当我们做同一件事有多种方式时可将每种方法封装起来，在不同的场景选择不同的策略，调用不同的方法</li>
<li>源码中的应用：图片加载框架(Glide,picaso等)缓存策略</li>
<li>注意事项和细节：<ol>
<li>关键是分析项目中变化部分与不变部分</li>
<li>注意多用组合/聚合、少用继承</li>
<li>体现了OCP原则，客户端增加行为不用修改原有代码，只要添加一种策略(或者行为)即可，避免使用多重if-else</li>
<li>每添加一个策略就要增加一个类，当策略过多时会导致类数目庞大</li>
<li>更好的实践：与工厂模式结合，将不同的策略对象封装到工厂类中，只需传递不同的策略类型从工厂中获取对应的策略对象</li>
</ol>
</li>
</ul>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><ul>
<li>基本介绍：<ol>
<li>职责链模式(Chain of Responsibility Pattern)又叫责任链模式，属于行为型模式。它为请求创建了一个处理者对象的链，对请求的发送者和接收者进行解耦</li>
<li>通常每个处理者都包含对另一个处理者的引用。如果一个处理者不能处理该请求，那么它会把该请求传给下一个处理者，依此类推</li>
</ol>
</li>
<li>源码中的应用：javax包下的FilterChain、SpringMVC包装的FilterChain</li>
<li>注意事项和细节：<ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>责任分担，每个处理者只处理自身该处理的任务，其余交由下一个处理者完成或提前返回</li>
<li>性能会受到影响，特别是在链比较长的时候。因此需控制链中最大节点数量</li>
<li>采用了类似递归的方式，调试不方便</li>
</ol>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://sobxiong.github.io/2020/10/09/BasicSkill/DesignPattern/>https://sobxiong.github.io/2020/10/09/BasicSkill/DesignPattern/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-11-07T16:41:41+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年11月7日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/BasicSkill/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>BasicSkill</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sobxiong.github.io/2020/10/09/BasicSkill/DesignPattern/&title=设计模式 - SOBXiong的博客&summary=内容
七大原则
UML类图
设计模式概述
单例模式
工厂模式
原型模式
建造者模式
适配器模式
桥接模式
装饰者模式
组合模式
外观模式
享元模式
代理模式
模板方法模式
命令模式
访问者模式
迭代器模式
观察者模式
中介者模式
备忘录模式
解释器模式
状态模式
策略模式
职责链模式
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sobxiong.github.io/2020/10/09/BasicSkill/DesignPattern/&title=设计模式 - SOBXiong的博客&summary=内容
七大原则
UML类图
设计模式概述
单例模式
工厂模式
原型模式
建造者模式
适配器模式
桥接模式
装饰者模式
组合模式
外观模式
享元模式
代理模式
模板方法模式
命令模式
访问者模式
迭代器模式
观察者模式
中介者模式
备忘录模式
解释器模式
状态模式
策略模式
职责链模式
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sobxiong.github.io/2020/10/09/BasicSkill/DesignPattern/&title=设计模式 - SOBXiong的博客&summary=内容
七大原则
UML类图
设计模式概述
单例模式
工厂模式
原型模式
建造者模式
适配器模式
桥接模式
装饰者模式
组合模式
外观模式
享元模式
代理模式
模板方法模式
命令模式
访问者模式
迭代器模式
观察者模式
中介者模式
备忘录模式
解释器模式
状态模式
策略模式
职责链模式
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/10/29/ProgrammingLanguage/Java/Java%E6%97%A5%E5%BF%97/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Java日志</p>
                <p class='content'>内容
日志介绍
日志实现
日志门面
SpringBoot中的日志



日志介绍
日志文件是用于记录系统操作事件的文件集合，可分为事件日志和消息日志。具有处理历史数据、诊断问题的追踪以及理解系统...</p>
              </a>
            
            
              <a class='next' href='/2020/10/09/BasicSkill/Docker/'>
                <p class='title'>Docker<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>内容
Docker简介
Docker安装
Docker常用命令
Docker镜像
Docker容器数据卷
Dockerfile
Docker安装步骤
Docker镜像发布



Docker简介...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '设计模式',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七大原则"><span class="toc-text">七大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML类图"><span class="toc-text">UML类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式概述"><span class="toc-text">设计模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建造者模式"><span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适配器模式-待完善"><span class="toc-text">适配器模式(待完善)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桥接模式"><span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰者模式"><span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合模式"><span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外观模式"><span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#享元模式"><span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理模式"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板方法模式"><span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令模式"><span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问者模式"><span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器模式"><span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#观察者模式"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中介者模式"><span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备忘录模式"><span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器模式"><span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态模式"><span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#策略模式"><span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#职责链模式"><span class="toc-text">职责链模式</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:1942991710@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/SOBXiong"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="http://xiongjc.top" target="_blank" rel="noopener">Copyright © 2017-2020 SOBXiong</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
