<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>Docker - SOBXiong的博客</title>
  
    <meta name="keywords" content="BasicSkill">
  
  
    <meta name="description" content="内容
Docker简介
Docker安装
Docker常用命令
Docker镜像
Docker容器数据卷
Dockerfile
Docker安装步骤
Docker镜像发布
">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png'></i>
          
          
            SOBXiong
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/10/09/BasicSkill/Docker/">
      Docker
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="http://xiongjc.top" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/hdImg_f757fa7e0fd65077ce52d251fc7a01d815860762755.jpg">
    <p>SOBXiong</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年10月9日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><a href="#Docker简介">Docker简介</a></li>
<li><a href="#Docker安装">Docker安装</a></li>
<li><a href="#Docker常用命令">Docker常用命令</a></li>
<li><a href="#Docker镜像">Docker镜像</a></li>
<li><a href="#Docker容器数据卷">Docker容器数据卷</a></li>
<li><a href="#Dockerfile">Dockerfile</a></li>
<li><a href="#Docker安装步骤">Docker安装步骤</a></li>
<li><a href="#Docker镜像发布">Docker镜像发布</a></li>
</ul>
<a id="more"></a>

<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul>
<li>Docker是什么：<ul>
<li>Docker出现背景：<ol>
<li>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。开发/运维之间的协作需要我们关心很多东西，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</li>
<li>Docker之所以发展如此迅速，就是因为它对此给出了一个标准化的解决方案</li>
<li>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。能不能从根本上解决问题，<strong>软件可以带环境安装？</strong>也就是说，安装的时候，把原始环境一模一样地复制过来。利用Docker可以消除协作编码时”在我的机器上可正常工作”的问题</li>
<li>之前在服务器配置一个应用的运行环境，要安装各种软件，有时还不能跨平台，移植应用也非常麻烦</li>
<li>传统上认为，软件编码开发和测试环节结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等。为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件。开发需要清楚地告诉运维部署团队用的全部配置文件和所有软件环境，即便如此仍然会发生部署失败的状况。<strong>Docker镜像的设计打破过去”程序即应用”的观念。透过镜像(images)将作业系统核心除外地运行应用程序所需要的系统环境，由下而上打包，达到应用程序跨平台间的无缝接轨运行</strong></li>
</ol>
</li>
<li>Docker理念：<ol>
<li>Docker是基于Go语言实现的云开源项目</li>
<li>Docker的主要目标是”Build, Ship and Run Any App, Anywhere”。即通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP(可以是一个WEB应用或数据库应用等)及其运行环境能够做到”<strong>一次封装，到处运行</strong>“<br> <img src="Docker%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87.png" alt="Docker主要目标"></li>
<li>Linux容器技术的出现就解决了这样一个问题，而Docker就是在它的基础上发展过来的。将应用运行在Docker容器上面，Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></li>
</ol>
</li>
<li>总结：解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术</li>
</ul>
</li>
<li>Docker与传统虚拟机技术<ul>
<li>虚拟机技术：<ul>
<li>虚拟机(virtual machine)是带环境安装的一种解决方案。</li>
<li>可以在一种操作系统里面运行另一种操作系统(Windows系统里面运行Linux系统)，应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样。而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美地运行了另一套系统，能够使应用程序、操作系统和硬件三者之间的逻辑不变<br><img src="%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚拟机架构示意图"></li>
<li>虚拟机的缺点：<ol>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ol>
</li>
</ul>
</li>
<li>容器虚拟化技术：<ul>
<li>由于前面虚拟机存在这些缺点，Linux发展出了另一种虚拟化技术——Linux容器(Linux Containers,缩写为LXC)</li>
<li>Linux容器并不模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行<br><img src="Docker%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker架构示意图"></li>
<li>Docker和传统虚拟化方式的不同之处：<ol>
<li>传统虚拟机技术是虚拟出一套硬件后在其上运行一个完整操作系统，再在该系统上再运行所需的应用进程</li>
<li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</li>
<li>每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Docker能干嘛：<ul>
<li>开发/运维(DevOps,一次构建、随处运行)：<ol>
<li>一次构建、随处运行：传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间</li>
<li>更便捷的升级和扩缩容：随着微服务架构和Docker的发展，大量的应用会通过微服务方式构建。应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块”积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级</li>
<li>更简单的系统运维：应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复</li>
<li>更高效的计算资源利用：Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率</li>
</ol>
</li>
</ul>
</li>
<li>Docker去哪下：<ul>
<li>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></li>
<li>镜像仓库：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></li>
</ul>
</li>
</ul>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ul>
<li><p>前提：Docker只能运行在CentOS-6.5或更高的版本的CentOS上，要求系统为64位、系统内核版本为2.6.32-431或者更高版本(以CentOS为例)</p>
</li>
<li><p>Docker的基本组成：</p>
<ol>
<li>镜像(image)：Docker镜像就是一个<strong>只读</strong>的模板。镜像可以用来创建容器，<strong>一个镜像可以创建多个容器</strong></li>
<li>容器(container)：<ul>
<li>Docker利用容器独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例</strong></li>
<li>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<strong>可以把容器看做是一个简易版的Linux环境</strong>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序</li>
<li>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的</li>
</ul>
</li>
<li>仓库(repository)：<ul>
<li><strong>仓库是集中存放镜像文件的场所</strong></li>
<li>仓库(Repository)和仓库注册服务器(Registry)是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)</li>
<li>仓库分为公开仓库(Public)和私有仓库(Private)两种形式</li>
<li>最大的公开仓库是Docker Hub，里面存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等</li>
</ul>
</li>
<li>总结：<ul>
<li>区分并理解仓储/镜像/容器这些概念</li>
<li>Docker本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件可以生成多个同时运行的容器实例</li>
<li>image文件生成的容器实例本身也是一个文件，称为镜像文件</li>
<li>一个容器运行一种服务，当我们需要的时候就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li>
<li>仓储是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以<br><img src="Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Docker架构图"></li>
</ul>
</li>
</ol>
</li>
<li><p>安装步骤(CentOS7)</p>
<ul>
<li><p>参考网址：<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p>
</li>
<li><p>具体步骤：</p>
<ol>
<li><p>卸载老版本依赖</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">  docker-client \</span><br><span class="line">  docker-client-latest \</span><br><span class="line">  docker-common \</span><br><span class="line">  docker-latest \</span><br><span class="line">  docker-latest-logrotate \</span><br><span class="line">  docker-logrotate \</span><br><span class="line">  docker-engine</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置yum仓库(repository)</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">  --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载最新版本Docker(ce版本——免费,ee版本——商业收费)</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Docker服务</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置docker服务开机自启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载Docker：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭docker服务</span></span><br><span class="line">sudo systemctl stop docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除docker包和依赖</span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除docker lib</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>测试docker：docker version</p>
</li>
<li><p>配置docker阿里云镜像加速：控制台 -&gt; 容器镜像服务 -&gt; 镜像加速器 -&gt; 查看操作文档</p>
</li>
<li><p>永远的hello world：</p>
<ul>
<li>运行：docker run hello-world</li>
<li>run hello-world的流程：<br><img src="hello-world%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="hello-world运行流程"></li>
</ul>
</li>
</ul>
</li>
<li><p>底层原理</p>
<ul>
<li>Docker是怎么工作的：Docker是一个CS结构的系统，Docker守护进程运行在主机上，通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器是一个运行时环境，就是”🐳背上的集装箱”<br><img src="Docker%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker工作示意图"></li>
<li>为什么Docker比虚拟机(VM)快：<ol>
<li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker会在效率上有明显优势</li>
<li>docker利用的是宿主机的内核，而不需要Guest OS。因此当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。从而避免引寻、加载操作系统内核等比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，整个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统、省略了新建过程，新建一个docker容器只需要几秒钟</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><ul>
<li><p>帮助命令：</p>
<ol>
<li>docker version</li>
<li>docker info</li>
<li>docker –help</li>
</ol>
</li>
<li><p>镜像命令：</p>
<ol>
<li>docker images [Options]<ul>
<li>介绍：列出本地主机上的镜像</li>
<li>显示参数介绍：<ol>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小<br>同一仓库源可以有多个TAG，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像<br>如果不指定一个镜像的版本标签，docker将默认使用centos:latest镜像(系统为CentOS)</li>
</ol>
</li>
<li>常用Options说明：<ol>
<li>-a：列出本地所有的镜像(含中间映像层)</li>
<li>-q：只显示镜像id</li>
<li>–digests：显示镜像的摘要信息</li>
<li>–no-trunc：显示完整的镜像信息</li>
</ol>
</li>
</ul>
</li>
<li>docker search [Options] 镜像名<ul>
<li>默认搜索源：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li>
<li>常用Options说明：<ol>
<li>–no-trunc：显示完整的镜像描述</li>
<li>-s：列出收藏数不小于指定值的镜像</li>
<li>–automated：只列出automated build类型的镜像</li>
</ol>
</li>
</ul>
</li>
<li>docker pull 镜像名[:标签]：下载指定镜像</li>
<li>docker rmi：删除镜像<ul>
<li>删除单个：docker rmi -f 镜像id/镜像名[:标签]</li>
<li>删除多个：docker rmi -f 镜像名1[:标签] 镜像名2[:标签]</li>
<li>删除全部：docker rmi -f $(docker images -qa)</li>
</ul>
</li>
</ol>
</li>
<li><p>容器命令：</p>
<ol>
<li><p>新建并启动容器(有镜像才能创建容器)：docker run [Options] image [Command] [args…]</p>
<ul>
<li><p>常用Options说明：</p>
<ol>
<li>–name dockerName：为容器指定一个名称</li>
<li>-d：后台运行容器，并返回容器ID(也即启动守护式容器)</li>
<li><strong>-i：以交互模式运行容器，通常与-t同时使用</strong></li>
<li><strong>-t：为容器重新分配一个伪输入终端，通常与-i同时使用</strong></li>
<li>-P: 随机端口映射</li>
<li>-p: 指定端口映射，有以下四种格式:<ol>
<li>ip:hostPort:containerPort</li>
<li>ip::containerPort</li>
<li><strong>hostPort:containerPort</strong></li>
<li>containerPort</li>
</ol>
</li>
</ol>
</li>
<li><p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</span></span><br><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：</p>
<ul>
<li>操作：docker run -d centos</li>
<li>现象：然后使用docker ps -a进行查看运行的容器，会发现容器已经退出</li>
<li>原因：Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令(比如运行top、tail)，就会自动退出。这是docker的机制问题，比如web容器。以nginx为例，正常情况下，我们配置启动服务只需要启动响应service即可，例如service nginx start。但是这样做，nginx以后台进程模式运行，就导致docker前台没有运行的应用。这样的容器后台启动后，会立即自杀。因为它觉得无事可做。因此最佳的解决方案是将你要运行的程序以前台进程的形式运行</li>
</ul>
</li>
</ul>
</li>
<li><p>列出当前所有正在运行的容器：docker ps [OPTIONS]<br> 常用Options说明：</p>
<ol>
<li>-a：列出当前所有<strong>正在运行、历史上运行过</strong>的容器</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li><strong>-q：静默模式，只显示容器编号</strong></li>
<li>–no-trunc：不截断输出</li>
</ol>
</li>
<li><p>退出容器(两种方式)</p>
<ol>
<li>容器停止退出：exit</li>
<li>容器不停止退出：ctrl+P+Q</li>
</ol>
</li>
<li><p>启动容器：docker start 容器id/容器名</p>
</li>
<li><p>停止容器：docker stop 容器id/容器名</p>
</li>
<li><p>强制停止容器：docker kill 容器id/容器名</p>
</li>
<li><p>删除已停止的容器：</p>
<ol>
<li>删除单个容器：docker rm 容器id</li>
<li>一次性删除多个容器(-f——force强制,关闭已启动的)：<ol>
<li>docker rm -f 容器id1 容器id2 …</li>
<li>docker rm -f $(docker ps -a -q)</li>
<li>docker ps -a -q | xargs docker rm</li>
</ol>
</li>
</ol>
</li>
<li><p>查看容器日志：docker logs -f -t –tail 条数 容器id<br> 参数说明：</p>
<ol>
<li>-t：加入时间戳</li>
<li>-f：跟随最新的日志打印</li>
<li>–tail num：显示最后多少条</li>
</ol>
</li>
<li><p>查看容器内运行的进程：docker top 容器id</p>
</li>
<li><p>查看容器内部细节(资源、配置)：docker inspect 容器id</p>
</li>
<li><p>进入正在运行的容器并以命令行交互：</p>
<ul>
<li>两种方式：<ol>
<li>docker exec -it 容器id /bin/bash</li>
<li>docker attach 容器id</li>
</ol>
</li>
<li>两种方式区别：<ol>
<li>attach：直接进入容器启动命令的终端，不会启动新的进程</li>
<li>exec：是在容器中打开新的终端，并且可以启动新的进程</li>
</ol>
</li>
</ul>
</li>
<li><p>从容器内拷贝文件到主机上：docker cp 容器id:容器文件路径 主机文件路径</p>
</li>
<li><p>命令一览：<br><img src="Docker%E5%91%BD%E4%BB%A4%E7%AE%80%E5%9B%BE.png" alt="Docker命令简图"></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>attach</td>
<td>Attach to a running container(当前shell下attach连接指定运行镜像)</td>
</tr>
<tr>
<td>build</td>
<td>Build an image from a Dockerfile(通过Dockerfile定制镜像)</td>
</tr>
<tr>
<td>commit</td>
<td>Create a new image from a container changes(提交当前容器为新的镜像)</td>
</tr>
<tr>
<td>cp</td>
<td>Copy files/folders from the containers filesystem to the host path(从容器中拷贝指定文件或者目录到宿主机中)</td>
</tr>
<tr>
<td>create</td>
<td>Create a new container(创建一个新的容器,同run,但不启动容器)</td>
</tr>
<tr>
<td>diff</td>
<td>Inspect changes on a container’s filesystem(查看docker容器变化)</td>
</tr>
<tr>
<td>events</td>
<td>Get real time events from the server(从docker服务获取容器实时事件)</td>
</tr>
<tr>
<td>exec</td>
<td>Run a command in an existing container(在已存在的容器上运行命令)</td>
</tr>
<tr>
<td>export</td>
<td>Stream the contents of a container as a tar archive(导出容器的内容流作为一个tar归档文件,对应import)</td>
</tr>
<tr>
<td>history</td>
<td>Show the history of an image(展示一个镜像形成历史)</td>
</tr>
<tr>
<td>images</td>
<td>List images(列出系统当前镜像)</td>
</tr>
<tr>
<td>import</td>
<td>Create a new filesystem image from the contents of a tarball(从tar包中的内容创建一个新的文件系统映像,对应export)</td>
</tr>
<tr>
<td>info</td>
<td>Display system-wide information(显示系统相关信息)</td>
</tr>
<tr>
<td>inspect</td>
<td>Return low-level information on a container(查看容器详细信息)</td>
</tr>
<tr>
<td>kill</td>
<td>Kill a running container(kill指定docker容器)</td>
</tr>
<tr>
<td>load</td>
<td>Load an image from a tar archive(从一个tar包中加载一个镜像,对应save)</td>
</tr>
<tr>
<td>login</td>
<td>Register or Login to the docker registry server(注册或者登陆一个 docker源服务器)</td>
</tr>
<tr>
<td>logout</td>
<td>Log out from a Docker registry server(从当前Docker registry退出)</td>
</tr>
<tr>
<td>logs</td>
<td>Fetch the logs of a container(输出当前容器日志信息)</td>
</tr>
<tr>
<td>port</td>
<td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT(查看映射端口对应的容器内部源端口)</td>
</tr>
<tr>
<td>pause</td>
<td>Pause all processes within a container(暂停容器)</td>
</tr>
<tr>
<td>ps</td>
<td>List containers(列出容器列表)</td>
</tr>
<tr>
<td>pull</td>
<td>Pull an image or a repository from the docker registry server(从docker镜像源服务器拉取指定镜像或者库镜像)</td>
</tr>
<tr>
<td>push</td>
<td>Push an image or a repository to the docker registry server(推送指定镜像或者库镜像至docker源服务器)</td>
</tr>
<tr>
<td>restart</td>
<td>Restart a running container(重启运行的容器)</td>
</tr>
<tr>
<td>rm</td>
<td>Remove one or more containers(移除一个或者多个容器)</td>
</tr>
<tr>
<td>rmi</td>
<td>Remove one or more images(移除一个或多个镜像——无容器使用该镜像才可删除,否则需删除相关容器才可继续或-f强制删除)</td>
</tr>
<tr>
<td>run</td>
<td>Run a command in a new container(创建一个新的容器并运行一个命令)</td>
</tr>
<tr>
<td>save</td>
<td>Save an image to a tar archive(保存一个镜像为一个tar包,对应load)</td>
</tr>
<tr>
<td>search</td>
<td>Search for an image on the Docker Hub(在docker hub中搜索镜像)</td>
</tr>
<tr>
<td>start</td>
<td>Start a stopped containers(启动容器)</td>
</tr>
<tr>
<td>stop</td>
<td>Stop a running containers(停止容器)</td>
</tr>
<tr>
<td>tag</td>
<td>Tag an image into a repository(给源中镜像打标签)</td>
</tr>
<tr>
<td>top</td>
<td>Lookup the running processes of a container(查看容器中运行的进程信息)</td>
</tr>
<tr>
<td>unpause</td>
<td>Unpause a paused container(取消暂停容器)</td>
</tr>
<tr>
<td>version</td>
<td>Show the docker version information(查看docker版本号)</td>
</tr>
<tr>
<td>wait</td>
<td>Block until a container stops, then print its exit code(截取容器停止时的退出状态值)</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><ul>
<li>是什么：镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件</strong>。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件<ul>
<li>UnionFS(联合文件系统,类比花卷)：<ul>
<li>介绍：Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统。<strong>它支持对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像</li>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统。联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
</ul>
</li>
<li>Docker镜像加载原理：<ul>
<li>docker的镜像实际上由一层一层的文件系统(UnionFS)组成</li>
<li>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel。Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是bootfs</strong>。这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</li>
<li>rootfs(root file system)在bootfs之上。包含典型Linux系统中的/dev、/proc、/bin和/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等</li>
</ul>
</li>
<li>为什么Docker中CentOS镜像出奇的小？(平时安装进虚拟机的CentOS都是好几个G,docker里才200M)<br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。因为底层直接用Host的kernel，自己只需要提供rootfs就行。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs</li>
<li>Docker镜像采用分层结构的理由：最大好处就是共享资源。比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享</li>
</ul>
</li>
<li>特点：Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作”容器层”，”容器层”之下的都叫”镜像层”</li>
<li>commit命令补充<ul>
<li>命令介绍：提交容器副本使之成为一个新的镜像</li>
<li>命令格式：docker commit -m=”提交的描述信息” -a=”作者” 容器id 要创建的目标镜像名:[标签]</li>
</ul>
</li>
</ul>
<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><ul>
<li><p>是什么：Docker的理念是将软件与运行的环境打包形成容器运行，运行可以伴随着容器。但对数据的要求希望是持久化的、容器之间希望有可能共享数据。Docker容器产生的数据如果不通过docker commit生成新的镜像使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。为了能保存数据在docker中我们使用卷。卷类似Redis里面的rdb和aof文件</p>
</li>
<li><p>能干嘛：</p>
<ul>
<li>容器的持久化</li>
<li>容器间继承+共享数据</li>
<li>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，它完全独立于容器的生存周期，Docker不会在容器删除时删除其挂载的数据卷</li>
<li>特点：<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
</li>
</ul>
</li>
<li><p>数据卷添加</p>
<ol>
<li><p>直接命令添加：docker run -it -v /主机目录路径:/容器目录路径 镜像名</p>
<ul>
<li>查看是否成功：docker inspect 容器id</li>
<li>容器停止退出后，主机修改后数据依然同步</li>
<li>设置只读(read only,容器)：docker run -it -v /主机目录路径:/容器目录路径:ro 镜像名</li>
</ul>
</li>
<li><p>Dockerfile添加：</p>
<ul>
<li><p>在新建Dockerfile添加volume指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 说明: 处于可移植和分享的考虑</span></span><br><span class="line"><span class="comment"># 使用-v 主机目录:容器目录这种方式不能直接在Dockerfile中实现</span></span><br><span class="line"><span class="comment"># 宿主机目录是依赖于特定宿主机的,并不能够保证在所有的宿主机上都存设定的特定目录</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer"</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完整Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>, <span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Build Docker with Volume succeed~~~"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完整流程：</p>
<ol>
<li>编写上述Dockerfile</li>
<li>build生成镜像：docker build -f Dockerfile -t sobxiong/centos .</li>
<li>run运行容器：docker run -it sobxiong/centos /bin/bash</li>
<li>查看目录是否存在，测试创建文件并写入内容</li>
<li>查看宿主机对应目录：docker inspect 容器id</li>
<li>前往对应目录查看内容</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>数据卷容器</p>
<ul>
<li>是什么：命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享。挂载数据卷的容器称为数据卷容器</li>
<li>前提：以sobxiong/centos为模板运行容器test1，它具有/dataVolumeContainer1和/dataVolumeContainer2容器卷</li>
<li>容器间传递共享：<ol>
<li>先启动父容器test1，并在dataVolumeContainer2中新增内容</li>
<li>以继承方式启动test2和test3：docker run -it –name test2 –volumes-from test1 sobxiong/centos</li>
<li>test2和test3分别在dataVolumeContainer2中新增内容</li>
<li>test1中可以看到新增的内容</li>
<li>删除test1后，test2修改的内容test3依旧可读</li>
<li>删除test2后，test3依旧可读之前内容</li>
<li>新建test4继承test3再删除test3，之前内容依旧可见</li>
</ol>
</li>
<li>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li><p>是什么：用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本</p>
</li>
<li><p>构建三步骤：</p>
<ol>
<li>编写Dockerfile文件</li>
<li>docker build</li>
<li>docker run</li>
</ol>
</li>
<li><p>Dockerfile具体实例</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以CentOS镜像为例</span></span><br><span class="line"><span class="comment"># https://github.com/CentOS/sig-cloud-instance-images/blob/12a4f1c0d78e257ce3d33fe89092eee07e6574da/docker/Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> centos-8-x86_64.tar.xz /</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> org.label-schema.schema-version=<span class="string">"1.0"</span>     org.label-schema.name=<span class="string">"CentOS Base Image"</span>     org.label-schema.vendor=<span class="string">"CentOS"</span>     org.label-schema.license=<span class="string">"GPLv2"</span>     org.label-schema.build-date=<span class="string">"20200809"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Dockerfile基础知识：</p>
<ol>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>‘#’表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
</li>
<li><p>执行Dockerfile的大致流程</p>
<ol>
<li>docker从基础镜像(scratch)运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行Dockerfile中的下一条指令直到所有指令都执行完成</li>
<li>小总结：<ul>
<li>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：<ol>
<li>Dockerfile是软件的原材料</li>
<li>Docker镜像是软件的交付品</li>
<li>Docker容器则可以认为是软件的运行态</li>
</ol>
</li>
<li>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石：<br><img src="Dockerfile%E6%9E%84%E5%BB%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Dockerfile构建示意图"><ol>
<li>Dockerfile：定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务、内核进程打交道时,需要考虑如何设计namespace的权限控制)等等</li>
<li>Docker镜像：在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行Docker镜像时真正开始提供服务</li>
<li>Docker容器：直接提供服务</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Dockerfile体系结构(保留字指令)</p>
<ol>
<li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的</p>
</li>
<li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p>RUN：容器构建时需要运行的命令</p>
</li>
<li><p>EXPOSE：当前容器对外暴露出的端口</p>
</li>
<li><p>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
</li>
<li><p>ENV：用来在构建镜像过程中设置环境变量</p>
 <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境变量可以在后续的任何RUN指令中使用,就如同在命令前面指定了环境变量前缀一样</span></span><br><span class="line"><span class="comment"># 也可以在其它指令中直接使用这些环境变量,如：WORKDIR $MY_PATH</span></span><br><span class="line"><span class="keyword">ENV</span> MY_PATH /usr/mytest</span><br></pre></td></tr></table></figure>
</li>
<li><p>ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p>
</li>
<li><p>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中源路径的文件/目录复制到新的一层的镜像内的目标路径位置</p>
<ol>
<li>COPY src dest</li>
<li>COPY [“src”, “dest”]</li>
</ol>
</li>
<li><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p>CMD：指定一个容器启动时要运行的命令；Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</p>
</li>
<li><p>ENTRYPOINT：指定一个容器启动时要运行的命令；ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数(不像CMD,不会被替换,都生效)</p>
</li>
<li><p>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p>
</li>
<li><p>小总结：<br><img src="Dockerfile%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4.png" alt="Dockerfile常用保留字指令"></p>
</li>
</ol>
</li>
<li><p>案例：</p>
<ul>
<li><p>Base镜像(scratch)：Docker Hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</p>
</li>
<li><p>自定义镜像mycentos：</p>
<ul>
<li><p>编写：</p>
<ul>
<li><p>目标：</p>
<ol>
<li>基于centos镜像</li>
<li>登陆后默认路径为/</li>
<li>安装vim编辑器</li>
<li>安装net-tools(支持ifconfig)</li>
</ol>
</li>
<li><p>内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> sobxiong</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"success--------------ok"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>构建：docker build -f Dockerfile -t 新镜像名:Tag .</p>
</li>
<li><p>运行：docker run -it 新镜像名:Tag</p>
</li>
<li><p>列出镜像变更历史：docker history 镜像名</p>
</li>
<li><p>CMD/ENTRYPOINT：均指定一个容器启动时要运行的命令</p>
<ul>
<li>CMD：Dockerfile中可以有多个CMD 指令，但只有最后一个生效，CMD会被docker run之后的参数替换</li>
<li>ENTRYPOINT：docker run之后的参数会被当做参数传递给ENTRYPOINT，之后形成新的命令组合</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：<br><img src="Dockerfile%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Dockerfile构建过程示意图"></p>
</li>
</ul>
<h2 id="Docker安装步骤"><a href="#Docker安装步骤" class="headerlink" title="Docker安装步骤"></a>Docker安装步骤</h2><ol>
<li>搜索镜像</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像</li>
<li>停止容器</li>
<li>移除容器</li>
</ol>
<h2 id="Docker镜像发布"><a href="#Docker镜像发布" class="headerlink" title="Docker镜像发布"></a>Docker镜像发布</h2><ul>
<li>发布流程(阿里云)<br><img src="%E9%98%BF%E9%87%8C%E4%BA%91ECS%E7%9A%84Docker%E7%94%9F%E6%80%81%E5%9B%BE.png" alt="阿里云ECS的Docker生态图"><ol>
<li>生成镜像：<ol>
<li>从Dockerfile构建</li>
<li>从容器创建一个新镜像：docker commit [Options] 容器id [Repository[:Tag]]</li>
</ol>
</li>
<li>将本地镜像推送到阿里云<ol>
<li>登陆阿里云</li>
<li>创建仓库镜像：命名空间、仓库名称</li>
<li>根据提示推送镜像到registery(此后可查看可下载)</li>
</ol>
</li>
</ol>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://sobxiong.github.io/2020/10/09/BasicSkill/Docker/>https://sobxiong.github.io/2020/10/09/BasicSkill/Docker/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-10-16T16:40:44+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年10月16日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/BasicSkill/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>BasicSkill</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sobxiong.github.io/2020/10/09/BasicSkill/Docker/&title=Docker - SOBXiong的博客&summary=内容
Docker简介
Docker安装
Docker常用命令
Docker镜像
Docker容器数据卷
Dockerfile
Docker安装步骤
Docker镜像发布
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sobxiong.github.io/2020/10/09/BasicSkill/Docker/&title=Docker - SOBXiong的博客&summary=内容
Docker简介
Docker安装
Docker常用命令
Docker镜像
Docker容器数据卷
Dockerfile
Docker安装步骤
Docker镜像发布
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sobxiong.github.io/2020/10/09/BasicSkill/Docker/&title=Docker - SOBXiong的博客&summary=内容
Docker简介
Docker安装
Docker常用命令
Docker镜像
Docker容器数据卷
Dockerfile
Docker安装步骤
Docker镜像发布
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/10/09/BasicSkill/DesignPattern/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>设计模式</p>
                <p class='content'>内容
七大原则
UML类图
设计模式概述
单例模式
工厂模式
原型模式
建造者模式
适配器模式
桥接模式
装饰者模式
组合模式
外观模式
享元模式
代理模式
模板方法模式
命令模式



七大原...</p>
              </a>
            
            
              <a class='next' href='/2020/10/09/BigData/Flume/'>
                <p class='title'>Flume<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>内容
</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Docker',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker简介"><span class="toc-text">Docker简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker安装"><span class="toc-text">Docker安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker常用命令"><span class="toc-text">Docker常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker镜像"><span class="toc-text">Docker镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker容器数据卷"><span class="toc-text">Docker容器数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker安装步骤"><span class="toc-text">Docker安装步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker镜像发布"><span class="toc-text">Docker镜像发布</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:1942991710@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/SOBXiong"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="http://xiongjc.top" target="_blank" rel="noopener">Copyright © 2017-2020 SOBXiong</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
