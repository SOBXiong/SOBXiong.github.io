<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.6'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>JUC - SOBXiong的博客</title>
  
    <meta name="keywords" content="Java高级">
  
  
    <meta name="description" content="内容
JUC是什么
Lock接口
线程间通信
线程间定制化调用通信
线程八锁
线程不安全集合
Callable接口
JUC辅助类
BlockingQueue阻塞队列
ThreadPool线程池
Java8流式计算
Java8分支合并
异步回调
volatile
CAS
值传递和引用传递
Java锁的类型
死锁及定...">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/favicon.png'></i>
          
          
            SOBXiong
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/09/18/ProgrammingLanguage/Java/JUC/">
      JUC
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="http://xiongjc.top" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/SOBXiong/imageBed/hdImg_f757fa7e0fd65077ce52d251fc7a01d815860762755.jpg">
    <p>SOBXiong</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年9月18日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><a href="#JUC是什么">JUC是什么</a></li>
<li><a href="#Lock接口">Lock接口</a></li>
<li><a href="#线程间通信">线程间通信</a></li>
<li><a href="#线程间定制化调用通信">线程间定制化调用通信</a></li>
<li><a href="#线程八锁">线程八锁</a></li>
<li><a href="#线程不安全集合">线程不安全集合</a></li>
<li><a href="#Callable接口">Callable接口</a></li>
<li><a href="#JUC辅助类">JUC辅助类</a></li>
<li><a href="#BlockingQueue阻塞队列">BlockingQueue阻塞队列</a></li>
<li><a href="#ThreadPool线程池">ThreadPool线程池</a></li>
<li><a href="#Java8流式计算">Java8流式计算</a></li>
<li><a href="#Java8分支合并">Java8分支合并</a></li>
<li><a href="#异步回调">异步回调</a></li>
<li><a href="#volatile">volatile</a></li>
<li><a href="#CAS">CAS</a></li>
<li><a href="#值传递和引用传递">值传递和引用传递</a></li>
<li><a href="#Java锁的类型">Java锁的类型</a></li>
<li><a href="#死锁及定位分析">死锁及定位分析</a></li>
</ul>
<a id="more"></a>

<h2 id="JUC是什么"><a href="#JUC是什么" class="headerlink" title="JUC是什么"></a>JUC是什么</h2><ul>
<li><p>JUC介绍：JDK1.5时Java引入的并发编程工具包——java.util.concurrent</p>
</li>
<li><p>基础知识回顾：</p>
<ul>
<li><p>进程/线程是什么：</p>
<ul>
<li>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元</li>
<li>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度</li>
</ul>
</li>
<li><p>进程/线程例子：</p>
<ul>
<li>进程：QQ.ext、word.exe</li>
<li>线程：word检查拼写、word容灾备份</li>
</ul>
</li>
<li><p>线程的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW, <span class="comment">// 创建</span></span><br><span class="line">  RUNNABLE, <span class="comment">// 准备就绪(还需等待OS),Thread实例start()后并不是马上运行,只是进入就绪状态,等待OS</span></span><br><span class="line">  BLOCKED, <span class="comment">// 阻塞</span></span><br><span class="line">  WAITING, <span class="comment">// 等待(一直等下去——不见不散)</span></span><br><span class="line">  TIMED_WAITING, <span class="comment">// 等待(有时限的等待——过时不候)</span></span><br><span class="line">  TERMINATED; <span class="comment">// 终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>wait/sleep的区别：</p>
<ul>
<li>wait/sleep都可以使当前线程暂停</li>
<li>wait放开手睡眠，放开手里的锁</li>
<li>sleep握紧手睡眠，唤醒后手里还有锁</li>
</ul>
</li>
<li><p>并发/并行各自都是什么：</p>
<ul>
<li>并发：同一时刻多个线程在访问同一个资源(例子：抢车票)</li>
<li>并行：多项工作同时执行，之后在汇合(例子：泡脚玩手机)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><ul>
<li><p>复习Synchronized：</p>
<ul>
<li><p><strong>多线程口诀1、2</strong>：</p>
<ul>
<li>高内聚低耦合</li>
<li>线程、操作、资源类</li>
</ul>
</li>
<li><p>实现步骤：</p>
<ol>
<li><p>创建资源类</p>
</li>
<li><p>资源类里创建同步方法(代码块)</p>
</li>
<li><p>创建线程，访问资源</p>
</li>
</ol>
</li>
<li><p>卖票实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：三个售票员,卖100张票</span></span><br><span class="line"><span class="comment">* 多线程编程的企业级套路 + 模版</span></span><br><span class="line"><span class="comment">* 1、高内聚低耦合</span></span><br><span class="line"><span class="comment">* 2、线程 操作(对外暴露的调用方法) 资源类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程不能直接继承Thread类,因为Java是单继承,资源宝贵,要使用接口方式</span></span><br><span class="line">    <span class="comment">// 如果方法体简单,可以不用继承Runnable接口,而直接采用匿名内部类/lambda表达式</span></span><br><span class="line">    <span class="comment">// 创建线程要使用两个参数Thread(runnable, name)的方式</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t卖出第"</span> + (number--) + <span class="string">"张票\t,还剩下"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Lock接口：</p>
<ul>
<li><p>Lock介绍(摘录自JDK1.8)：Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects —— 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象</p>
</li>
<li><p>Lock的常用实现类ReentrantLock(可重入锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock使用模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedResource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * synchronized与Lock的区别</span></span><br><span class="line"><span class="comment">  * 1、首先synchronized是java内置关键字,在jvm层面;Lock是个java类</span></span><br><span class="line"><span class="comment">  * 2、synchronized无法判断是否获取锁的状态,Lock可以判断是否获取到锁</span></span><br><span class="line"><span class="comment">  * 3、synchronized会自动释放锁(a:线程执行完同步代码会释放锁;b:线程执行过程中发生异常会释放锁);Lock需在finally中手动释放锁(unlock()方法释放锁),否则容易造成线程死锁</span></span><br><span class="line"><span class="comment">  * 4、用synchronized关键字的两个线程1和线程2,如果当前线程1获得锁,线程2线程等待。如果线程1阻塞,线程2则会一直等待下去;而Lock锁就不一定会等待下去,如果尝试获取不到锁,线程可以不用一直等待就结束了</span></span><br><span class="line"><span class="comment">  * 5.synchronized的锁可重入、不可中断、非公平,而Lock锁可重入、可判断、可公平(默认非公平,二者皆可)</span></span><br><span class="line"><span class="comment">  * 6.Lock锁适合大量同步的代码的同步问题,synchronized锁适合代码少量的同步问题</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">competitionMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// block until condition holds</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lock方式卖票实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">120</span>; i++) ticket.saleTicket();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t卖出第"</span> + (number--) + <span class="string">"张票\t,还剩下"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul>
<li><p>题目：两个线程来操作初始值为零的一个变量，实现一个线程对该变量加1,另一个线程对该变量减1。实现交替10个轮次,变量初始值为0</p>
</li>
<li><p>线程间通信：</p>
<ol>
<li>生产者/消费者模型</li>
<li>通知等待唤醒机制</li>
</ol>
</li>
<li><p><strong>多线程口诀3</strong>：</p>
<ol>
<li>判断</li>
<li>干活</li>
<li>通知</li>
</ol>
</li>
<li><p>老版本synchronized实现：</p>
<ul>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断</span></span><br><span class="line">    <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、干活</span></span><br><span class="line">    number++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t生产,剩余"</span> + number);</span><br><span class="line">    <span class="comment">// 3、通知</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断</span></span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、干活</span></span><br><span class="line">    number--;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t消费,剩余"</span> + number);</span><br><span class="line">    <span class="comment">// 3、通知</span></span><br><span class="line">    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：两个线程来操作初始值为零的一个变量,实现一个线程对该变量加1,另一个线程对该变量减1;实现交替10个轮次,变量初始值为0</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cake cake = <span class="keyword">new</span> Cake();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cake.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cake.decrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：符合要求</p>
</li>
<li><p>如果换成4个线程(2消费者,2生产者)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只改变main</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Cake cake = <span class="keyword">new</span> Cake();</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ProducerB"</span>).start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"ConsumerB"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：出现错误，有可能生产出大于1的cake来</p>
</li>
<li><p>原因：换成4个线程会导致错误——虚假唤醒，因为在Java多线程判断时，不能用if。错误出在了判断上面：如果突然有一个增加cake的线程进入到if里面了，但突然中断了并交出控制权。等到唤醒后由于是if，不需要再次进行验证，而是直接走下去了，所以进行了错误的增加<br><img src="%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚假唤醒示意图"></p>
</li>
<li><p>解决方法：把所有的资源类的increment()和decrement()方法中的if判断变为while判断</p>
</li>
</ul>
</li>
<li><p><strong>多线程口诀4</strong>：注意多线程之间的虚假唤醒</p>
</li>
<li><p>新版本Lock实现：</p>
<ul>
<li><p>新老版本对标：</p>
<ol>
<li>synchronized - Lock</li>
<li>wait - await</li>
<li>notify - signal</li>
</ol>
</li>
<li><p>Lock示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t生产,剩余"</span> + number);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      number++;</span><br><span class="line">      <span class="comment">// 3、通知</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t消费,剩余"</span> + number);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      number--;</span><br><span class="line">      <span class="comment">// 3、通知</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：两个线程来操作初始值为零的一个变量,实现一个线程对该变量加1,另一个线程对该变量减1;实现交替10个轮次,变量初始值为0</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">* 3、多线程交互中,必须要防止多线程的虚假唤醒,也即(判断只能用while,不能用if)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadAwaitSignal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cake1 cake = <span class="keyword">new</span> Cake1();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerA"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.increment();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ProducerB"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cake.decrement();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"ConsumerB"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="线程间定制化调用通信"><a href="#线程间定制化调用通信" class="headerlink" title="线程间定制化调用通信"></a>线程间定制化调用通信</h2><ul>
<li><p>题目：多线程之间按顺序调用，实现A -&gt; B -&gt; C，三个线程启动,要求如下：AAAAA打印5次，BBBBB打印10次，CCCCC打印15次，以上操作进行10轮</p>
</li>
<li><p><strong>多线程口诀5</strong>：标志位</p>
</li>
<li><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1 -&gt; A, 2 -&gt; B, 3 -&gt; C</span></span><br><span class="line">  <span class="comment">// 一把锁lock</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 三把钥匙condition</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionA = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionB = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">        conditionA.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"AAAAA ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">2</span>;</span><br><span class="line">      conditionB.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">        conditionB.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"BBBBB ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">3</span>;</span><br><span class="line">      conditionC.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFromC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、判断</span></span><br><span class="line">      <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">        conditionC.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、干活</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"CCCCC ~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、通知(修改标志位,通知下一个)</span></span><br><span class="line">      number = <span class="number">1</span>;</span><br><span class="line">      conditionA.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：多线程之间按顺序调用,实现A -&gt; B -&gt; C,三个线程启动,要求如下：AAAAA打印5次,BBBBB打印10次,CCCCC打印15次,以上操作进行10轮</span></span><br><span class="line"><span class="comment">* 1、高聚合低耦合前提下,线程操作资源类</span></span><br><span class="line"><span class="comment">* 2、判断/干活/通知</span></span><br><span class="line"><span class="comment">* 3、多线程交互中,必须要防止多线程的虚假唤醒,也即(判断只能用while,不能用if)</span></span><br><span class="line"><span class="comment">* 4、标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOrderAccess</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromA();</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromB();</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) shareResource.printFromC();</span><br><span class="line">    &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul>
<li><p>八锁示例：</p>
<ul>
<li><p>情况1(标准访问)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、标准访问,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock8</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况2(其一线程sleep)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、邮件方法暂停4秒,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况3(新增一个普通方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、在2的基础上,新增并使用一个普通方法hello(),请问先打印邮件还是hello? hello</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.hello();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况4(两个对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、两部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况5(改为静态同步方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、两个静态同步方法,同一部手机,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况6(两个对象调用静态同步方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、两个静态同步方法,两部手机,请问先打印邮件还是短信? 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况7(一个静态同步方法,一个普通同步方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、一个普通同步方法,一个静态同步方法,一部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况8(一个静态同步方法,一个普通同步方法,两个对)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Send Email ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Send Message ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8、一个普通同步方法,一个静态同步方法,两部手机,请问先打印邮件还是短信? 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        phone1.sendMessage();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>八锁分析：</p>
<ul>
<li>情况1、2：如果一个对象有多个synchronized方法，某个时刻内只要有一个线程去调用当前对象的一个synchronized方法，那么其它线程只能等待。换句话说，某个时刻内只能有唯一一个线程去访问这些synchronized方法。锁作用的是当前对象this，this被锁定后其它的线程都不能进入到当前对象的其它的synchronized方法(情况1、2都进入了sendEmail()方法,因此不响应sendMessage()方法)</li>
<li>情况3、4：普通方法和同步锁无关，一个线程调用了synchronized方法，另一个线程可以同时调用普通方法；当换成两个对象后，synchronized锁的是对象实例，而当前有两个实例，锁的就不是同一把锁了，因此sendMessage先打印</li>
<li>情况5、6：对于静态同步方法，锁是当前类的Class对象，对于同一个Phone类锁是相同的(Phone.class)，因此进入sendEmail()方法后不会响应sendMessage()方法，而是等待sendEmail()方法执行完毕</li>
<li>情况7、8：对于普通同步方法和静态同步方法，他们锁的对象不同，普通同步方法锁的是当前对象实例(Phone的一个实例对象)，而静态同步方法锁的是当前类的Class对象(Phone.class)。他们锁的对象不同，不会相互影响，因此先打印sendMessage</li>
</ul>
</li>
<li><p><strong>线程八锁总结</strong>：</p>
<ul>
<li>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象</li>
</ul>
</li>
<li>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待已获取锁的方法释放锁后才能获取锁</li>
<li>其他实例对象的普通同步方法跟当前实例对象的普通同步方法用的是不同的锁(不同的实例对象)，所以无须等待当前实例对象已获取锁的普通同步方法释放锁就可以获取他们自己的锁</li>
<li>所有静态同步方法用的是同一把锁——类对象本身，普通同步方法的锁和静态同步方法的锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的。但一旦一个静态同步方法获取锁后，其他静态同步方法都必须等待该方法释放锁后才能获取锁(而不管是同一个实例对象的静态同步方法之间，还是不同实例对象的静态同步方法之间，只要它们是同一个类的实例对象)</li>
</ul>
</li>
</ul>
<h2 id="线程不安全集合"><a href="#线程不安全集合" class="headerlink" title="线程不安全集合"></a>线程不安全集合</h2><ul>
<li><p>线程不安全的集合</p>
<ul>
<li><p>ArrayList</p>
<ul>
<li><p>情况1：3个线程同时读写ArrayList(结果：运行基本不报错,但是会出现List中有时内容为null或者集合元素个数不等于3的情况)</p>
</li>
<li><p>情况2：30个线程同时读写ArrayList(结果：运行报错——java.util.ConcurrentModificationException并发修改异常)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> or <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(list);</span><br><span class="line">    &#125;, <span class="string">"list"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出错原因：ArrayList本身就是线程不安全的(为了性能考虑,不加锁性能提升但会出错误)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>改用Vector(线程安全,加了synchronized,加锁数据一致但性能下降;性能较差,不要使用)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">  elementData[elementCount++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Collections工具类<br> 少量数据可以使用，通过在ArrayList外包装一层同步机制<br> <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code></p>
</li>
<li><p>CopyOnWriteArrayList(推荐使用)<br> CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)<br> 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器是一种读写分离的思想，读和写不同的容器  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyOnWriteArrayList.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="comment">// copy原始数据</span></span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新增数据</span></span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    <span class="comment">// 引用更新</span></span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>HashSet(HashSet底层就是HashMap)</p>
<ul>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new HashSet&lt;&gt;()</span></span><br><span class="line">  <span class="comment">// Collections.synchronizedSet(new HashSet&lt;&gt;())</span></span><br><span class="line">  <span class="comment">// new CopyOnWriteArraySet&lt;&gt;()</span></span><br><span class="line">  Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(set);</span><br><span class="line">    &#125;, <span class="string">"set"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>Collections工具类<br> <code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></p>
</li>
<li><p>CopyOnWriteArraySet<br> 底层还是CopyOnWriteArrayList</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5457747651344034263L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates an empty set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>HashMap</p>
<ul>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new HashMap&lt;&gt;()</span></span><br><span class="line">  <span class="comment">// Collections.synchronizedMap(new HashMap&lt;&gt;())</span></span><br><span class="line">  <span class="comment">// new ConcurrentHashMap&lt;&gt;()</span></span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">      System.out.println(map);</span><br><span class="line">    &#125;, <span class="string">"map"</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<ol>
<li>Collections工具类<br> <code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code></li>
<li>ConcurrentHashMap</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><ul>
<li><p>获得多线程的方法有几种?</p>
<ol>
<li>继承Thread类(不建议使用)</li>
<li>实现Runnale接口</li>
<li>实现Callable接口</li>
<li>从线程池获取</li>
</ol>
</li>
<li><p>Callable是什么：一个JDK1.5推出的线程接口，比Runnable更强大。是一个函数式接口，可用作lambda表达式。能在线程执行完成后返回结果(应用场景一般在于批处理业务,如转账时需要返回结果的状态码,代表本次操作的成功与否)</p>
</li>
<li><p>与Runnable的区别：</p>
<ol>
<li>是否有返回值</li>
<li>是否会抛出异常</li>
<li>落地方法不同(run()/call())</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么使用：</p>
<ol>
<li><p><del>直接替换runnable：不可行，Thread的构造方法传参都是Runnable接口，没有Callable接口</del></p>
</li>
<li><p>找中间人FutureTask：FutureTask类实现了Runnable接口，并且接收一个Callable接口作为构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"~~~"</span> + Thread.currentThread().getName() + <span class="string">" Come in call() ~~~"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"1024"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 多线程第3种创建多线程的方式</span></span><br><span class="line"><span class="comment">* get()方法一般请放在最后一行,它会阻塞线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask, <span class="string">"B"</span>).start();</span><br><span class="line">    <span class="comment">// System.out.println(Thread.currentThread().getName() + "计算中~~~");</span></span><br><span class="line">    <span class="comment">// 使用类似自旋锁的方式判断是否运行完毕</span></span><br><span class="line">    <span class="keyword">while</span> (!futureTask.isDone())&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"计算中~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"计算完成~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">~~~A Come in call() ~~~</span><br><span class="line">main计算中~~~</span><br><span class="line">1024</span><br><span class="line">1024</span><br><span class="line">main计算完成~~~</span><br></pre></td></tr></table></figure>

<p>说明：多个线程执行一个FutureTask时只会计算一次，结果缓存，因此Come in call()方法只打印一次。如果需要两个线程同时计算任务时，需要定义两个futureTask</p>
</li>
</ol>
</li>
<li><p>FutureTask/Callable应用场景：在主线程中需要执行比较耗时的操作但又不想阻塞主线程时，可把这些操作交给FutureTask对象在后台完成。当主线程将来需要操作结果时可以通过FutureTask对象获得后台作业的计算结果或者执行状态。一般FutureTask多用于耗时的计算任务，主线程可在完成自己的任务后再去获取结果。仅在计算完成时才能检索结果；如果计算尚未完成，则会阻塞get()方法。get()方法获取结果只有在计算完成时获取，否则会阻塞直到任务转入完成状态，最后返回结果或者抛出异常。一旦计算完成，就不会再重新开始或取消计算，如果再次调用结果方法，会将缓存的结果直接返回</p>
</li>
</ul>
<h2 id="JUC辅助类"><a href="#JUC辅助类" class="headerlink" title="JUC辅助类"></a>JUC辅助类</h2><ul>
<li><p>CountDownLatch(减少计数)</p>
<ul>
<li><p>概念：让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p>
</li>
<li><p>原理：CountDownLatch主要有两个方————countDown()以及await()。当一个或多个线程调用await()方法时，这些线程会阻塞。其它线程调用countDown()方法会将计数器减1(调用countDown()方法的线程不会阻塞)，当计数器的值变为0时，因await()方法阻塞的线程会被唤醒，继续执行</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>场景：假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后关灯、锁教室门然后走人，因此班长是需要最后一个走的。需要一种方法能够控制班长这个线程最后一个执行，而其它线程是随机执行的</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：所有子线程完成后(所有同学离开教室),主线程退出(班长离开教室)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 离开教室~~~"</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 班长关门走人~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规方法无法完成,会有乱序</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" 离开教室~~~"</span>), i + <span class="string">""</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" 班长关门走人~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 普通版本</span><br><span class="line">0 离开教室~~~</span><br><span class="line">2 离开教室~~~</span><br><span class="line">3 离开教室~~~</span><br><span class="line">1 离开教室~~~</span><br><span class="line">main 班长关门走人~~~</span><br><span class="line">4 离开教室~~~</span><br><span class="line">5 离开教室~~~</span><br><span class="line"></span><br><span class="line"># CountDownLatch版本</span><br><span class="line">a4055b7f 离开教室~~~</span><br><span class="line">816b8658 离开教室~~~</span><br><span class="line">1876e706 离开教室~~~</span><br><span class="line">9657fae5 离开教室~~~</span><br><span class="line">4833f0f9 离开教室~~~</span><br><span class="line">6d229a84 离开教室~~~</span><br><span class="line">main 班长关门走人~~~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CyclicBarrier(循环栅栏)</p>
<ul>
<li><p>概念：让一些线程阻塞直到另一些线程完成一系列操作才被唤醒。方式与CountDownLatch相反，做加法，开始为0，加到某个值时才开始执行</p>
</li>
<li><p>原理：CyclicBarrier的字面意思是可循环(Cyclic)使用的屏障(Barrier)。它做的事情是让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门；此时所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>场景：集齐7颗龙珠召唤神龙</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：子线程全部完成后再运行指定方法(集齐七棵龙珠召唤神龙)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" 召唤神龙~~~"</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"收集到第"</span> + finalI + <span class="string">"颗龙珠~~~"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cyclicBarrier.await();</span><br><span class="line">          <span class="comment">// 在7个线程中最后一个线程到达await()屏障,之后下面的语句和cyclicBarrier中设定的动作才会被调度执行</span></span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"收集第"</span> + finalI + <span class="string">"颗龙珠完毕~~~"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, i + <span class="string">""</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 收集到第1颗龙珠~~~</span><br><span class="line">2 收集到第2颗龙珠~~~</span><br><span class="line">3 收集到第3颗龙珠~~~</span><br><span class="line">4 收集到第4颗龙珠~~~</span><br><span class="line">5 收集到第5颗龙珠~~~</span><br><span class="line">6 收集到第6颗龙珠~~~</span><br><span class="line">7 收集到第7颗龙珠~~~</span><br><span class="line">7 召唤神龙~~~</span><br><span class="line">7 收集第7颗龙珠完毕~~~</span><br><span class="line">1 收集第1颗龙珠完毕~~~</span><br><span class="line">3 收集第3颗龙珠完毕~~~</span><br><span class="line">2 收集第2颗龙珠完毕~~~</span><br><span class="line">6 收集第6颗龙珠完毕~~~</span><br><span class="line">5 收集第5颗龙珠完毕~~~</span><br><span class="line">4 收集第4颗龙珠完毕~~~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Semaphore(信号量)</p>
<ul>
<li><p>概念：信号量，用于两个目的：</p>
<ol>
<li>用于共享资源的互斥使用</li>
<li>用于并发线程数的控制</li>
</ol>
</li>
<li><p>原理：在信号量上了定义两种操作：acquire()————获取，当一个线程调用acquire()操作时，它要么成功并获取信号量(信号量减1)，要么一直等下去直到有线程释放信号量或超时；release()————释放，会将信号量的值加1，然后唤醒等待的线程</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>场景：抢车位，假设有6辆车，3个停车位</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求：只有三个线程，但是希望六个线程都能够运行(有3个空闲车位,共有6辆车,一开始3辆车抢到,之后开走1辆另外的车占1个车位)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟资源类,有3个空车位</span></span><br><span class="line">    <span class="comment">// false表示非公平锁,默认也是非公平锁</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> finalI = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取信号量(车位)</span></span><br><span class="line">          semaphore.acquire();</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到了车位 ~~~"</span>);</span><br><span class="line">          TimeUnit.SECONDS.sleep(finalI);</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" 离开了车位 ~~~"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放信号量(车位)</span></span><br><span class="line">          semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, i + <span class="string">"号车"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0号车 抢到了车位 ~~~</span><br><span class="line">2号车 抢到了车位 ~~~</span><br><span class="line">1号车 抢到了车位 ~~~</span><br><span class="line">0号车 离开了车位 ~~~</span><br><span class="line">3号车 抢到了车位 ~~~</span><br><span class="line">1号车 离开了车位 ~~~</span><br><span class="line">4号车 抢到了车位 ~~~</span><br><span class="line">2号车 离开了车位 ~~~</span><br><span class="line">5号车 抢到了车位 ~~~</span><br><span class="line">3号车 离开了车位 ~~~</span><br><span class="line">4号车 离开了车位 ~~~</span><br><span class="line">5号车 离开了车位 ~~~</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h2><ul>
<li><p>阻塞队列介绍：<br>首先是一个队列，大致的数据结构如下图所示：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阻塞队列示意图"></p>
<ol>
<li>线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素</li>
<li><code>当队列是空的，从队列中获取元素的操作将会被阻塞</code></li>
<li><code>当队列是满的，从队列中添加元素的操作将会被阻塞</code></li>
<li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li>
<li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素，或者完全清空使队列变得空闲起来，再进行后续新增</li>
</ol>
</li>
<li><p>阻塞的解释：在多线程领域，所谓的阻塞就是指在某些情况下线程会被挂起，但一旦条件满足，被挂起的线程又会自动被唤起</p>
</li>
<li><p>阻塞队列的好处：</p>
<ol>
<li>不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，为这一切BlockingQueue都一手包办了</li>
<li>在concurrent包发布以前，多线程环境下每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给程序开发带来不小的复杂度</li>
</ol>
</li>
<li><p>阻塞队列种类：</p>
<ul>
<li>继承图：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="阻塞队列继承图"></li>
<li>各实现类介绍：<ol>
<li><strong>ArrayBlockingQueue</strong>：由数组结构组成的有界阻塞队列</li>
<li><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界(但大小默认值为integer.MAX_VALUE)的阻塞队列</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列(生产一个,消费一个,不存储元素,不消费不生产)</li>
<li>LinkedTransferQueue：由链表组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表组成的双向阻塞队列</li>
</ol>
</li>
</ul>
</li>
<li><p>阻塞队列核心方法：<br><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png" alt="阻塞队列核心方法"></p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>抛出异常</strong></td>
<td><strong>当阻塞队列满时，再往队列里add插入元素会抛出异常IllegalStateException:Queue full；当阻塞队列空时，再往队列里remove移除元素会抛出异常NoSuchElementException</strong></td>
</tr>
<tr>
<td>特殊值</td>
<td>插入方法————成功ture，失败false；移除方法————成功返回出队列的元素，队列里没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据成功(元素被消费)或响应中断退出；当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用(元素被生产)</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
</li>
<li><p>用处</p>
<ol>
<li><p>线程池</p>
</li>
<li><p>消息中间件</p>
</li>
<li><p>生产者消费者模式</p>
<ul>
<li><p>需求：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来五轮</p>
</li>
<li><p>多线程口诀：</p>
<ol>
<li>线程、操作、资源类</li>
<li>判断、干活、通知</li>
<li>防止虚假唤醒机制</li>
</ol>
</li>
<li><p>传统版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 循环判断</span></span><br><span class="line">      <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待,不生产</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 干活</span></span><br><span class="line">      num++;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + num);</span><br><span class="line">      <span class="comment">// 通知唤醒</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deIncrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待,不生产</span></span><br><span class="line">        condition.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 干活</span></span><br><span class="line">      num--;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + num);</span><br><span class="line">      <span class="comment">// 通知唤醒</span></span><br><span class="line">      condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 解锁</span></span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerTraditionDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          shareData.increment();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          shareData.deIncrement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞队列版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认开启,进行生产/消费</span></span><br><span class="line">  <span class="comment">// volatile修饰,保证多线程内存可见性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 依赖注入,定义接口,而非实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProduce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String data;</span><br><span class="line">    <span class="keyword">boolean</span> returnValue;</span><br><span class="line">    <span class="comment">// 多线程环境的判断一定要使用while进行,防止出现虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      data = atomicInteger.incrementAndGet() + <span class="string">""</span>;</span><br><span class="line">      returnValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span> (returnValue) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" insert "</span> + data + <span class="string">" succeed~~~"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" insert "</span> + data + <span class="string">" fail~~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" myProduce() finish~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result;</span><br><span class="line">    <span class="comment">// 多线程环境的判断一定要使用while进行,防止出现虚假唤醒</span></span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty()) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" over 2 seconds"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" get "</span> + result + <span class="string">" succeed~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" myConsume() finish~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumeBlockQueueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" produce thread start~~~"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        myResource.myProduce();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"Produce Thread"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" Consume thread start~~~"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        myResource.myConsume();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">"Consume Thread"</span>).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      myResource.stop();</span><br><span class="line">      System.out.println(<span class="string">"Main Stop()~~~"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">Produce Thread produce thread start~~~</span><br><span class="line">Consume Thread Consume thread start~~~</span><br><span class="line">Produce Thread insert 1 succeed~~~</span><br><span class="line">Consume Thread get 1 succeed~~~</span><br><span class="line">Produce Thread insert 2 succeed~~~</span><br><span class="line">Consume Thread get 2 succeed~~~</span><br><span class="line">Produce Thread insert 3 succeed~~~</span><br><span class="line">Consume Thread get 3 succeed~~~</span><br><span class="line">Produce Thread insert 4 succeed~~~</span><br><span class="line">Consume Thread get 4 succeed~~~</span><br><span class="line">Produce Thread insert 5 succeed~~~</span><br><span class="line">Consume Thread get 5 succeed~~~</span><br><span class="line">Main Stop()~~~</span><br><span class="line">Produce Thread myProduce() finish~~~</span><br><span class="line">Consume Thread over 2 seconds</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="ThreadPool线程池"><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h2><ul>
<li><p>为什么使用线程池：主要特点有线程复用、控制最大并发数、管理线程<br>线程池做的主要工作就是控制运行的线程的数量，处理过程中将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量则排队等候，等其它线程执行完毕，再从队列中取出任务来执行</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
</li>
<li><p>线程池如何使用：</p>
<ul>
<li>线程池类继承图：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="线程池类继承图"></li>
<li>获取线程池的几种方式：<ol>
<li>Executors.newFixedThreadPool(int)：创建一个具有n个固定线程的线程池<ul>
<li>执行长期的任务，性能较好</li>
<li>创建一个<strong>定长线程池</strong>，可控制线程数最大并发数，超出的线程会在队列中等待</li>
<li>corePoolSize和MaxmumPoolSize是相等的，为输入的n；使用的底层阻塞队列是LinkedBlockingQueue</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor()：创建一个只有1个线程的单线程池<ul>
<li>一个任务一个任务执行的场景</li>
<li>创建一个<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li>
<li>corePoolSize和MaxmumPoolSize都设置为1；使用的底层阻塞队列是<strong>LinkedBlockingQueue</strong></li>
</ul>
</li>
<li>Executors.newCachedThreadPool()：创建一个可扩容的线程池<ul>
<li>使用执行很多短期异步的小程序或负载较轻的服务器</li>
<li>创建一个<strong>可缓存线程池</strong>，如果线程长度超过处理需要，可灵活回收空闲线程。如无线程可回收，则新建新线程</li>
<li>corePoolSize设置为0，maxmumPoolSize设置为Integer.MAX_VALUE；使用的底层阻塞队列是<strong>SynchronousQueue</strong>；来了任务就创建线程运行，如果线程空闲超过传入指定的keepAliveTime时间，就销毁线程</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool(int)：创建周期性执行任务的线程池<ul>
<li>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li>
<li>使用的底层阻塞队列为DelayedWorkQueue</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Executors创建线程原理：<br><img src="Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86.png" alt="Executors创建线程原理"></p>
</li>
<li><p>线程池参数解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">    maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">    keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">  <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul>
<li>在创建线程池后，当有请求任务就会安排池中的线程去执行请求任务</li>
<li>当线程池中的线程数目达到corePoolSize后，就会把到达的请求任务放到缓存队列中</li>
</ul>
</li>
<li>maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime：多余的空闲线程的存活时间，<ul>
<li>若当前池中线程数量超过corePoolSize，且当空闲时间达到keepAliveTime时，多余线程会被销毁，直到只剩下corePoolSize个线程为止</li>
<li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li>
</ul>
</li>
<li>unit：keepAliveTime的时间单位</li>
<li>workQueue：任务队列，用于存储被提交但尚未被执行的任务(也即上面介绍的阻塞队列)<ul>
<li>LinkedBlockingQueue：链表阻塞队列</li>
<li>SynchronousBlockingQueue：同步阻塞队列</li>
</ul>
</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，<strong>一般默认即可</strong></li>
<li>handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时，如何来拒绝请求执行的Runnable的策略</li>
</ol>
</li>
<li><p>线程池底层工作原理：<br><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="线程池底层工作原理"></p>
<ol>
<li>在创建了线程池后，开始等待提交过来的任务请求</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ol>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务<strong>放入队列</strong></li>
<li>如果这个时候队列满了，且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会<strong>启动饱和拒绝策略来执行</strong></li>
</ol>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断：<ol>
<li>如果当前运行的线程数大于corePoolSize，那么该线程就被停掉</li>
<li>当线程池的所有任务完成后，<strong>线程池线程数目最终会收缩到corePoolSize</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>线程池拒绝策略</p>
<ul>
<li>拒绝策略是什么：等待队列已经排满了，再也塞不下新任务了。同时，线程池中也达到了最大线程数，无法继续为新任务服务。这时就需要一种拒绝策略机制合理地处理这个问题</li>
<li>JDK内置的拒绝策略(内置拒绝策略均实现了RejectedExecutionHandle接口)<ol>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
<li>CallerRunsPolicy：”调用者运行”调节机制，该策略既不会抛弃任务也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略</li>
</ol>
</li>
</ul>
</li>
<li><p>线程池的选用</p>
<ul>
<li><p>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多：一个都不用<br><code>如Alibaba Java开发手册规定所示</code><br><img src="Alibaba_Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E8%A7%84%E5%AE%9A.png" alt="Alibaba Java开发手册规定"></p>
</li>
<li><p>自定义线程池示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RejectedExecutionException AbortPolicy</span></span><br><span class="line">    <span class="comment">// CallerRunsPolicy()</span></span><br><span class="line">    <span class="comment">// DiscardPolicy()</span></span><br><span class="line">    <span class="comment">// DiscardOldestPolicy()</span></span><br><span class="line">    ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">2L</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟有10个顾客来银行办理业务</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"办理业务~~~"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 线程池必须要关闭,重量资源</span></span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useSystemPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1池5个工作线程</span></span><br><span class="line">    <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">// 1池1个工作线程</span></span><br><span class="line">    <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">// 1池N个工作线程</span></span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟有10个顾客来银行办理业务</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">"办理业务~~~"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 线程池必须要关闭,重量资源</span></span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>线程池的合理参数配置<br>生产环境中如何配置corePoolSize和maximumPoolSize大小：根据具体业务来配置，分为CPU密集型和IO密集型</p>
<ol>
<li>CPU密集型<br>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行<br>CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)；而在单核CPU上，无论开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些<br>CPU密集型任务配置尽可能少的线程数量：一般为————CPU核数 + 1</li>
<li>IO密集型<br>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2<br>IO密集型即该任务需要大量的IO操作，即大量的阻塞<br>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上；IO密集型任务中使用多线程可以大大地加速程序的运行，即使在单核CPU上。这种加速主要就是利用了被浪费掉的阻塞时间<br>IO密集时，大部分线程都被阻塞，故需要多配置线程数：参考————CPU核数 / (1 - 阻塞系数)<br>通常阻塞系数在0.8 ~ 0.9左右<br>例如：8核CPU：8 / (1 - 0.9) = 80个线程数</li>
</ol>
</li>
</ul>
<h2 id="Java8流式计算"><a href="#Java8流式计算" class="headerlink" title="Java8流式计算"></a>Java8流式计算</h2><ul>
<li><p>函数式接口(只有一个方法(除default和static方法)的接口)：</p>
<ul>
<li><p>Lambda表达式口诀：<strong>拷贝小括号，写死右括号，落地大括号</strong></p>
</li>
<li><p>Lambda案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Lambda表达式</span></span><br><span class="line"><span class="comment">* 口诀：拷贝小括号(参数),写死右括号,落地大括号</span></span><br><span class="line"><span class="comment">* 注释<span class="doctag">@FunctionalInterface</span>(只有一个方法的接口,函数式接口)</span></span><br><span class="line"><span class="comment">* default方法允许接口有默认实现(jdk1.8),可以有多个</span></span><br><span class="line"><span class="comment">* 静态方法实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpress</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Foo foo = () -&gt; System.out.println(<span class="string">"Hello LambdaExpress"</span>);</span><br><span class="line">    foo.sayHello();</span><br><span class="line"></span><br><span class="line">    Foo1 foo1 = (x, y) -&gt; <span class="number">2</span> * x + y;</span><br><span class="line">    System.out.println(foo1.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(foo1.div(<span class="number">1.0</span>, <span class="number">0.3333</span>));</span><br><span class="line">    System.out.println(Foo1.multiply(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java内置核心四大函数式接口<br><img src="Java%E5%86%85%E7%BD%AE%E6%A0%B8%E5%BF%83%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt="Java内置核心四大函数式接口"></p>
</li>
</ul>
</li>
<li><p>Stream流</p>
<ul>
<li><p>是什么：流(Stream)是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。集合讲的是数据，流讲的是计算</p>
</li>
<li><p>特点：</p>
<ol>
<li>Stream自己不会存储元素</li>
<li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li>
<li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行(懒加载)</li>
</ol>
</li>
<li><p>怎么用：</p>
<ol>
<li>创建一个Stream：一个数据源(数组、集合)</li>
<li>中间操作：一个中间操作，处理数据源数据</li>
<li>终止操作：一个终止操作，执行中间操作链，产生结果</li>
</ol>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String  userName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment">*      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment">*      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">    User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">    User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">    User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">    User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">    List list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line">    list.stream().filter(p -&gt; p.getId() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      .filter(p -&gt; p.getAge() &gt; <span class="number">24</span>)</span><br><span class="line">      .map(f -&gt; f.getUserName().toUpperCase())</span><br><span class="line">      .sorted((o1, o2) -&gt; o2.compareTo(o1))</span><br><span class="line">      .limit(<span class="number">1</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Java8分支合并"><a href="#Java8分支合并" class="headerlink" title="Java8分支合并"></a>Java8分支合并</h2><ul>
<li><p>原理(类同MapReduce)：<br>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并</p>
</li>
<li><p>相关类：</p>
<ol>
<li>ForkJoinPool(分支合并线程池)<br><img src="ForkJoinPool%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ForkJoinPool继承图"></li>
<li>ForkJoinTask(类似FutureTask)<br><img src="ForkJoinTask%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="ForkJoinTask继承图"></li>
<li>RecursiveTask(递归任务,继承自ForkJoinTask,递归自己)<br><img src="RecursiveTask%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="RecursiveTask继承图"></li>
</ol>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> begin;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.begin = begin;</span><br><span class="line">      <span class="keyword">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((end - begin) &lt;= ADJUST_VALUE) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">        result += i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> middle = (end + begin) / <span class="number">2</span>;</span><br><span class="line">      MyTask leftTask = <span class="keyword">new</span> MyTask(begin, middle);</span><br><span class="line">      MyTask rightTask = <span class="keyword">new</span> MyTask(middle + <span class="number">1</span>, end);</span><br><span class="line">      leftTask.fork();</span><br><span class="line">      rightTask.fork();</span><br><span class="line">      result = leftTask.join() + rightTask.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>, <span class="number">1023423423L</span>);</span><br><span class="line">    ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    ForkJoinTask&lt;Long&gt; forkJoinTask = threadPool.submit(myTask);</span><br><span class="line">    System.out.println(forkJoinTask.get());</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><ul>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 同步</span></span><br><span class="line">  CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"无返回!"</span>));</span><br><span class="line">  completableFuture.get();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步</span></span><br><span class="line">  CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"有返回!"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步回调</span></span><br><span class="line">  System.out.println(completableFuture2.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：t = "</span> + t);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：u = "</span> + u);</span><br><span class="line">  &#125;).exceptionally(f -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"：f = "</span> + f.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4444</span>;</span><br><span class="line">  &#125;).get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li><p>介绍：volatile是Java虚拟机提供的轻量级的同步机制</p>
<ol>
<li>保证可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ol>
</li>
<li><p>JMM介绍：<br>JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念，<strong>并不真实存在</strong>。它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式<br>JMM关于同步规定：</p>
<ol>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>
<li>加锁解锁是同一把锁</li>
</ol>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间)。工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>。主内存是共享内存区域，所有线程都可访问，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行。首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存</strong>。不能直接操作主内存中的变量，各个线程中的工作内存储存着主内存中的<strong>变量副本拷贝</strong>，因此不同的线程无法访问对方的工作内存，线程间的通讯(传值)必须通过主内存来完成，其简要访问过程如下图所示：<br><img src="%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="线程间通讯访问内存示意图"><br><img src="%E5%9B%BE%E8%A7%A3%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图解主内存工作内存示意图"></p>
</li>
<li><p>可见性：通过JMM的介绍，可知各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的。这将导致可能存在一个线程A修改了共享变量X的值，该值还未写回主内存中；此时另外一个线程B又对内存中的共享变量X进行操作，但此时线程A工作内存中的共享变量X对线程B来说并不不可见。这种工作内存与主内存同步延迟现象就造成了可见性问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// volatile int number = 0;</span></span><br><span class="line">  <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证volatile可见性</span></span><br><span class="line"><span class="comment">// 假如int number = 0;number变量之前没有volatile关键字修饰,没有可见性</span></span><br><span class="line"><span class="comment">// 添加了volatile,可解决可见性问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      myData.add();</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"\t update number"</span>);</span><br><span class="line">    &#125;, <span class="string">"Test"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待,直到number被更新</span></span><br><span class="line">    <span class="keyword">while</span> (myData.number == <span class="number">0</span>) ;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over , number = "</span> + myData.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当number不加volatile关键字时,主内存不更新,一直在循环中</span></span><br><span class="line"><span class="comment">打印:</span></span><br><span class="line"><span class="comment">Test come in</span></span><br><span class="line"><span class="comment">Test update number</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当number加volatile关键字时,主内存可见,循环能正常退出</span></span><br><span class="line"><span class="comment">打印:</span></span><br><span class="line"><span class="comment">Test come in</span></span><br><span class="line"><span class="comment">Test update number</span></span><br><span class="line"><span class="comment">main mission is over , number = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原子性：操作不可分割，完整性。即某个线程正在做某个具体业务时，中间不可以被加塞或被分割。需整体完整，要么同时成功要么同时失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// AtomicInteger number = new AtomicInteger();</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// public void add() &#123; number.getAndIncrement(); &#125;</span></span><br><span class="line">  <span class="comment">// public synchronized void add() &#123; number++; &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证volatile不保证原子性</span></span><br><span class="line"><span class="comment">// 如何保证原子性：</span></span><br><span class="line"><span class="comment">// 1、加synchronized关键字()</span></span><br><span class="line"><span class="comment">// 2、使用AtomicInteger原子整型类替换int</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123; myData.add(); &#125;</span><br><span class="line">      &#125;, <span class="string">"Thread "</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待20个线程全部即算完成后,主线程继续执行(当还有子线程时,主线程算一个)</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 线程让步,让出CPU执行时间给其他线程</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印最终的结果值</span></span><br><span class="line">    System.out.println(myData.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当add()不加synchronized关键字时</span></span><br><span class="line"><span class="comment">打印小于20000的数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当add()加synchronized关键字时</span></span><br><span class="line"><span class="comment">打印20000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add()方法对应的字节码反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; number++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: dup</span><br><span class="line">    2: getfield      #2                  // Field number:I</span><br><span class="line">    <span class="number">5</span>: iconst_1</span><br><span class="line">    <span class="number">6</span>: iadd</span><br><span class="line">    7: putfield      #2                  // Field number:I</span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n++被拆分成三个指令：</span></span><br><span class="line"><span class="comment">1、执行getfield从主内存拿到原始number</span></span><br><span class="line"><span class="comment">2、执行iadd进行加1操作</span></span><br><span class="line"><span class="comment">3、执行putfield把累加后的值写回主内存</span></span><br><span class="line"><span class="comment">可能会出现写覆盖,因此小于20000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>数值丢失的原因：假设线程1和2同时修改各自工作空间的内容，因此可见性，因此需要重新写入主内存。但在线程1写入时，线程2也同时写入，这导致线程1的写入操作被挂起；线程2写完后线程1继续写入，这样线程1写入的值覆盖了线程2写入的值，造成数据丢失</p>
</li>
<li><p>有序性：计算机在执行程序时为了提高性能，编译器和处理器常常会做<strong>指令重排</strong>，一般分为以下3种：<br><code>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code><br>单线程环境里确保程序最终执行结果和代码顺序执行的结果一致<br>处理器在进行重新排序是必须要考虑指令之间的<strong>数据依赖性</strong><br>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的，结果无法预测</p>
</li>
<li><p>指令重排案例：</p>
<ol>
<li><p>案例一：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">11</span>; <span class="comment">// 语句1</span></span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">12</span>; <span class="comment">// 语句2</span></span><br><span class="line">  x = x + <span class="number">5</span>; <span class="comment">// 语句3</span></span><br><span class="line">  y = x * x; <span class="comment">// 语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 正常单线程情况：1234<br> 多线程环境可能的情况：2134、1324<br> 上述的过程就可以当做是指令的重排，即内部执行顺序和我们的代码顺序不一样。但是指令重排也是有限制的，即不会此情况：4321<br> 因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性。语句4依赖于y以及x的申明，因为存在数据依赖，无法首先执行</p>
</li>
<li><p>案例二：</p>
<p> <code>int a = 0, b = 0, x = 0, y = 0;</code></p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = 0; y = 0;</td>
<td></td>
</tr>
</tbody></table>
<p> 如果编译器对这段代码进行执行重排优化后，可能出现下列情况：</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>x = 2; y = 1;</td>
<td></td>
</tr>
</tbody></table>
<p> 这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程使用的变量能否保持一致是无法确定的</p>
</li>
<li><p>案例三：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResortSeqDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      a = a + <span class="number">5</span>;</span><br><span class="line">      System.out.println(<span class="string">"Value: "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 按照正常的顺序分别调用method01()和method02()，那么最终输出就是a = 6<br> 但如果在多线程环境下，因为method01()和method02()之间不能存在数据依赖的问题，因此原先的顺序可能是</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">a = a + <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"Value:"</span> + a);</span><br></pre></td></tr></table></figure>

<p> 但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">a = a + <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"Value:"</span> + a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p> 先执行flag = true后，另外一个线程马上调用方法2，满足flag的判断，最终a = a + 5，结果为5，这样出现了数据不一致的问题<br> 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测<br> 这就需要通过volatile来修饰变量，来保证线程安全性</p>
</li>
</ol>
</li>
<li><p>volatile对指令重排作用总结：<br>volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象<br>内存屏障(Memory Barrier)又称内存栅栏，是一个CPU指令，作用有两个：</p>
<ol>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)<br>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，即<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本<br><img src="volatile%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile指令重排内存屏障示意图"></li>
</ol>
</li>
<li><p>线程安全保证：</p>
<ol>
<li>工作内存与主内存同步延迟现象导致的可见性问题：<ul>
<li>可通过synchronized或volatile关键字解决，它们都可使一个线程修改后的变量立即对其它线程可见</li>
</ul>
</li>
<li>对于指令重排导致的可见性问题和有序性问题：<ul>
<li>可以使用volatile关键字解决，volatile关键字的另一个作用就是禁止重排序优化</li>
</ul>
</li>
</ol>
</li>
<li><p>volatile的应用：单例模式DCL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version1：普通方式/加synchronized关键字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t Constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> SingletonDemo(); &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较内存地址(单线程) 正确</span></span><br><span class="line">    System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><br><span class="line">    <span class="comment">// 查看打印信息(多线程) -&gt; 打印多次构造器,错误</span></span><br><span class="line">    <span class="comment">// 改进：getInstance()方法添加关键字synchronized</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(</span><br><span class="line">        () -&gt; SingletonDemo.getInstance(),</span><br><span class="line">        <span class="string">"Thread"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过引入synchronized关键字,能够解决高并发环境下的单例模式问题</span></span><br><span class="line"><span class="comment">但synchronized属于重量级的同步机制,它只允许一个线程同时访问获取实例的方法;为了保证数据一致性而减低了并发性,因此采用的比较少</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// version2：DCL(Double Check Lock:双端检锁机制)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 同步代码段的时候，进行检测</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; instance = <span class="keyword">new</span> SingletonDemo(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的DCL(双端检锁)机制不一定线程安全，原因是由于指令重排的存在；加入volatile可以禁止指令重排<br>原因在于某一个线程在执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化：<br><code>instance = new SingletonDemo();</code><br>可以分为以下步骤(伪代码)<br><code>memory = allocate(); // 1、分配对象内存空间</code><br><code>instance(memory); // 2、初始化对象</code><br><code>instance = memory; // 3、设置instance指向刚分配的内存地址,此时instance != null</code><br>步骤2和步骤3不存在数据依赖关系。而且无论重排前还是重排后程序执行的结果在单线程中并没有改变，因此这种重排优化是允许的<br><code>memory = allocate(); // 1、分配对象内存空间</code><br><code>instance = memory; // 3、设置instance指向刚分配的内存地址,此时instance != null;但对象还没有初始化完</code><br><code>instance(memory); // 2、初始化对象</code><br>当我们执行到重排后的步骤2试图获取instance的时候会得到null，因为对象的初始化还没有完成，而在重排后的步骤3才完成。因此执行单例模式的代码时候，就会重新再创建一个instance实例<br><strong>指令重排只会保证串行语义的执行一致性(单线程),并不会关心多线程间的语义一致性</strong><br>所以当一条线程访问instance不为null时，由于instance实例未必完成初始化,也就造成了线程安全问题。因此需要引入volatile来保证出现指令重排的问题，从而保证单例模式的线程安全性</p>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul>
<li><p>概念：<br>CAS的全称是Compare-And-Swap(比较并交换)，它是<strong>一条CPU并发原语</strong><br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子性的<br>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现<strong>CAS汇编指令</strong>，这是一种完全<strong>依赖于硬件</strong>的功能，通过它实现了原子操作。CAS是一种系统原语(属于操作系统原语范畴)，由若干条指令组成，用于完成某个功能的一个过程。<strong>原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的</strong></p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个AtomicInteger实例,并初始化为5</span></span><br><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 调用CAS方法,企图更新成2019</span></span><br><span class="line"><span class="comment">// 两个参数：前者为5，表示期望值;后者为2019,是要求更新的值</span></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">"\t current data = "</span> + atomicInteger.get());</span><br><span class="line"><span class="comment">// 再次调用CAS方法,企图更新成1024</span></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">"\t current data = "</span> + atomicInteger.get());</span><br></pre></td></tr></table></figure>

<p>第一次执行CAS方法时，期望值和原本值满足，因此修改成功，返回true和2019；但第二次执行主内存值已修改为2019，不满足期望值，本次写入失败，因此返回了false和2019<br>类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p>
</li>
<li><p>CAS底层原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// atomicInteger.getAndIncrement()方法源码</span></span><br><span class="line"><span class="comment">// this：当前atomicInteger对象</span></span><br><span class="line"><span class="comment">// valueOffset：内存偏移量,即内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思是通过valueOffset直接利用内存地址获取到值然后进行加1的操作<br>底层又调用了一个unsafe类的getAndAddInt()方法<br>AtomicInteger底层部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Unsafe类：<br> Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(Native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C指针一样直接操作内存。Java中的CAS操作的执行依赖于Unsafe类的方法<br> <code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code><br> <code>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</code></p>
</li>
<li><p>变量valueOffset：表示该变量值(Atomic修饰的值)在内存中的偏移地址，Unsafe就是根据内存偏移地址获取数据的</p>
</li>
<li><p>变量value用volatile修饰：保证多线程之间内存的可见性</p>
</li>
<li><p>具体的unsafe.getAndAddInt()方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// getIntVolatile()和compareAndSwapInt()都是native方法</span></span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解释：</p>
<ul>
<li>参数解释：<ol>
<li>val1：AtomicInteger对象本身</li>
<li>var2：值的引用内存地址</li>
<li>var4：需要增加的int值</li>
<li>var5：用var1和var2找到的主内存中的真实值——即从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值并拷贝到当前线程的本地内存，然后执行compareAndSwapInt()方法再和主内存的值进行比较——在高并发环境下可能主内存值又被更新。线程不可以直接越过高速缓存直接操作主内存，所以需要执行比较方法，值统一后再执行加1操作——底层原子绑定)</li>
</ol>
</li>
<li>实现思路：操作时需要比较当前线程工作内存中的值和主内存中的值，假设执行compareAndSwapInt()方法返回false，那么就一直执行while循环体的内容，一直刷新主内存中的值到当前线程的工作内存，直到期望的值和真实值一样<ol>
<li>用该对象当前的值与var5比较</li>
<li>如果相同，更新为var5 + var4并返回true</li>
<li>如果不同，继续从主内存中取最新的值然后再比较，重复流程1，直到值相同，更新完成<br>该处没有使用synchronized加锁机制，而使用CAS，这能提高并发性，同样也能实现一致性。这是因为每个线程进来后，进入do while循环体，不断地获取内存中的值，判断是否为最新的值，为最新值后再进行更新操作</li>
</ol>
</li>
<li>具体案例：假设线程A和线程B同时执行getAndInt()方法(分别跑在不同的CPU上)<ol>
<li>AtomicInteger里面的value原始值为3(即主内存中AtomicInteger的value为3)，根据JMM模型，线程A和线程B各自持有一份值为3的AtomicInteger副本，并分别存储在各自的工作内存中</li>
<li>线程A通过getIntVolatile()方法拿到最新value值3，此时线程A被挂起(该线程失去CPU执行权)</li>
<li>线程B此时通过getIntVolatile()方法获取到最新value值，也是3。此时线程B没有被挂起，并执行了compareAndSwapInt()方法，主内存的值也是3，成功修改主内存值为4，线程B退出循环</li>
<li>此时线程A恢复，执行compareAndSwapInt()方法，比较发现工作内存的值3和主内存中的值4不一致，说明该值已被其它线程抢先一步修改过。因此A线程本次修改失败，再次进入循环体</li>
<li>线程A重新获取主内存最新的value值，因为变量value被volatile修饰，所以其它线程对它的修改线程A总能够看到，线程A继续执行compareAndSwapInt()方法进行比较并交换直到成功</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Unsafe类的CAS思想：自旋(自我旋转,直到成功)</p>
</li>
<li><p>底层实现：Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="comment">// 先想办法拿到变量value在内存中的地址</span></span><br><span class="line">  <span class="comment">// 通过Atomic::cmpxchg实现比较替换,其中参数X是即将更新的值,参数e是原内存的值</span></span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
</li>
<li><p>CAS缺点：</p>
<ol>
<li>循环时间长，CPU开销大(因为执行的是do-while语句,如果比较不一致会一直循环;最差的情况就是某个线程一直取到的值和预期值都不一样,导致无限循环)</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量执行操作时，可以通过CAS方式来保证原子操作</li>
<li>当对多个共享变量执行操作时，CAS方式就无法保证操作的原子性，此时只能用锁来保证原子性</li>
</ul>
</li>
<li>引出ABA问题</li>
</ol>
</li>
<li><p>ABA问题：</p>
<ul>
<li><p>介绍：<br>CAS算法实现的一个重要前提：需要取出内存中某时刻的数据，并在当下时刻比较并交换，在这个时间差上可能会发生数据的变化<br>比如线程1从内存位置V中取出值为A，此时另一线程2也从内存V中取出A，并且线程2进行了一些操作将值更新为B之后又将值更新为A；这时线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功<br><strong>尽管线程1的CAS操作成功，但不代表该过程就是没有问题的</strong></p>
</li>
<li><p>原子引用AtomicReference(能操作对象)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  String userName;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>, <span class="number">22</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="string">"lisi"</span>, <span class="number">23</span>);</span><br><span class="line">AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">atomicReference.set(user1);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1, user2) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1, user2) + <span class="string">"\t"</span> + atomicReference.get().toString());</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true User&#123;userName='lisi', age=23&#125;</span></span><br><span class="line"><span class="comment">// false User&#123;userName='lisi', age=23&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ABA问题的解决(AtomicStampedReference,新增版本号(类似时间戳)标记)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABA问题的模拟</span></span><br><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">&#125;, <span class="string">"ABA A"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// 暂停1秒,保证t1线程完成ABA操作</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">&#125;, <span class="string">"ABA B"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// true 101</span></span><br><span class="line"><span class="comment">// true 100</span></span><br><span class="line"><span class="comment">// true 2019</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABA问题的解决AtomicStampedReference</span></span><br><span class="line"><span class="comment">// 新增版本号标记数据版本</span></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 1st: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">  <span class="comment">// 等待线程B获取版本号</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 2nd: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">  atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 3rd: "</span> + atomicStampedReference.getStamp());</span><br><span class="line">&#125;, <span class="string">"ABA Solution A"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Version 1st: "</span> + stamp);</span><br><span class="line">  <span class="comment">// 等待线程A完成一次ABA操作</span></span><br><span class="line">  <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">"\t Result = "</span> + atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>) + <span class="string">"\t Current Version = "</span> + atomicStampedReference.getStamp() + <span class="string">"\t Value = "</span> + atomicStampedReference.getReference());</span><br><span class="line">&#125;, <span class="string">"ABA Solution B"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 1st: 1</span></span><br><span class="line"><span class="comment">// ABA Solution B Version 1st: 1</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 2nd: 2</span></span><br><span class="line"><span class="comment">// ABA Solution A Version 3rd: 3</span></span><br><span class="line"><span class="comment">// ABA Solution B Result = false Current Version = 3 Value = 100</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CAS总结：</p>
<ol>
<li>CAS是compare and swap的缩写，表示比较当前工作内存中的值和主物理内存中的值；如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</li>
<li>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</li>
</ol>
</li>
</ul>
<h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.personName = personName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferValueDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    age = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    person.setPersonName(<span class="string">"XXXX"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = <span class="string">"XXX"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TransferValueDemo test = <span class="keyword">new</span> TransferValueDemo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义基本数据类型</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    test.changeValue1(age);</span><br><span class="line">    System.out.println(<span class="string">"age: "</span> + age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化person类</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"SOBXiong"</span>);</span><br><span class="line">    test.changeValue2(person);</span><br><span class="line">    System.out.println(<span class="string">"personName: "</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String</span></span><br><span class="line">    String str = <span class="string">"SOBXiong"</span>;</span><br><span class="line">    test.changeValue3(str);</span><br><span class="line">    System.out.println(<span class="string">"string: "</span> + str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">age: 20</span></span><br><span class="line"><span class="comment">personName: XXXX</span></span><br><span class="line"><span class="comment">string: SOBXiong</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ChangeValue1()执行过程<br>八种基本数据类型，在栈里面分配内存，属于值传递<br><code>栈管运行，堆管存储</code><br>执行changeValue1()时，int是基本数据类型，所以传递的是int = 20这个值，传递的是一个副本，main方法里面的age并没有改变，因此输出的结果age还是20，属于值传递<br><img src="changeValue1()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue1()执行过程图解"></p>
</li>
<li><p>ChangeValue2()执行过程<br>Person是属于对象，作为方法参数时也是值传递，只不过传递的是引用——在堆空间的内存地址。执行changeValue2()时复制了内存地址，两个值都是指向同一个地址<br><img src="changeValue2()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue2()执行过程图解"></p>
</li>
<li><p>ChangeValue3()执行过程<br>String不属于基本数据类型，但是为什么执行完成后值未改变？<br>这时因为String的特殊性，当执行String str = “SOBXiong”的时候，JVM会检查常量池中是否已存在”SOBXiong”，如果存在则不会创建，会生成一个引用指向常量池中的”SOBXiong”并把str赋值为引用的值；如果不存在，则会新建”SOBXiong”并把引用指向它并将str赋值为引用的值<br><img src="changeValue3()%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" alt="changeValue3()执行过程图解"></p>
</li>
</ul>
<h2 id="Java锁的类型"><a href="#Java锁的类型" class="headerlink" title="Java锁的类型"></a>Java锁的类型</h2><ul>
<li><p>公平锁/非公平锁</p>
<ul>
<li>概念：<ol>
<li>公平锁：多个线程按照申请锁的顺序来获取锁，先来先服务，就是公平的，也即队列</li>
<li>非公平锁：多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下有可能造成优先级翻转，或者饥饿线程(某个线程一直得不到锁)</li>
</ol>
</li>
<li>如何创建：<ol>
<li>并发包中ReentrantLock的创建可以指定构造函数的boolean值来得到公平锁/非公平锁，默认是非公平锁，因为非公平锁有吞吐量比公平锁高的优点<br> <code>Lock lock = new ReentrantLock(true);</code></li>
<li>synchronized也是一种非公平锁</li>
</ol>
</li>
<li>两者区别：<ol>
<li><strong>公平锁</strong>：很公平。在并发环境中每个线程在获取锁时会先查看此锁维护的等待队列，如果为空或当前线程是等待队列中的第一个，就占用锁，否则就会加入到等待队列中，此后按照FIFO的规则</li>
<li><strong>非公平锁</strong>：较粗鲁，一上来就直接尝试占有锁，如果尝试失败，再采用类似公平锁的方式</li>
</ol>
</li>
</ul>
</li>
<li><p>可重入锁(递归锁)</p>
<ul>
<li><p>概念：<br>可重入锁就是递归锁<br>指同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，同一线程在外层方法获取锁时，进入内层方法会自动获取锁<br>也即————<strong>线程可以进入任何一个它已拥有的锁所同步的代码块</strong><br>ReentrantLock/Synchronized是典型的可重入锁</p>
</li>
<li><p>作用：可避免死锁</p>
</li>
<li><p>可重入锁验证：</p>
<ul>
<li><p>案例一：验证Synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendSMS()"</span>);</span><br><span class="line">    <span class="comment">// 在同步方法中调用另外一个同步方法</span></span><br><span class="line">    sendEmail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" invoked sendEmail()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    <span class="keyword">new</span> Thread(phone::sendSMS, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(phone::sendSMS, <span class="string">"t2"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure>

<p>说明：sendSMS()同步方法调用sendEmail()同步方法，synchronized锁的是对象，假如不是重入锁，那么sendSMS()方法要获取一次锁，sendEmail()又要获取一次锁，就会造成死锁；由于是同一线程，再次获取锁时就是sendSMS()获取的那个锁，没有新锁产生。同时由于synchronized锁的是对象，线程t1得到锁后，线程t2只能等t1运行完sendSMS()同步方法释放完锁</p>
</li>
<li><p>案例二：验证ReentrantLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">        setLock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" set Lock"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">"t3"</span>);</span><br><span class="line">    Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">"t4"</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    t4.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure>

<p>说明：与加synchronized锁一样，多次获取锁后，锁是重入的，并不会锁死自己</p>
</li>
<li><p>案例三：案例二变形</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure>

<p>说明：结果与案例二一样，因此不管有几把锁，实际都是同一把锁，用同一把钥匙都能打开</p>
</li>
<li><p>案例四：案例三变形</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure>

<p>说明：加锁两次，解锁一次。程序在输出上述两句后阻塞(线程阻塞)，也就是说ReentrantLock申请加锁几次就要解锁几次</p>
</li>
<li><p>案例五：案例三变形</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" get Lock"</span>);</span><br><span class="line">    setLock();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread "t3" Exception in thread "t4" java.lang.IllegalMonitorStateException</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">  at com.xiong.interview.Phone.getLock(ReenterLockDemo.java:16)</span><br><span class="line">  at com.xiong.interview.Phone.run(ReenterLockDemo.java:31)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">  at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">  at com.xiong.interview.Phone.getLock(ReenterLockDemo.java:16)</span><br><span class="line">  at com.xiong.interview.Phone.run(ReenterLockDemo.java:31)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>说明：加锁次数小于解锁次数，直接抛异常</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自旋锁：</p>
<ul>
<li><p>概念：SpinLock，指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU资源<br>上文提及的<a href="##CAS">比较并交换(CAS)</a>底层使用的就是自旋</p>
</li>
<li><p>手写自旋锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原子引用线程</span></span><br><span class="line">  AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123; &#125;</span><br><span class="line">    System.out.println(thread.getName() + <span class="string">" Come in ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(thread.getName() + <span class="string">" Come out ~~~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      spinLockDemo.myLock();</span><br><span class="line">      <span class="comment">// 暂停一会</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      spinLockDemo.myUnlock();</span><br><span class="line">    &#125;,<span class="string">"Thread A"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停一会</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      spinLockDemo.myLock();</span><br><span class="line">      spinLockDemo.myUnlock();</span><br><span class="line">    &#125;,<span class="string">"Thread B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread A Come in ~~~</span><br><span class="line">Thread A Come out ~~~</span><br><span class="line">Thread B Come in ~~~</span><br><span class="line">Thread B Come out ~~~</span><br></pre></td></tr></table></figure>

<p>说明：打印第1句5s后打印后三句话，而且out紧接第一句话。A线程调用myLock()方法自己持有锁5s，线程B进入方法后发现有线程持有锁，因此只能通过自旋等待，A线程调用myUnlock()方法释放锁后，线程B才能继续执行</p>
</li>
</ul>
</li>
<li><p>独占锁(写锁)/共享锁(读锁)/互斥锁</p>
<ul>
<li><p>概念：<br>独占锁：指该锁一次只能被一个线程所持有。ReentrantLock和Synchronized都是独占锁<br>共享锁：指该锁可以被多个线程锁持有<br>ReentrantReadWriteLock其读锁是共享，写锁是独占。写的时候只能一个人写，但是读的时候可以多个人同时读。读锁的共享锁可保证并发读是非常高效的。读写/写写的过程是互斥的</p>
</li>
<li><p>为什么会有写锁和读锁：<br>独占锁一次只能一个线程访问，但有一个读写分离的场景，读时想同时进行，原来独占锁的并发性就没这么好了。读锁并不会造成数据不一致的问题，因此可以多个人共享读<br>多个线程同时读一个资源类没有任何问题，为了满足并发，读取共享资源应该可以同时进行。但若有一个线程去写共享资源，就不应该再有其他线程对该资源进行读或写操作</p>
</li>
<li><p>案例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写入："</span> + key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写入完成"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读取:"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = map.get(key);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读取完成："</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">    <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; myCache.put(tempInt + <span class="string">""</span>, tempInt + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; myCache.get(tempInt + <span class="string">""</span>), String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>运行结果如下</code></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">3 正在写入：3</span><br><span class="line">2 正在写入：2</span><br><span class="line">1 正在写入：1</span><br><span class="line">4 正在写入：4</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">0 写入完成</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">3 写入完成</span><br><span class="line">2 写入完成</span><br><span class="line">2 读取完成：2</span><br><span class="line">4 写入完成</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">1 读取完成：null</span><br></pre></td></tr></table></figure>

<ul>
<li><p>案例说明：在写入时，写线程被其他线程打断，这就造成还没写完就被挂起，其他线程开始写，这可能会造成数据的不一致。写操作需要原子 + 独占，整个过程必须是一个完整的统一体，中间不许被分割、打断。结果的打印顺序与真实顺序有出入，因为也是多线程的，实际读取到null的应该在写入完成之前执行</p>
</li>
<li><p>解决方案：加读写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增量部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个读写锁,是一个读写一体的锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写锁加锁</span></span><br><span class="line">  lock.writeLock().lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写入："</span> + key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写入完成"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 写锁释放</span></span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读锁加锁</span></span><br><span class="line">  lock.readLock().lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读取:"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟网络拥堵</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读取完成："</span> + map.get(key));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 读锁释放</span></span><br><span class="line">    lock.readLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">0 写入完成</span><br><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">1 读取完成：1</span><br><span class="line">3 读取完成：3</span><br><span class="line">2 读取完成：2</span><br><span class="line">4 读取完成：4</span><br><span class="line">0 读取完成：0</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案说明：写锁一次只允许一个线程进入执行写操作，而读锁允许多个线程同时进入执行读取的操作。结果证明写入操作中间不会被打断，而读操作可以同时进入</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁及定位分析"><a href="#死锁及定位分析" class="headerlink" title="死锁及定位分析"></a>死锁及定位分析</h2><ul>
<li><p>死锁概念：死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象。若无外力干涉，那它们都将无法继续推进下去。如果资源充足，进程的资源请求都能得到满足，死锁出现的可能性很低，否则就会因争夺有限的资源而陷入死锁<br><img src="%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="死锁情况示意图"></p>
</li>
<li><p>产生原因：</p>
<ol>
<li>系统资源不足</li>
<li>进程运行推进的顺序不对</li>
<li>资源分配不当</li>
</ol>
</li>
<li><p>死锁产生的四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
</li>
<li><p>死锁案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object lockA;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object lockB;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(Object lockA, Object lockB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">    <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 自己持有&#123;"</span> + lockA + <span class="string">"&#125; , 尝试获得&#123;"</span> + lockB + <span class="string">'&#125;'</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 自己持有&#123;"</span> + lockB + <span class="string">"&#125; , 尝试获得&#123;"</span> + lockA + <span class="string">'&#125;'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object lockA = <span class="keyword">new</span> Object(), lockB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">new</span> HoldLockThread(lockA, lockB).run(), <span class="string">"Thread A"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">new</span> HoldLockThread(lockB, lockA).run(), <span class="string">"Thread B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果如下</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread B 自己持有&#123;java.lang.Object@1b77d269&#125; , 尝试获得&#123;java.lang.Object@42f5503f&#125;</span><br><span class="line">Thread A 自己持有&#123;java.lang.Object@42f5503f&#125; , 尝试获得&#123;java.lang.Object@1b77d269&#125;</span><br></pre></td></tr></table></figure>

<p>说明：打印上述信息后，主线程阻塞，无法结束</p>
</li>
<li><p>排查死锁：</p>
<ol>
<li><p>使用jps命令定位进程编号：jps -l<br> <img src="jps%E5%AE%9A%E4%BD%8Djava%E8%BF%9B%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="jps定位java进程示意图"></p>
</li>
<li><p>使用jstack命令查看堆栈信息：jstack pid</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.251-b08 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #14 daemon prio=9 os_prio=31 tid=0x00007fcd65818000 nid=0x5903 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"DestroyJavaVM" #13 prio=5 os_prio=31 tid=0x00007fcd6607d000 nid=0xe03 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Thread B" #12 prio=5 os_prio=31 tid=0x00007fcd67815000 nid=0x5803 waiting for monitor entry [0x0000700006488000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$2/1595428806.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Thread A" #11 prio=5 os_prio=31 tid=0x00007fcd638b8000 nid=0x5703 waiting for monitor entry [0x0000700006385000]</span><br><span class="line">  java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$0(DeadLockDemo.java:33)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$1/2065951873.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Service Thread" #10 daemon prio=9 os_prio=31 tid=0x00007fcd64056800 nid=0xa903 runnable [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread3" #9 daemon prio=9 os_prio=31 tid=0x00007fcd66057800 nid=0x4203 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread2" #8 daemon prio=9 os_prio=31 tid=0x00007fcd65052800 nid=0x4303 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread1" #7 daemon prio=9 os_prio=31 tid=0x00007fcd63843000 nid=0x4403 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #6 daemon prio=9 os_prio=31 tid=0x00007fcd6604e800 nid=0x4603 waiting on condition [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Monitor Ctrl-Break" #5 daemon prio=5 os_prio=31 tid=0x00007fcd6780e800 nid=0x3f03 runnable [0x0000700005c70000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">        - locked &lt;0x000000076ac839b8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">        at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">        - locked &lt;0x000000076ac839b8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:61)</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" #4 daemon prio=9 os_prio=31 tid=0x00007fcd6701b000 nid=0x4803 runnable [0x0000000000000000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=31 tid=0x00007fcd65813800 nid=0x3103 in Object.wait() [0x0000700005964000]</span><br><span class="line">  java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab08ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x000000076ab08ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=31 tid=0x00007fcd66813000 nid=0x2f03 in Object.wait() [0x0000700005861000]</span><br><span class="line">  java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076ab06c00&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x000000076ab06c00&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=31 tid=0x00007fcd6580f000 nid=0x4f03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" os_prio=31 tid=0x00007fcd6500c800 nid=0x2007 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=31 tid=0x00007fcd6500d000 nid=0x1b03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#2 (ParallelGC)" os_prio=31 tid=0x00007fcd6500e000 nid=0x1d03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#3 (ParallelGC)" os_prio=31 tid=0x00007fcd65012800 nid=0x2a03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#4 (ParallelGC)" os_prio=31 tid=0x00007fcd65013800 nid=0x2c03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#5 (ParallelGC)" os_prio=31 tid=0x00007fcd65014000 nid=0x5303 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#6 (ParallelGC)" os_prio=31 tid=0x00007fcd65014800 nid=0x2e03 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#7 (ParallelGC)" os_prio=31 tid=0x00007fcd65015000 nid=0x5103 runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=31 tid=0x00007fcd65053000 nid=0xa803 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 319</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread B":</span><br><span class="line">  waiting to lock monitor 0x00007fcd6504d758 (object 0x000000076ac374a8, a java.lang.Object),</span><br><span class="line">  which is held by "Thread A"</span><br><span class="line">"Thread A":</span><br><span class="line">  waiting to lock monitor 0x00007fcd6504d6a8 (object 0x000000076ac374b8, a java.lang.Object),</span><br><span class="line">  which is held by "Thread B"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread B":</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$1(DeadLockDemo.java:34)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$2/1595428806.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"Thread A":</span><br><span class="line">        at com.xiong.interview.HoldLockThread.run(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ac374b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ac374a8&gt; (a java.lang.Object)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo.lambda$main$0(DeadLockDemo.java:33)</span><br><span class="line">        at com.xiong.interview.DeadLockDemo$$Lambda$1/2065951873.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p> 说明：查看最后一行，看到<code>Found 1 deadlock</code>，即存在一个死锁，上面的部分信息指示了出现问题的文件和行数</p>
</li>
</ol>
</li>
</ul>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://sobxiong.github.io/2020/09/18/ProgrammingLanguage/Java/JUC/>https://sobxiong.github.io/2020/09/18/ProgrammingLanguage/Java/JUC/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-11-15T16:36:30+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2020年11月15日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java%E9%AB%98%E7%BA%A7/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java高级</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://sobxiong.github.io/2020/09/18/ProgrammingLanguage/Java/JUC/&title=JUC - SOBXiong的博客&summary=内容
JUC是什么
Lock接口
线程间通信
线程间定制化调用通信
线程八锁
线程不安全集合
Callable接口
JUC辅助类
BlockingQueue阻塞队列
ThreadPool线程池
Java8流式计算
Java8分支合并
异步回调
volatile
CAS
值传递和引用传递
Java锁的类型
死锁及定位分析
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://sobxiong.github.io/2020/09/18/ProgrammingLanguage/Java/JUC/&title=JUC - SOBXiong的博客&summary=内容
JUC是什么
Lock接口
线程间通信
线程间定制化调用通信
线程八锁
线程不安全集合
Callable接口
JUC辅助类
BlockingQueue阻塞队列
ThreadPool线程池
Java8流式计算
Java8分支合并
异步回调
volatile
CAS
值传递和引用传递
Java锁的类型
死锁及定位分析
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://sobxiong.github.io/2020/09/18/ProgrammingLanguage/Java/JUC/&title=JUC - SOBXiong的博客&summary=内容
JUC是什么
Lock接口
线程间通信
线程间定制化调用通信
线程八锁
线程不安全集合
Callable接口
JUC辅助类
BlockingQueue阻塞队列
ThreadPool线程池
Java8流式计算
Java8分支合并
异步回调
volatile
CAS
值传递和引用传递
Java锁的类型
死锁及定位分析
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/09/26/ProgrammingLanguage/Java/JVM/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>JVM</p>
                <p class='content'>内容
JVM体系结构概述
堆体系结构概述
堆参数调优



JVM体系结构概述
JVM位置：运行与操作系统之上(可以认为是一种中间件)，与硬件没有直接的交互

JVM结构

类装载器Class...</p>
              </a>
            
            
              <a class='next' href='/2020/09/06/Middleware/Nginx/'>
                <p class='title'>Nginx<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>内容
Nginx简介
Nginx安装
Nginx常用的命令和配置文件
Nginx配置实例-反向代理
Nginx配置实例-负载均衡
Nginx配置实例-动静分离
Nginx搭建高可用集群
Ngin...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'JUC',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-text">内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC是什么"><span class="toc-text">JUC是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock接口"><span class="toc-text">Lock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间通信"><span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间定制化调用通信"><span class="toc-text">线程间定制化调用通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程八锁"><span class="toc-text">线程八锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程不安全集合"><span class="toc-text">线程不安全集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable接口"><span class="toc-text">Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC辅助类"><span class="toc-text">JUC辅助类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockingQueue阻塞队列"><span class="toc-text">BlockingQueue阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPool线程池"><span class="toc-text">ThreadPool线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8流式计算"><span class="toc-text">Java8流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8分支合并"><span class="toc-text">Java8分支合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步回调"><span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#值传递和引用传递"><span class="toc-text">值传递和引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java锁的类型"><span class="toc-text">Java锁的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁及定位分析"><span class="toc-text">死锁及定位分析</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="mailto:1942991710@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/SOBXiong"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="http://xiongjc.top" target="_blank" rel="noopener">Copyright © 2017-2020 SOBXiong</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
    appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
    placeholder: "快来评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
